<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Data Marketplace | Provider Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Data Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Provider Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
        <div class="header-right header-right-with-actions">
            <div class="header-actions">
                <a class="icon-btn" href="admin.html" title="Open Admin Area" aria-label="Open Admin Area">
                    <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M12.0002 8C9.79111 8 8.00024 9.79086 8.00024 12C8.00024 14.2091 9.79111 16 12.0002 16C14.2094 16 16.0002 14.2091 16.0002 12C16.0002 9.79086 14.2094 8 12.0002 8ZM10.0002 12C10.0002 10.8954 10.8957 10 12.0002 10C13.1048 10 14.0002 10.8954 14.0002 12C14.0002 13.1046 13.1048 14 12.0002 14C10.8957 14 10.0002 13.1046 10.0002 12Z" />
                        <path fill-rule="evenodd" clip-rule="evenodd" d="M11.2867 0.5C9.88583 0.5 8.6461 1.46745 8.37171 2.85605L8.29264 3.25622C8.10489 4.20638 7.06195 4.83059 6.04511 4.48813L5.64825 4.35447C4.32246 3.90796 2.83873 4.42968 2.11836 5.63933L1.40492 6.83735C0.67773 8.05846 0.954349 9.60487 2.03927 10.5142L2.35714 10.7806C3.12939 11.4279 3.12939 12.5721 2.35714 13.2194L2.03927 13.4858C0.954349 14.3951 0.67773 15.9415 1.40492 17.1626L2.11833 18.3606C2.83872 19.5703 4.3225 20.092 5.64831 19.6455L6.04506 19.5118C7.06191 19.1693 8.1049 19.7935 8.29264 20.7437L8.37172 21.1439C8.6461 22.5325 9.88584 23.5 11.2867 23.5H12.7136C14.1146 23.5 15.3543 22.5325 15.6287 21.1438L15.7077 20.7438C15.8954 19.7936 16.9384 19.1693 17.9553 19.5118L18.3521 19.6455C19.6779 20.092 21.1617 19.5703 21.8821 18.3606L22.5955 17.1627C23.3227 15.9416 23.046 14.3951 21.9611 13.4858L21.6432 13.2194C20.8709 12.5722 20.8709 11.4278 21.6432 10.7806L21.9611 10.5142C23.046 9.60489 23.3227 8.05845 22.5955 6.83732L21.8821 5.63932C21.1617 4.42968 19.678 3.90795 18.3522 4.35444L17.9552 4.48814C16.9384 4.83059 15.8954 4.20634 15.7077 3.25617L15.6287 2.85616C15.3543 1.46751 14.1146 0.5 12.7136 0.5H11.2867ZM10.3338 3.24375C10.4149 2.83334 10.7983 2.5 11.2867 2.5H12.7136C13.2021 2.5 13.5855 2.83336 13.6666 3.24378L13.7456 3.64379C14.1791 5.83811 16.4909 7.09167 18.5935 6.38353L18.9905 6.24984C19.4495 6.09527 19.9394 6.28595 20.1637 6.66264L20.8771 7.86064C21.0946 8.22587 21.0208 8.69271 20.6764 8.98135L20.3586 9.24773C18.6325 10.6943 18.6325 13.3057 20.3586 14.7523L20.6764 15.0186C21.0208 15.3073 21.0946 15.7741 20.8771 16.1394L20.1637 17.3373C19.9394 17.714 19.4495 17.9047 18.9905 17.7501L18.5936 17.6164C16.4909 16.9082 14.1791 18.1618 13.7456 20.3562L13.6666 20.7562C13.5855 21.1666 13.2021 21.5 12.7136 21.5H11.2867C10.7983 21.5 10.4149 21.1667 10.3338 20.7562L10.2547 20.356C9.82113 18.1617 7.50931 16.9082 5.40665 17.6165L5.0099 17.7501C4.55092 17.9047 4.06104 17.714 3.83671 17.3373L3.1233 16.1393C2.9058 15.7741 2.97959 15.3073 3.32398 15.0186L3.64185 14.7522C5.36782 13.3056 5.36781 10.6944 3.64185 9.24779L3.32398 8.98137C2.97959 8.69273 2.9058 8.2259 3.1233 7.86067L3.83674 6.66266C4.06106 6.28596 4.55093 6.09528 5.0099 6.24986L5.40676 6.38352C7.50938 7.09166 9.82112 5.83819 10.2547 3.64392L10.3338 3.24375Z" />
                    </svg>
                </a>
            </div>
            <div class="header-line" id="headerPubkey">
                <strong>Provider Pubkey:</strong>
                <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerAddress">
                <strong>Provider Address:</strong>
                <span class="inline">
                    <span id="headerAddressValue"></span>
                    <button class="copy-btn" onclick="copyAddressFromHeader()">Copy</button>
                </span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Provider Balance:</strong></div>
            <div class="header-line muted" id="headerBlock">
                <strong>Current Block:</strong>
                <div class="header-line fixed-pill" style="justify-content: flex-end;">
                    <span id="syncPill" class="status-badge status-warn hidden">Syncing...</span>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <div class="row-between align-center">
        <h2 class="mt-0 mb-0">Provider Earnings</h2>
        <div class="range-toggle">
            <button class="toggle-btn" data-range="daily" onclick="changeEarningsRange('daily')">Daily</button>
            <button class="toggle-btn" data-range="weekly" onclick="changeEarningsRange('weekly')">Weekly</button>
            <button class="toggle-btn" data-range="monthly" onclick="changeEarningsRange('monthly')">Monthly</button>
            <button class="toggle-btn active" data-range="all_time" onclick="changeEarningsRange('all_time')">All Time</button>
        </div>
    </div>
    <div class="chart-wrapper">
        <canvas id="earningsChart" height="220"></canvas>
        <div id="earningsChartEmpty" class="muted chart-empty hidden"></div>
    </div>
    <div id="earningsChartStatus" class="muted small-text"></div>
    <div id="claimTotals" class="claims-grid muted card-body" data-has-content="0">(loading claim totals...)</div>
</div>

<div class="card">
    <h2>Sentinel Info</h2>
    <div class="row">
        <div class="col">
            <div class="stack panel mb-8">
                <div class="pill-row">
                    <div class="status-badge status-warn" id="sentinelStatusBadgeTop">(loading)</div>
                </div>
                <div class="actions">
                    <button class="primary" onclick="controlSentinel('restart')">Restart Sentinel</button>
                    <button class="primary" onclick="controlSentinel('stop')">Stop Sentinel</button>
                    <button class="primary" onclick="controlSentinel('start')">Start Sentinel</button>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 1: Provide Sentinel Details</h3>
                    <p>Configure your sentinel settings before bonding a service.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="sentinel.html">Open Sentinel Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Provider Services</h2>
    <div class="row">
        <div class="col">
            <div class="panel mb-12">
                <div id="providerServices" class="muted">(loading services...)</div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 2: Add Provider Services</h3>
                    <p>Bond and modify provider services for the marketplace.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="provider.html">Open Provider Services Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Access Points</h2>

    <div class="row">
        <div class="col">
            <div class="panel mb-12">

                <div id="endpointList" class="muted ws-normal"></div>

            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 3: Export</h3>
                    <p>Export your configs to make it easier to update/restore your docker later.</p>
                    <div class="actions">
                        <button class="primary" onclick="runProviderExport()">Provider Export</button>
                        <button class="primary" onclick="triggerProviderImport()">Provider Import</button>
                        <input type="file" id="providerImportInput" class="hidden" accept="application/json" onchange="handleProviderImport(event)" />
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="section">

        <h3>Claim Status</h3>
        <div class="actions mb-8">
            <button class="primary" onclick="runClaimsAndContracts()">Run Claims + Refresh Contracts</button>
        </div>
        <div class="muted" id="claimsHeartbeat">Last claims run: (unknown)</div>
        <pre id="claimStatusLog">Waiting for updates...</pre>

        <h3>Debug</h3>
        <button class="primary" onclick="refreshInfo()">Refresh Info</button>
        <p id="version">Loading arkeod version...</p>
        <span id="refreshBadge" class="status-badge status-warn hidden mb-8">Refreshing…</span>
        <pre id="debugInfo">Loading...</pre>
    </div>
</div>

<div id="adminPasswordGate" class="overlay overlay-strong hidden">
    <div class="overlay-card password-card">
        <div class="password-title">
            <span>Arkeo Data Marketplace</span>
            <span class="sep">|</span>
            <span class="sub">Provider Manager</span>
        </div>
        <form onsubmit="submitAdminPasswordGate(event); return false;">
            <div class="password-body">
                <h3 class="mt-6 mb-0">Password Required</h3>
                <p class="muted">Enter the admin password to continue.</p>
                <input type="text" name="admin-username-filler" autocomplete="username" value="admin" class="hidden" aria-hidden="true" tabindex="-1" />
                <input type="password" id="adminPasswordGateInput" autocomplete="current-password" placeholder="Admin password" />
            </div>
            <div class="actions center mt-6">
                <button class="primary" type="submit">Unlock</button>
            </div>
            <div id="adminPasswordGateStatus" class="muted mt-6"></div>
        </form>
    </div>
</div>

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <pre id="modalBody"></pre>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<script>
    const DEFAULT_ADMIN_API_PORT = (() => {
        try {
            const url = new URL(window.location.href);
            return url.searchParams.get("api_port") || "9999";
        } catch (e) {
            return "9999";
        }
    })();
    const DEFAULT_ADMIN_UI_PORT = (() => {
        try {
            const url = new URL(window.location.href);
            return url.searchParams.get("ui_port") || "8080";
        } catch (e) {
            return "8080";
        }
    })();
    let adminHost = (window.location && window.location.hostname) || "localhost";
    let adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);

    function buildBaseUrl(host, port) {
        const proto = (window.location && window.location.protocol === "https:") ? "https:" : "http:";
        const cleaned = (host || "").replace(/^https?:\/\//, "").replace(/\/+$/, "");
        return `${proto}//${cleaned}${port ? `:${port}` : ""}`;
    }

    async function detectAdminApiBase() {
        const tried = new Set();
        // Try explicit API host/port if passed in URL (?api_host=..&api_port=..)
        let apiHostOverride = null;
        let apiPortOverride = null;
        try {
            const u = new URL(window.location.href);
            apiHostOverride = u.searchParams.get("api_host") || null;
            apiPortOverride = u.searchParams.get("api_port") || null;
        } catch (e) {}

        const candidatePorts = [
            apiPortOverride,
            "9990",
            DEFAULT_ADMIN_API_PORT,
            "9999",
        ].filter(Boolean);
        for (const port of candidatePorts) {
            const hostToUse = apiHostOverride || adminHost;
            const base = buildBaseUrl(hostToUse, port);
            if (tried.has(base)) continue;
            tried.add(base);
            try {
                const res = await fetch(`${base}/api/ping`, { cache: "no-store" });
                if (res.ok) {
                    adminApiBase = base;
                    return;
                }
            } catch (e) {
                continue;
            }
        }
        // fallback: keep existing adminApiBase
    }

    async function refreshVitals() {
        const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
        const parseSafe = async (settled) => {
            if (settled.status !== "fulfilled" || !settled.value) return { error: String(settled.reason || "request failed") };
            try {
                if (!settled.value.ok) {
                    const text = await settled.value.text().catch(() => "");
                    return { error: `${settled.value.status} ${settled.value.statusText || ""}`, body: text };
                }
                return await settled.value.json();
            } catch (err) {
                return { error: "invalid json", detail: String(err) };
            }
        };
        try {
            const [balRes, heightRes] = await Promise.allSettled([
                fetchNoStore(resolveApi("/api/balance")),
                fetchNoStore(resolveApi("/api/block-height")),
            ]);
            lastBalance = await parseSafe(balRes);
            lastBlockHeight = await parseSafe(heightRes);
        } catch (e) {
            // leave last values as-is on error
        }
        const headerBalanceEl = document.getElementById("headerBalance");
        const headerBlockEl = document.getElementById("headerBlock");
        if (headerBalanceEl) headerBalanceEl.innerHTML = `<strong>Provider Balance:</strong> ${formatBalance(lastBalance)}`;
        if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${formatBlockHeight(lastBlockHeight)}`;
    }

    function extractHostFromValue(val) {
        if (!val) return "";
        try {
            const u = val.startsWith("http") ? new URL(val) : new URL(`http://${val}`);
            return u.hostname || "";
        } catch (e) {
            return "";
        }
    }

    function setAdminHost(candidateHost) {
        if (!candidateHost) return;
        const cleaned = extractHostFromValue(candidateHost) || candidateHost;
        if (cleaned && cleaned !== adminHost) {
            adminHost = cleaned;
            adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);
        }
    }

    function resolveApi(path) {
        if (!path.startsWith("/")) path = `/${path}`;
        return `${adminApiBase}${path}`;
    }

    function isLocalHost(host) {
        const h = (host || "").toLowerCase();
        return h === "localhost" || h === "127.0.0.1" || h === "";
    }

    function updateHostFromConfig(sCfg, metaObj) {
        const envLower = (sCfg && sCfg.env) || {};
        const envFile = (sCfg && sCfg.env_file) || {};
        const meta = metaObj || {};
        const pickEnv = (keyUpper) => {
            const lower = keyUpper.toLowerCase();
            return (envFile[keyUpper] ?? envLower[lower] ?? "");
        };
        const pickMeta = (key) => meta[key] || meta[key.toUpperCase()] || meta[key.toLowerCase()] || "";
        const adminHostOverride = pickEnv("ADMIN_HOST") || pickMeta("ADMIN_HOST");
        const sentinelNode = pickEnv("SENTINEL_NODE") || pickMeta("SENTINEL_NODE");
        const sentinelHost = extractHostFromValue(sentinelNode);
        const currentIsLocal = isLocalHost(adminHost);
        const chosen = adminHostOverride || (currentIsLocal ? sentinelHost : "");
        // Do not override adminApiBase; keep using the page host for API calls
    }

    const BLOCK_TIME_SECONDS = 5.8;
    const EARNINGS_TIME_WINDOWS = {
        daily: 86400,
        weekly: 604800,
        monthly: 2592000,
    };
    const EARNINGS_CACHE_MS = 60000;

let providerServicesData = [];
let providerServiceTotals = [];
let providerServiceLookup = {};
let lastSentinelConfig = null;
let lastBalance = null;
let lastBlockHeight = null;
let lastClaimsRun = null;
let lastClaimsHeartbeat = null;
let earningsRange = "all_time";
let earningsChartInstance = null;
let earningsChartCache = {};
    let currentPubkey = "";
    let adminPasswordEnabled = false;
    let adminSessionAuthed = false;
    function requirePasswordGate() {
        sessionStorage.removeItem("adminAuthed");
        adminSessionAuthed = false;
        const gate = document.getElementById("adminPasswordGate");
        if (gate) gate.classList.remove("hidden");
    }
    const realFetch = window.fetch.bind(window);
    window.fetch = (url, options = {}) =>
        realFetch(url, { credentials: "include", ...options }).then((resp) => {
            if (resp && resp.status === 401) {
                requirePasswordGate();
            }
            return resp;
        });

    async function refreshInfo() {
        const debugEl = document.getElementById("debugInfo");
        debugEl.textContent = "Loading...";
        const refreshBadge = document.getElementById("refreshBadge");
        const headerPill = document.getElementById("headerRefreshPill");
        if (refreshBadge) refreshBadge.style.display = "inline-block";
        if (headerPill) headerPill.style.display = "inline-block";
        try {
            const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
            const [provRes, keyRes, sentRes, sCfgRes, metaRes, settingsRes] = await Promise.allSettled([
                fetchNoStore(resolveApi("/api/provider-info")),
                fetchNoStore(resolveApi("/api/key")),
                fetchNoStore(resolveApi("/api/sentinel-status")),
                fetchNoStore(resolveApi("/api/sentinel-config")),
                fetchNoStore(resolveApi("/api/sentinel-metadata?quiet=1")),
                fetchNoStore(resolveApi("/api/provider-settings")),
            ]);
            const parseSafe = async (settled) => {
                if (settled.status !== "fulfilled" || !settled.value) return { error: String(settled.reason || "request failed") };
                try {
                    if (!settled.value.ok) {
                        const text = await settled.value.text().catch(() => "");
                        return { error: `${settled.value.status} ${settled.value.statusText || ""}`, body: text };
                    }
                    return await settled.value.json();
                } catch (err) {
                    return { error: "invalid json", detail: String(err) };
                }
            };
            const prov = await parseSafe(provRes);
            const key = await parseSafe(keyRes);
            const sentinelStatus = await parseSafe(sentRes);
            const sentinelConfig = await parseSafe(sCfgRes);
            const meta = await parseSafe(metaRes);
            const settings = await parseSafe(settingsRes);
            // cache sentinel config for service rendering
            lastSentinelConfig = sentinelConfig && !sentinelConfig.error ? sentinelConfig : null;
            // Provider summary at top
            const metaCfg = (meta && meta.metadata && meta.metadata.config) || {};
            const envMeta = (prov && prov.provider_metadata) || {};
            updateHostFromConfig(sentinelConfig, envMeta);
            const moniker =
                metaCfg.moniker ||
                metaCfg.provider_name ||
                envMeta.MONIKER ||
                envMeta.PROVIDER_NAME ||
                "";
            const desc = metaCfg.description || envMeta.DESCRIPTION || "";
            const bech32Pubkey =
                (prov && prov.pubkey && prov.pubkey.bech32) ||
                (key && key.pubkey && key.pubkey.bech32) ||
                "(unknown)";
            const bech32Address =
                (prov && (prov.address || prov.addr || prov.provider_address || prov.operator_address)) ||
                (key && (key.address || key.addr || key.provider_address || key.operator_address)) ||
                "";
            currentPubkey = bech32Pubkey || "";
            const shortPubkey = formatPubkeyShort(currentPubkey);
            const shortAddress = formatAddressShort(bech32Address);
            const summaryEl = document.getElementById("providerSummary");
            if (summaryEl) summaryEl.innerHTML = "";
            const headerMonikerEl = document.getElementById("headerMoniker");
            const headerDescEl = document.getElementById("headerDescription");
            const headerBalanceEl = document.getElementById("headerBalance");
            const headerBlockEl = document.getElementById("headerBlock");
            const headerPubEl = document.getElementById("headerPubkey");
            const headerAddrEl = document.getElementById("headerAddress");
            if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
            if (headerDescEl) headerDescEl.textContent = desc || "";
            if (headerBalanceEl) headerBalanceEl.innerHTML = `<strong>Provider Balance:</strong> ${formatBalance(lastBalance)}`;
            if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${formatBlockHeight(lastBlockHeight)}`;
            if (headerPubEl) {
                const valEl = document.getElementById("headerPubkeyValue");
                if (valEl) valEl.textContent = shortPubkey;
                headerPubEl.dataset.fullPubkey = currentPubkey;
            }
            if (headerAddrEl) {
                const addrEl = document.getElementById("headerAddressValue");
                if (addrEl) addrEl.textContent = shortAddress || "(unavailable)";
                headerAddrEl.dataset.fullAddress = bech32Address || "";
            }
            renderEndpointPanel(sentinelConfig, prov, envMeta, settings);
            debugEl.textContent = JSON.stringify(
                {
                    provider_info: prov,
                    balance: lastBalance,
                    key: key,
                    sentinel_metadata: meta,
                    sentinel_config: sentinelConfig,
                    sentinel_status: sentinelStatus,
                    block_height: lastBlockHeight,
                },
                null,
                2
            );
            if (sentinelConfig && sentinelConfig.raw) {
                const sentinelYamlEl = document.getElementById("sentinelYamlStatus");
                if (sentinelYamlEl) {
                    sentinelYamlEl.textContent = sentinelConfig.raw;
                }
                const sentinelEnvEl = document.getElementById("sentinelEnvStatus");
                if (sentinelEnvEl && sentinelConfig.env_file) {
                    sentinelEnvEl.textContent = JSON.stringify(sentinelConfig.env_file, null, 2);
                }
            }
            updateSentinelStatusDisplay(sentinelStatus);
        } catch (e) {
            debugEl.textContent = "Failed to load info: " + e;
        }
        if (refreshBadge) refreshBadge.style.display = "none";
        if (headerPill) headerPill.style.display = "none";
    }

    async function refreshServices() {
        const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
        const parseSafe = async (settled) => {
            if (settled.status !== "fulfilled" || !settled.value) return { error: String(settled.reason || "request failed") };
            try {
                if (!settled.value.ok) {
                    const text = await settled.value.text().catch(() => "");
                    return { error: `${settled.value.status} ${settled.value.statusText || ""}`, body: text };
                }
                return await settled.value.json();
            } catch (err) {
                return { error: "invalid json", detail: String(err) };
            }
        };
        try {
            const [svcRes, allSvcRes] = await Promise.allSettled([
                fetchNoStore(resolveApi("/api/provider-services")),
                fetchNoStore(resolveApi("/api/services")),
            ]);
            const services = await parseSafe(svcRes);
            const allServices = await parseSafe(allSvcRes);

            const svcLookup = {};
            if (allServices && Array.isArray(allServices.services)) {
                allServices.services.forEach(s => {
                    const rawId = s && (s.id ?? s.service_id ?? s.serviceID);
                    const key = rawId !== undefined && rawId !== null ? String(rawId) : "";
                    const name = s ? (s.name || s.service || s.label || "") : "";
                    const desc = s ? (s.description || s.desc || s.label || "") : "";
                    if (key) {
                        const val = { name, description: desc, service: s.service };
                        svcLookup[key] = val;
                        const numKey = Number(key);
                        if (!Number.isNaN(numKey)) {
                            svcLookup[String(numKey)] = val;
                        }
                    }
                });
            }
            providerServiceLookup = svcLookup;
            providerServicesData = services && Array.isArray(services.services) ? services.services : [];

            const sentinelServices = [];
            const cfg = lastSentinelConfig;
            if (cfg && cfg.config && Array.isArray(cfg.config.services)) {
                cfg.config.services.forEach(ss => {
                    if (!ss || typeof ss !== "object") return;
                    const sid = ss.id !== undefined && ss.id !== null ? String(ss.id) : "";
                    const sname = ss.name || ss.service;
                    if (sid) sentinelServices.push({ id: sid, name: sname });
                    else if (sname) sentinelServices.push({ name: sname });
                });
            }

            const svcEl = document.getElementById("providerServices");
            if (providerServicesData && providerServicesData.length) {
                const items = providerServicesData.map((s, idx) => {
                    let rawId = "";
                    let rawName = "";
                    if (s && typeof s === "object") {
                        const candidateId = s.id ?? s.service_id ?? s.serviceID;
                        rawId = candidateId !== undefined && candidateId !== null ? String(candidateId) : "";
                        rawName = s.name || s.service || s.label || "";
                    } else if (typeof s === "string" || typeof s === "number") {
                        rawName = String(s);
                    }
                    if (!rawId && rawName && /^[0-9]+$/.test(rawName)) {
                        rawId = rawName;
                    }

                    let resolvedName = rawName;
                    const lookupById = rawId ? svcLookup[rawId] : "";
                    const lookupName = lookupById && typeof lookupById === "object" ? (lookupById.name || lookupById.label || lookupById.service || "") : lookupById;
                    const lookupDesc = lookupById && typeof lookupById === "object" ? lookupById.description : "";
                    if (!resolvedName || resolvedName === rawId || /^[0-9]+$/.test(resolvedName)) {
                        resolvedName = lookupName || resolvedName || "(unknown service)";
                    }
                    if (!rawId && lookupName) {
                        rawId = Object.keys(svcLookup).find(k => {
                            const v = svcLookup[k];
                            if (typeof v === "object") return v.name === lookupName || v.service === lookupName;
                            return v === lookupName;
                        }) || "";
                    }
                    const resolvedDisplay = lookupDesc || resolvedName;

                    const statusVal = s && s.status;
                    const statusStr = statusVal === undefined ? "active" : String(statusVal).toLowerCase();
                    const isActive =
                        statusStr === "1" ||
                        statusStr === "active" ||
                        statusStr === "online" ||
                        statusStr === "true";
                    const statusLabel = isActive ? "Active" : "Inactive";
                    const statusClass = isActive ? "ok" : "err";
                    const inSentinel = sentinelServices.some(ss => {
                        if (!ss) return false;
                        const idMatch = rawId && (ss.id === rawId || String(ss.id) === String(rawId));
                        const nameMatch = resolvedName && ss.name && String(ss.name) === String(resolvedName);
                        return idMatch || nameMatch;
                    });
                    const sentinelBadge = inSentinel
                        ? '<span class="status-pill status-ok">In Sentinel</span>'
                        : '<span class="status-pill status-err">Not in Sentinel</span>';
                    const subtitle = rawId ? `${resolvedName} (${rawId})` : resolvedName;
                    return `
                        <div class="service-row full-width service-row-padded">
                            <div class="service-name full-width">
                                <div class="full-width"><strong>${resolvedDisplay}</strong></div>
                                ${subtitle ? `<div class="full-width muted normal-weight">${subtitle}</div>` : ""}
                                <div class="full-width mt-4">
                                    <span class="status-pill ${statusClass}">${statusLabel}</span>
                                    ${sentinelBadge}
                                </div>
                            </div>
                            <div class="service-actions-row">
                                <button class="primary" onclick="editService(${idx})">Edit</button>
                            </div>
                        </div>
                    `;
                });
                svcEl.innerHTML = `<div class="service-grid full-width">${items.join("")}</div>`;
            } else if (services && services.error) {
                if (svcEl) svcEl.textContent = "Provider services unavailable";
            } else if (svcEl) {
                svcEl.textContent = "No provider services found";
            }
            renderClaimTotals();
        } catch (e) {
            const svcEl = document.getElementById("providerServices");
            if (svcEl) svcEl.textContent = "Failed to load services: " + e;
        }
    }

    async function refreshContractTotals() {
        const el = document.getElementById("claimTotals");
        const hasContent = el && el.dataset.hasContent === "1";
        if (el && !hasContent) {
            el.textContent = "(loading claim totals...)";
            el.classList.add("muted");
        }
        const body = rangeToHeightBody(earningsRange);
        if (body === null) {
            if (el && !hasContent) el.textContent = "Waiting for latest block height...";
            return;
        }
        try {
            const res = await fetch(resolveApi("/api/provider-contracts-summary"), {
                method: "POST",
                headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
                body: JSON.stringify(body || {}),
            });
            const data = await res.json();
            if (res.ok) {
                providerServiceTotals = Array.isArray(data.service_totals) ? data.service_totals : [];
            } else {
                // leave previous totals in place on error to avoid UI jump
            }
        } catch (e) {
            // leave previous totals in place on error to avoid UI jump
        }
        renderClaimTotals();
    }

    function updateSentinelStatusDisplay(sentinelStatus) {
        const statusEl = document.getElementById("sentinelStatus");
        const badgeTop = document.getElementById("sentinelStatusBadgeTop");
        const rawStatus = (sentinelStatus && sentinelStatus.status) || "";
        const upper = rawStatus.toUpperCase();
        let cls = "status-warn";
        if (upper.includes("RUNNING")) cls = "status-ok";
        else if (upper.includes("FATAL") || upper.includes("STOP") || upper.includes("EXIT")) cls = "status-err";
        if (sentinelStatus && !sentinelStatus.error) {
            let cleaned = rawStatus.replace(/pid\s+\d+,\s*/gi, "").trim();
            cleaned = cleaned.replace(/^sentinel\s*/i, "").trim();
            const display = `Sentinel ${cleaned.replace(",", " :").trim() || "(unknown)"}`
                .replace(/\s+uptime\s+/i, " : Uptime ");
            if (badgeTop) {
                badgeTop.className = `status-badge ${cls}`;
                badgeTop.textContent = display;
            }
            if (statusEl) statusEl.textContent = display;
        } else {
            if (statusEl) statusEl.textContent = "Sentinel status unavailable";
            if (badgeTop) {
                badgeTop.className = "status-badge status-warn";
                badgeTop.textContent = "Sentinel status unavailable";
            }
        }
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "0 uarkeo";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ARKEO`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(heightObj) {
        const h =
            (heightObj && heightObj.height) ||
            (heightObj && heightObj.status && (heightObj.status.latest_block_height || (heightObj.status.SyncInfo && heightObj.status.SyncInfo.latest_block_height)));
        if (!h) return "(unknown)";
        const num = Number(h);
        if (!Number.isFinite(num)) return String(h);
        return num.toLocaleString("en-US");
    }

    function formatPubkeyShort(pk) {
        if (!pk) return "";
        const str = String(pk);
        if (str.length <= 17) return str;
        return `${str.slice(0, 9)}...${str.slice(-8)}`;
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    function getNumericHeight(val) {
        if (val === undefined || val === null) return null;
        if (typeof val === "number") return Number.isFinite(val) ? val : null;
        if (typeof val === "string") {
            const num = Number(val);
            if (!Number.isNaN(num)) return num;
        }
        const raw =
            (val && val.height) ||
            (val && val.status && (
                val.status.latest_block_height ||
                val.status.latest_block ||
                (val.status.SyncInfo && val.status.SyncInfo.latest_block_height) ||
                (val.status.sync_info && val.status.sync_info.latest_block_height)
            ));
        const parsed = Number(raw);
        return Number.isFinite(parsed) ? parsed : null;
    }

    function estimateHeightsForRange(range) {
        const latest = getNumericHeight(lastBlockHeight);
        if (!latest) return { from: null, to: null };
        const seconds = EARNINGS_TIME_WINDOWS[range];
        if (!seconds || range === "all_time") {
            return { from: 0, to: latest };
        }
        const blocksBack = Math.ceil(seconds / BLOCK_TIME_SECONDS);
        const from = Math.max(0, latest - blocksBack);
        return { from, to: latest };
    }

    function rangeToHeightBody(range) {
        if (!range || range === "all_time") return {};
        const { from, to } = estimateHeightsForRange(range);
        if (from === null || to === null) return null;
        return { from_height: from, to_height: to };
    }

    function isServiceActive(statusVal) {
        const rawStatus = statusVal === undefined ? "active" : String(statusVal).toLowerCase();
        return rawStatus === "1" || rawStatus === "active" || rawStatus === "online" || rawStatus === "true";
    }

    function formatArkeoTotals(uarkeoVal) {
        const num = Number(uarkeoVal || 0);
        const arkeo = num / 1_000_000;
        const arkeoStr = arkeo.toLocaleString("en-US", { minimumFractionDigits: 3, maximumFractionDigits: 3 });
        const uStr = num.toLocaleString("en-US");
        return { arkeo: `${arkeoStr} ARKEO`, uarkeo: `${uStr} uarkeo` };
    }

    function renderClaimTotals() {
        const el = document.getElementById("claimTotals");
        if (!el) return;
        if (!providerServicesData || !providerServicesData.length) {
            el.textContent = "No provider services found.";
            el.classList.add("muted");
            el.dataset.hasContent = "0";
            return;
        }
        const active = providerServicesData.filter((s) => isServiceActive(s && s.status));
        if (!active.length) {
            el.textContent = "No active services.";
            el.classList.add("muted");
            el.dataset.hasContent = "0";
            return;
        }
        const totalsMap = new Map();
        (providerServiceTotals || []).forEach((t) => {
            if (!t || !t.service) return;
            const key = String(t.service).toLowerCase();
            totalsMap.set(key, t);
        });
        const cards = active.map((s) => {
            const rawId = s?.id ?? s?.service_id ?? s?.serviceID ?? s?.service ?? "";
            const rawName = s?.name || s?.service || s?.label || String(rawId);
            const serviceKey = String(rawName || rawId).toLowerCase();
            const lookup = providerServiceLookup[rawId] || providerServiceLookup[String(rawId)] || providerServiceLookup[serviceKey];
            const displayName = (lookup && (lookup.description || lookup.name || lookup.service)) || rawName || rawId;
            const totalEntry = totalsMap.get(serviceKey);
            const paid = totalEntry ? totalEntry.tokens_paid_total_uarkeo || 0 : 0;
            const txCount = totalEntry ? (totalEntry.tx_count || totalEntry.payg_requests_total || 0) : 0;
            // Format uarkeo as ARKEO with 8 decimal places (1 ARKEO = 1e8 uarkeo)
            const arkeoVal = paid / 1e8;
            const arkeoStr = arkeoVal.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 });
            return `
                <div class="claim-card">
                    <div class="claim-title">${displayName || "(unknown service)"}</div>
                    <div class="claim-metric">${arkeoStr} ARKEO</div>
                    <div class="claim-meta">${txCount} transactions</div>
                </div>
            `;
        });
        el.classList.remove("muted");
        el.innerHTML = cards.join("") || "<div class=\"muted\">No claim totals available.</div>";
        el.dataset.hasContent = "1";
    }

    function updateEarningsRangeButtons(activeRange) {
        const buttons = document.querySelectorAll(".toggle-btn[data-range]");
        buttons.forEach((btn) => {
            const r = btn.dataset.range;
            if (r === activeRange) btn.classList.add("active");
            else btn.classList.remove("active");
        });
    }

    function resolveServiceLabel(rawService) {
        const key = rawService !== undefined && rawService !== null ? String(rawService) : "";
        const lower = key.toLowerCase();
        const lookup = providerServiceLookup[key] || providerServiceLookup[lower];
        if (lookup && typeof lookup === "object") {
            return lookup.description || lookup.name || lookup.service || key || "(unknown service)";
        }
        if (typeof lookup === "string") return lookup || key || "(unknown service)";
        return key || "(unknown service)";
    }

    function buildServiceChartEntries(list) {
        return (list || [])
            .map((st) => {
                const totalU =
                    Number(
                        st.total_paid_uarkeo ??
                        st.tokens_paid_total_uarkeo ??
                        st.tokens_paid_finalized_uarkeo ??
                        st.total ??
                        st.paid ??
                        0
                    );
                const value = totalU / 1e8;
                const svc = st.service || st.service_id || st.name || "";
                return { label: resolveServiceLabel(svc), value };
            })
            .filter((d) => d.value > 0);
    }

    function renderEarningsChart(data) {
        const canvas = document.getElementById("earningsChart");
        const emptyEl = document.getElementById("earningsChartEmpty");
        if (!canvas) return;
        const hasData = Array.isArray(data) && data.length > 0;
        if (!hasData) {
            if (earningsChartInstance) {
                earningsChartInstance.destroy();
                earningsChartInstance = null;
            }
            canvas.classList.add("hidden");
            if (emptyEl) {
                emptyEl.classList.remove("hidden");
                emptyEl.textContent = "";
            }
            return;
        }
        canvas.classList.remove("hidden");
        if (emptyEl) emptyEl.classList.add("hidden");
        const ctx = canvas.getContext("2d");
        if (!ctx || typeof Chart === "undefined") return;
        const labels = data.map((d) => d.label);
        const values = data.map((d) => d.value);
        if (earningsChartInstance) {
            earningsChartInstance.data.labels = labels;
            earningsChartInstance.data.datasets[0].data = values;
            earningsChartInstance.update();
            return;
        }
        earningsChartInstance = new Chart(ctx, {
            type: "bar",
            data: {
                labels,
                datasets: [
                    {
                        label: "ARKEO Earned",
                        data: values,
                        backgroundColor: "rgba(59, 224, 255, 0.35)",
                        borderColor: "rgba(59, 224, 255, 0.8)",
                        borderWidth: 1.5,
                        borderRadius: 6,
                    },
                ],
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    tooltip: {
                        callbacks: {
                            label: (context) => `${context.parsed.y.toFixed(6)} ARKEO`,
                        },
                    },
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        grid: { color: "rgba(255,255,255,0.08)" },
                        ticks: { color: "#cbd5e1" },
                    },
                    x: {
                        grid: { display: false },
                        ticks: { color: "#94a3b8" },
                    },
                },
            },
        });
    }

    async function loadEarningsByService(range = earningsRange, force = false) {
        earningsRange = range;
        updateEarningsRangeButtons(range);
        const statusEl = document.getElementById("earningsChartStatus");
        if (statusEl) statusEl.textContent = "";
        const gateAuthed = sessionStorage.getItem("adminAuthed") === "1" || adminSessionAuthed || !adminPasswordEnabled;
        if (adminPasswordEnabled && !gateAuthed) {
            if (statusEl) statusEl.textContent = "Enter the admin password to view earnings.";
            return;
        }
        const now = Date.now();
        const cacheEntry = earningsChartCache[range];
        if (!force && cacheEntry && now - cacheEntry.fetched < EARNINGS_CACHE_MS) {
            renderEarningsChart(cacheEntry.data);
            if (statusEl) statusEl.textContent = "";
            return;
        }
        const { from, to } = estimateHeightsForRange(range);
        const body = {};
        if (range !== "all_time" && (from === null || to === null)) {
            if (statusEl) statusEl.textContent = "Waiting for latest block height...";
            return;
        }
        if (range !== "all_time" && from !== null && to !== null) {
            body.from_height = from;
            body.to_height = to;
        }
        if (statusEl) statusEl.textContent = "";
        try {
            const res = await fetch(resolveApi("/api/provider-totals"), {
                method: "POST",
                headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok) {
                if (statusEl) statusEl.textContent = data && data.error ? `Error: ${data.error}` : `Error ${res.status}`;
                renderEarningsChart([]);
                return;
            }
            let services = Array.isArray(data.service_totals) ? data.service_totals : [];
            if ((!services || !services.length) && providerServiceTotals && providerServiceTotals.length) {
                services = providerServiceTotals;
                if (statusEl && !(data && data.error)) {
                    statusEl.textContent = "";
                }
            } else if (data && data.error && statusEl) {
                statusEl.textContent = data.error;
            }
            const chartData = buildServiceChartEntries(services);
            chartData.sort((a, b) => b.value - a.value);
            const top = chartData.slice(0, 10);
            earningsChartCache[range] = { data: top, fetched: now };
            renderEarningsChart(top);
            if (statusEl && !top.length) {
                statusEl.textContent = "";
            }
        } catch (e) {
            renderEarningsChart([]);
            if (statusEl) statusEl.textContent = `Failed to load earnings: ${e}`;
        }
    }

    function changeEarningsRange(range) {
        loadEarningsByService(range, true);
        earningsRange = range;
        refreshContractTotals();
    }

    async function refreshClaimTotals() {
        const el = document.getElementById("claimTotals");
        const hasContent = el && el.dataset.hasContent === "1";
        if (el && !hasContent) {
            el.textContent = "Refreshing claim totals...";
            el.classList.add("muted");
        }
        try {
            const res = await fetch(resolveApi("/api/provider-contracts-summary"), {
                method: "POST",
                headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
                body: "{}",
            });
            const data = await res.json();
            if (res.ok) {
                providerServiceTotals = Array.isArray(data.service_totals) ? data.service_totals : [];
                if (data.last_claims_run && data.last_claims_run !== lastClaimsRun) {
                    lastClaimsRun = data.last_claims_run;
                    updateClaimsHeartbeat(lastClaimsRun);
                }
                renderClaimTotals();
                if (providerServiceTotals && providerServiceTotals.length) {
                    loadEarningsByService(earningsRange, true);
                }
            } else if (!hasContent && el) {
                el.textContent = "Error: " + JSON.stringify(data);
            }
        } catch (e) {
            if (!hasContent && el) el.textContent = "Error: " + e;
        }
    }

    async function runClaimsAndContracts() {
        const logEl = document.getElementById("claimStatusLog");
        const append = (line) => {
            if (!logEl) return;
            const ts = new Date().toISOString();
            const text = logEl.textContent || "";
            logEl.textContent = `${ts} ${line}\n${text}`;
        };
        append("Starting provider claims...");
        try {
            const claimsRes = await fetch(resolveApi("/api/provider-claims"), { method: "POST" });
            const claimsData = await claimsRes.json().catch(() => ({}));
            if (claimsRes.ok) {
                append(`Claims ok: ${JSON.stringify(claimsData)}`);
            } else {
                append(`Claims error: ${JSON.stringify(claimsData)}`);
            }
        } catch (e) {
            append(`Claims request failed: ${e}`);
        }
        append("Waiting 10s for inclusion...");
        await new Promise(res => setTimeout(res, 10000));
        append("Refreshing contract totals...");
        try {
            const ctrRes = await fetch(resolveApi("/api/provider-contracts-summary"), {
                method: "POST",
                headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
                body: "{}",
            });
            const ctrData = await ctrRes.json().catch(() => ({}));
            if (ctrRes.ok) {
                append(`Contracts ok: ${JSON.stringify(ctrData)}`);
                providerServiceTotals = Array.isArray(ctrData.service_totals) ? ctrData.service_totals : providerServiceTotals;
                if (ctrData.last_claims_run && ctrData.last_claims_run !== lastClaimsRun) {
                    lastClaimsRun = ctrData.last_claims_run;
                    updateClaimsHeartbeat(lastClaimsRun);
                }
                renderClaimTotals();
            } else {
                append(`Contracts error: ${JSON.stringify(ctrData)}`);
            }
        } catch (e) {
            append(`Contracts request failed: ${e}`);
        }
    }

    function updateClaimsHeartbeat(ts) {
        const el = document.getElementById("claimsHeartbeat");
        if (!el) return;
        if (!ts) {
            el.textContent = "Last claims run: (unknown)";
            return;
        }
        el.textContent = `Last claims run: ${ts}`;
        lastClaimsHeartbeat = ts;
    }

    async function refreshClaimsHeartbeat() {
        try {
            const res = await fetch(resolveApi("/api/claims-heartbeat"), { cache: "no-store" });
            const data = await res.json().catch(() => ({}));
            const ts = data.last_claims_run;
            if (ts && ts !== lastClaimsRun) {
                lastClaimsRun = ts;
            }
            updateClaimsHeartbeat(ts || lastClaimsRun || lastClaimsHeartbeat);
        } catch (e) {
            // keep prior heartbeat display
        }
    }

    function showSyncingPill() {
        setSyncPill(true, "Syncing...");
    }

    function hideSyncingPill() {
        setSyncPill(false);
    }

    function setStatusDot(statusId, state) {
        const badge = document.getElementById(statusId);
        if (!badge) return;
        let cls = "err";
        if (state === "ok") cls = "ok";
        else if (state === "warn") cls = "warn";
        badge.className = `status-dot ${cls}`;
    }

    function setSyncPill(show, text = "Syncing...") {
        const pill = document.getElementById("syncPill");
        if (!pill) return;
        pill.textContent = text;
        pill.classList.toggle("hidden", !show);
    }

    async function fetchAdminPasswordStatus(showGate = true) {
        try {
            const res = await fetch(resolveApi("/api/session"), { cache: "no-store" });
            const data = await res.json();
            adminPasswordEnabled = !!(data && data.enabled);
            adminSessionAuthed = !!(data && data.authed);
        } catch (e) {
            adminPasswordEnabled = false;
            adminSessionAuthed = false;
        }
        if (adminPasswordEnabled && !adminSessionAuthed) {
            sessionStorage.removeItem("adminAuthed");
        }
        const gateAuthed = sessionStorage.getItem("adminAuthed") === "1" || adminSessionAuthed;
        const gate = document.getElementById("adminPasswordGate");
        if (gate) {
            if (showGate && adminPasswordEnabled && !gateAuthed) {
                gate.classList.remove("hidden");
            } else {
                gate.classList.add("hidden");
            }
        }
    }

    async function submitAdminPasswordGate(event) {
        if (event && event.preventDefault) event.preventDefault();
        const input = document.getElementById("adminPasswordGateInput");
        const statusEl = document.getElementById("adminPasswordGateStatus");
        const pwd = (input && input.value) || "";
        if (statusEl) statusEl.textContent = "Verifying...";
        try {
            const res = await fetch(resolveApi("/api/login"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ password: pwd }),
            });
            const data = await res.json();
            if (data && data.ok) {
                sessionStorage.setItem("adminAuthed", "1");
                adminSessionAuthed = true;
                const gate = document.getElementById("adminPasswordGate");
                if (gate) gate.classList.add("hidden");
                if (statusEl) statusEl.textContent = "";
                // Full reload to re-init all timers/fetches with the new session
                window.location.reload();
            } else if (statusEl) {
                statusEl.textContent = "Incorrect password.";
            }
        } catch (e) {
            if (statusEl) statusEl.textContent = `Failed to verify: ${e}`;
        }
    }

    async function refreshEndpointStatuses() {
        try {
            const res = await fetch(resolveApi("/api/endpoint-checks"));
            const data = await res.json();
            const ep = (data && data.endpoints) || {};
            const map = [
                ["arkeod-status", ep.arkeod_status],
                ["arkeorpc-status", ep.arkeorpc],
                ["sentinel-external-status", ep.sentinel_external],
                ["internal-sentinel-status", ep.sentinel_internal],
                ["internal-adminapi-status", ep.admin_api],
                ["internal-admin-status", ep.admin_ui],
            ];
            for (const [id, entry] of map) {
                if (!entry) {
                    setStatusDot(id, "err");
                    continue;
                }
                setStatusDot(id, entry.ok ? "ok" : "err");
            }
        } catch (e) {
            const ids = ["arkeod-status", "arkeorpc-status", "sentinel-external-status", "internal-sentinel-status", "internal-adminapi-status", "internal-admin-status"];
            ids.forEach((id) => setStatusDot(id, "err"));
        }
    }

    async function refreshSentinelStatus() {
        try {
            const res = await fetch(resolveApi("/api/sentinel-status"));
            const data = await res.json();
            updateSentinelStatusDisplay(data);
        } catch (e) {
            const badgeTop = document.getElementById("sentinelStatusBadgeTop");
            if (badgeTop) { badgeTop.className = "status-badge status-warn"; badgeTop.textContent = "unavailable"; }
        }
    }

    async function controlSentinel(action) {
        showResultModal("Sentinel Control", `Sending ${action}...`);
        try {
            const res = await fetch(resolveApi("/api/sentinel-control"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ action }),
            });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Sentinel Control", `${action} ok: ${JSON.stringify(data)}`);
                refreshInfo();
            } else {
                showResultModal("Sentinel Control", `${action} failed: ${JSON.stringify(data)}`);
            }
        } catch (e) {
                showResultModal("Sentinel Control", `${action} request error: ${e}`);
        }
    }

    async function runProviderTotals() {
        showResultModal("Provider Totals", "Running provider totals...");
        try {
            const res = await fetch(resolveApi("/api/provider-totals"), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({}) });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Provider Totals", JSON.stringify(data, null, 2));
            } else {
                showResultModal("Provider Totals", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Totals", "Request failed: " + e);
        }
    }

    async function runProviderExport() {
        showResultModal("Provider Export", "Exporting...");
        try {
            const res = await fetch(resolveApi("/api/provider-export"), { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                const content = JSON.stringify(data.export || data, null, 2);
                const blob = new Blob([content], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "provider-export.json";
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showResultModal("Provider Export", `Exported to ${data.path || "(unknown)"}${data.bytes ? ` (${data.bytes} bytes)` : ""}`);
            } else {
                showResultModal("Provider Export", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Export", "Request failed: " + e);
        }
    }

    function triggerProviderImport() {
        const input = document.getElementById("providerImportInput");
        if (input) input.click();
    }

    async function handleProviderImport(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        try {
            const text = await file.text();
            const json = JSON.parse(text);
            showResultModal("Provider Import", "Uploading...");
            const res = await fetch(resolveApi("/api/provider-import"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(json),
            });
            let data;
            try {
                data = await res.json();
            } catch (e) {
                const txt = await res.text().catch(() => "");
                showResultModal("Provider Import", `Import error: non-JSON response (${res.status})\n${txt}`);
                return;
            }
            if (res.ok) {
                showResultModal("Provider Import", `Imported and cached to ${data.path || "(unknown)"}`);
            } else {
                showResultModal("Provider Import", "Import error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Import", "Failed to import: " + e);
        } finally {
            event.target.value = "";
        }
    }

    async function runSentinelSync() {
        showResultModal("Sync Sentinel", "Syncing...");
        try {
            const res = await fetch(resolveApi("/api/sentinel-sync"), { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Sync Sentinel", `Synced:\n${JSON.stringify(data, null, 2)}`);
            } else {
                showResultModal("Sync Sentinel", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Sync Sentinel", "Request failed: " + e);
        }
    }

    function showResultModal(title, bodyText) {
        const modal = document.getElementById("resultModal");
        const t = document.getElementById("modalTitle");
        const b = document.getElementById("modalBody");
        if (t) t.textContent = title || "Result";
        if (b) b.textContent = bodyText || "";
        if (modal) modal.style.display = "flex";
    }

    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.style.display = "none";
    }

    async function ensureProviderSettingsExists() {
        try {
            const res = await fetch(resolveApi("/api/provider-settings"), { cache: "no-store" });
            const data = await res.json();
            if (res.ok && data && data.settings_exists === false) {
                // Flag for admin page to show setup modal, then redirect
                sessionStorage.setItem("requireProviderSetup", "1");
                window.location.href = "admin.html";
                return false;
            }
        } catch (e) {
            // If this check fails, let the page continue; other calls will surface issues.
        }
        return true;
    }

    async function renderEndpointPanel(sCfg, provObj, envMeta, providerSettings) {
        const el = document.getElementById("endpointList");
        if (!el) return;
        const envLower = (sCfg && sCfg.env) || {};
        const envFile = (sCfg && sCfg.env_file) || {};
        const pickEnv = (keyUpper) => {
            const lower = keyUpper.toLowerCase();
            return (envFile[keyUpper] ?? envLower[lower] ?? "");
        };
        const meta = (provObj && provObj.provider_metadata) || envMeta || {};
        const pickMeta = (key) => meta[key] || meta[key.toUpperCase()] || meta[key.toLowerCase()] || "";

        const arkeodNode = pickEnv("ARKEOD_NODE") || pickMeta("ARKEOD_NODE");
        const ps = (providerSettings && providerSettings.settings) || providerSettings || {};
        const restApi =
            envFile.ARKEO_REST_API_PORT ||
            envLower["arkeo_rest_api_port"] ||
            ps.ARKEO_REST_API_PORT ||
            pickMeta("ARKEO_REST_API_PORT");
        const sentinelNode = pickEnv("SENTINEL_NODE") || pickMeta("SENTINEL_NODE");
        const sentinelPort = pickEnv("SENTINEL_PORT") || pickMeta("SENTINEL_PORT") || "3636";
        const resolvedHost = extractHostFromValue(sentinelNode) || adminHost;
        const sentinelFull = sentinelNode ? `${sentinelNode}:${sentinelPort}` : `(not set):${sentinelPort}`;
        // Always use loopback for the internal check
        const sentinelInternalUrl = buildBaseUrl("127.0.0.1", sentinelPort);
        const sentinelExternalHost = extractHostFromValue(sentinelNode) || adminHost;
        const sentinelExternalUrl = buildBaseUrl(sentinelExternalHost, sentinelPort);
        const adminApiPort = pickEnv("ADMIN_API_PORT") || pickMeta("ADMIN_API_PORT") || "9999";
        const adminPort = pickEnv("ADMIN_PORT") || pickMeta("ADMIN_PORT") || "8080";
        const pageHost = (window.location && window.location.hostname) || adminHost;
        const adminApiUrl = buildBaseUrl(pageHost, adminApiPort);
        const adminUiUrl = buildBaseUrl(pageHost, adminPort);

        const makeRow = (label, value, statusId) => {
            return `<div class="endpoint-row">
                <strong>${label}: </strong><br>
                <span id="${statusId}" class="status-dot warn"></span>
                <span class="muted endpoint-url">${value || "(not set)"}</span>
            </div>`;
        };

        el.innerHTML = [
            `<div class="endpoint-section-title"><h3>External Access</h3></div>`,
            makeRow("Arkeo Node", arkeodNode, "arkeod-status"),
            makeRow("Arkeo Rest", restApi, "arkeorpc-status"),
            makeRow("Sentinel RPC (External)", sentinelExternalUrl, "sentinel-external-status"),
            `<div class="endpoint-section-title"><h3>Internal Access</h3></div>`,
            makeRow("Sentinel RPC (Internal)", sentinelInternalUrl, "internal-sentinel-status"),
            makeRow("Admin API", `${adminApiUrl}/api/version`, "internal-adminapi-status"),
            makeRow("Admin UI", `${adminUiUrl}`, "internal-admin-status")
        ].join("");

        // Kick off reachability checks from the backend
        refreshEndpointStatuses();
    }

    async function getVersion() {
        try {
            let res = await fetch(resolveApi("/api/version"));
            let data = await res.json();
            if (data.arkeod_version) {
                document.getElementById("version").textContent = "arkeod version: " + data.arkeod_version;
            } else if (data.error) {
                document.getElementById("version").textContent = "Error getting version: " + data.error;
            } else {
                document.getElementById("version").textContent = "Unknown version response";
            }
        } catch (e) {
            document.getElementById("version").textContent = "Error fetching version: " + e;
        }
    }

    function editService(idx) {
        if (!providerServicesData || !providerServicesData[idx]) return;
        try {
            localStorage.setItem("providerServiceEdit", JSON.stringify(providerServicesData[idx]));
        } catch (e) {
            console.warn("Failed to cache service for edit", e);
        }
        window.location.href = "provider.html";
    }

    async function copyPubkeyFromHeader() {
        const el = document.getElementById("headerPubkey");
        const full = (el && el.dataset.fullPubkey) || currentPubkey || "";
        if (full) {
            await copyPubkey(full);
        } else {
            showResultModal("Copy Provider Pubkey", "Pubkey unavailable");
        }
    }

    async function copyPubkey(val) {
        try {
            await navigator.clipboard.writeText(val);
            showResultModal("Copy Provider Pubkey", `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            const msg = [
                "Failed to copy pubkey (clipboard is blocked in insecure contexts).",
                "",
                "You can copy it manually:",
                val || "(unavailable)"
            ].join("\n");
            showResultModal("Copy Provider Pubkey", msg);
        }
    }

    async function copyAddressFromHeader() {
        const el = document.getElementById("headerAddress");
        const full = (el && el.dataset.fullAddress) || "";
        const fallback = document.getElementById("headerAddressValue")?.textContent || "";
        const val = full || fallback;
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Provider Address", "Provider address unavailable");
            return;
        }
        try {
            await navigator.clipboard.writeText(val);
            showResultModal("Copy Provider Address", `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const msg = [
                "Failed to copy address (clipboard is blocked in insecure contexts).",
                "",
                "You can copy it manually:",
                val
            ].join("\n");
            showResultModal("Copy Provider Address", msg);
        }
    }

    window.addEventListener('load', async () => {
        await detectAdminApiBase();
        const ok = await ensureProviderSettingsExists();
        if (!ok) return;
        fetchAdminPasswordStatus(true);
        getVersion();
        showSyncingPill();
        refreshInfo().finally(() => hideSyncingPill());
        refreshServices();
        refreshContractTotals();
        refreshVitals();
        refreshClaimsHeartbeat();
        loadEarningsByService(earningsRange, true);
        setInterval(refreshInfo, 10000);
        setInterval(refreshServices, 20000);
        setInterval(refreshContractTotals, 20000);
        setInterval(refreshVitals, 20000);
        setInterval(refreshClaimsHeartbeat, 30000);
        setInterval(() => {
            loadEarningsByService(earningsRange).catch(() => {
                /* ignore interval errors to avoid console noise */
            });
        }, 10000);
    });
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            refreshInfo();
        }
    });
    window.addEventListener('pageshow', (event) => {
        if (event.persisted) {
            refreshInfo();
        }
    });
</script>

</body>
</html>
