<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Marketplace | Provider Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>
<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Provider Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
        <div class="header-right">
            <div class="header-line" id="headerPubkey">
                <strong>Provider Pubkey:</strong>
                <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerAddress">
                <strong>Provider Address:</strong>
                <span class="inline">
                    <span id="headerAddressValue"></span>
                    <button class="copy-btn" onclick="copyAddressFromHeader()">Copy</button>
                </span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Provider Balance:</strong></div>
            <div class="header-line muted" id="headerBlock"><strong>Current Block:</strong></div>
            <div class="header-line fixed-pill"><span id="headerRefreshPill" class="status-badge status-warn hidden">Loading...</span></div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Claim Totals</h2>
    <div id="claimTotals" class="claims-grid muted card-body">(loading claim totals...)</div>
</div>

<div class="card">
    <h2>Sentinel Info</h2>
    <div class="row">
        <div class="col">
            <div class="stack panel mb-8">
                <div class="pill-row">
                    <div class="status-badge status-warn" id="sentinelStatusBadgeTop">(loading)</div>
                </div>
                <div class="actions">
                    <button class="primary" onclick="controlSentinel('restart')">Restart Sentinel</button>
                    <button class="primary" onclick="controlSentinel('stop')">Stop Sentinel</button>
                    <button class="primary" onclick="controlSentinel('start')">Start Sentinel</button>
                </div>
                <div class="actions">
                    <button class="primary" onclick="runProviderClaims()">Provider Claims</button>
                    <button class="primary" onclick="runProviderTotals()">Provider Totals</button>
                </div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 1: Provide Sentinel Details</h3>
                    <p>Configure your sentinel settings before bonding a service.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="sentinel.html">Open Sentinel Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Provider Services</h2>
    <div class="row">
        <div class="col">
            <div class="panel mb-12">
                <div id="providerServices" class="muted">(loading services...)</div>
            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 2: Add Provider Services</h3>
                    <p>Bond and modify provider services for the marketplace.</p>
                    <p class="muted">* Edits may take 1–2 blocks to appear in the dashboard as the blockchain refreshes. Let the interface refresh to see the latest changes.</p>
                    <a class="btn" href="provider.html">Open Provider Services Form</a>
                </div>
            </div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Access Points</h2>

    <div class="row">
        <div class="col">
            <div class="panel mb-12">

                <div id="endpointList" class="muted ws-normal"></div>

            </div>
        </div>
        <div class="col">
            <div class="steps">
                <div class="step">
                    <h3>Step 3: Export</h3>
                    <p>Export your configs to make it easier to update/restore your docker later.</p>
                    <div class="actions">
                        <button class="primary" onclick="runProviderExport()">Provider Export</button>
                        <button class="primary" onclick="triggerProviderImport()">Provider Import</button>
                        <input type="file" id="providerImportInput" class="hidden" accept="application/json" onchange="handleProviderImport(event)" />
                    </div>
                </div>
            </div>
        </div>
    </div>

</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="section">

        <h3>Debug</h3>
        <h4>Sentinel Status</h4>
        <pre id="sentinelStatus">Loading...</pre>
        <h4>Sentinel Env (runtime)</h4>
        <pre id="sentinelEnvStatus">Loading...</pre>
        <h4>Sentinel YAML</h4>
        <pre id="sentinelYamlStatus">Loading...</pre>

        <h4>Debug</h4>
        <button class="primary" onclick="refreshInfo()">Refresh Info</button>
        <p id="version">Loading arkeod version...</p>
        <span id="refreshBadge" class="status-badge status-warn hidden mb-8">Refreshing…</span>
        <pre id="debugInfo">Loading...</pre>


    </div>
</div>

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <pre id="modalBody"></pre>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<script>
    const DEFAULT_ADMIN_API_PORT = "9999";
    const DEFAULT_ADMIN_UI_PORT = "8080";
    let adminHost = (window.location && window.location.hostname) || "localhost";
    let adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);

    function buildBaseUrl(host, port) {
        const proto = (window.location && window.location.protocol === "https:") ? "https:" : "http:";
        const cleaned = (host || "").replace(/^https?:\/\//, "").replace(/\/+$/, "");
        return `${proto}//${cleaned}${port ? `:${port}` : ""}`;
    }

    function extractHostFromValue(val) {
        if (!val) return "";
        try {
            const u = val.startsWith("http") ? new URL(val) : new URL(`http://${val}`);
            return u.hostname || "";
        } catch (e) {
            return "";
        }
    }

    function setAdminHost(candidateHost) {
        if (!candidateHost) return;
        const cleaned = extractHostFromValue(candidateHost) || candidateHost;
        if (cleaned && cleaned !== adminHost) {
            adminHost = cleaned;
            adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);
        }
    }

    function resolveApi(path) {
        if (!path.startsWith("/")) path = `/${path}`;
        return `${adminApiBase}${path}`;
    }

    function isLocalHost(host) {
        const h = (host || "").toLowerCase();
        return h === "localhost" || h === "127.0.0.1" || h === "";
    }

    function updateHostFromConfig(sCfg, metaObj) {
        const envLower = (sCfg && sCfg.env) || {};
        const envFile = (sCfg && sCfg.env_file) || {};
        const meta = metaObj || {};
        const pickEnv = (keyUpper) => {
            const lower = keyUpper.toLowerCase();
            return (envFile[keyUpper] ?? envLower[lower] ?? "");
        };
        const pickMeta = (key) => meta[key] || meta[key.toUpperCase()] || meta[key.toLowerCase()] || "";
        const adminHostOverride = pickEnv("ADMIN_HOST") || pickMeta("ADMIN_HOST");
        const sentinelNode = pickEnv("SENTINEL_NODE") || pickMeta("SENTINEL_NODE");
        const sentinelHost = extractHostFromValue(sentinelNode);
        const currentIsLocal = isLocalHost(adminHost);
        const chosen = adminHostOverride || (currentIsLocal ? sentinelHost : "");
        // Do not override adminApiBase; keep using the page host for API calls
    }

    let providerServicesData = [];
    let providerServiceTotals = [];
    let providerServiceLookup = {};
    let currentPubkey = "";

    async function refreshInfo() {
        const debugEl = document.getElementById("debugInfo");
        debugEl.textContent = "Loading...";
        const refreshBadge = document.getElementById("refreshBadge");
        const headerPill = document.getElementById("headerRefreshPill");
        if (refreshBadge) refreshBadge.style.display = "inline-block";
        if (headerPill) headerPill.style.display = "inline-block";
        try {
            const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
            const [provRes, balRes, keyRes, svcRes, allSvcRes, sentRes, heightRes, sCfgRes, metaRes, totalsRes] = await Promise.allSettled([
                fetchNoStore(resolveApi("/api/provider-info")),
                fetchNoStore(resolveApi("/api/balance")),
                fetchNoStore(resolveApi("/api/key")),
                fetchNoStore(resolveApi("/api/provider-services")),
                fetchNoStore(resolveApi("/api/services")),
                fetchNoStore(resolveApi("/api/sentinel-status")),
                fetchNoStore(resolveApi("/api/block-height")),
                fetchNoStore(resolveApi("/api/sentinel-config")),
                fetchNoStore(resolveApi("/api/sentinel-metadata?quiet=1")),
                fetch(resolveApi("/api/provider-totals"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json", "Cache-Control": "no-store" },
                    body: "{}",
                }),
            ]);
            const parseSafe = async (settled) => {
                if (settled.status !== "fulfilled" || !settled.value) return { error: String(settled.reason || "request failed") };
                try {
                    if (!settled.value.ok) {
                        const text = await settled.value.text().catch(() => "");
                        return { error: `${settled.value.status} ${settled.value.statusText || ""}`, body: text };
                    }
                    return await settled.value.json();
                } catch (err) {
                    return { error: "invalid json", detail: String(err) };
                }
            };
            const prov = await parseSafe(provRes);
            const bal = await parseSafe(balRes);
            const key = await parseSafe(keyRes);
            const services = await parseSafe(svcRes);
            const allServices = await parseSafe(allSvcRes);
            const sentinelStatus = await parseSafe(sentRes);
            const height = await parseSafe(heightRes);
            const sentinelConfig = await parseSafe(sCfgRes);
            const meta = await parseSafe(metaRes);
            const totals = await parseSafe(totalsRes);
            // Provider summary at top
            const metaCfg = (meta && meta.metadata && meta.metadata.config) || {};
            const envMeta = (prov && prov.provider_metadata) || {};
            updateHostFromConfig(sentinelConfig, envMeta);
            const moniker =
                metaCfg.moniker ||
                metaCfg.provider_name ||
                envMeta.MONIKER ||
                envMeta.PROVIDER_NAME ||
                "";
            const desc = metaCfg.description || envMeta.DESCRIPTION || "";
            const bech32Pubkey =
                (prov && prov.pubkey && prov.pubkey.bech32) ||
                (key && key.pubkey && key.pubkey.bech32) ||
                "(unknown)";
            const bech32Address =
                (prov && (prov.address || prov.addr || prov.provider_address || prov.operator_address)) ||
                (key && (key.address || key.addr || key.provider_address || key.operator_address)) ||
                "";
            currentPubkey = bech32Pubkey || "";
            const shortPubkey = formatPubkeyShort(currentPubkey);
            const shortAddress = formatAddressShort(bech32Address);
            const balanceAmt = formatBalance(bal);
            const blockHeight = formatBlockHeight(height);
            const summaryEl = document.getElementById("providerSummary");
            if (summaryEl) summaryEl.innerHTML = "";
            const headerMonikerEl = document.getElementById("headerMoniker");
            const headerDescEl = document.getElementById("headerDescription");
            const headerBalanceEl = document.getElementById("headerBalance");
            const headerBlockEl = document.getElementById("headerBlock");
            const headerPubEl = document.getElementById("headerPubkey");
            const headerAddrEl = document.getElementById("headerAddress");
            if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
            if (headerDescEl) headerDescEl.textContent = desc || "";
            if (headerBalanceEl) headerBalanceEl.innerHTML = `<strong>Provider Balance:</strong> ${balanceAmt}`;
            if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${blockHeight}`;
            if (headerPubEl) {
                const valEl = document.getElementById("headerPubkeyValue");
                if (valEl) valEl.textContent = shortPubkey;
                headerPubEl.dataset.fullPubkey = currentPubkey;
            }
            if (headerAddrEl) {
                const addrEl = document.getElementById("headerAddressValue");
                if (addrEl) addrEl.textContent = shortAddress || "(unavailable)";
                headerAddrEl.dataset.fullAddress = bech32Address || "";
            }
            const svcEl = document.getElementById("providerServices");
            const svcLookup = {};
            if (allServices && Array.isArray(allServices.services)) {
                allServices.services.forEach(s => {
                    const rawId = s && (s.id ?? s.service_id ?? s.serviceID);
                    const key = rawId !== undefined && rawId !== null ? String(rawId) : "";
                    const name = s ? (s.name || s.service || s.label || "") : "";
                    const desc = s ? (s.description || s.desc || s.label || "") : "";
                    if (key) {
                        const val = { name, description: desc, service: s.service };
                        svcLookup[key] = val;
                        // also store numeric key variant to be safe
                        const numKey = Number(key);
                        if (!Number.isNaN(numKey)) {
                            svcLookup[String(numKey)] = val;
                        }
                    }
                });
            }
            providerServiceLookup = svcLookup;
            providerServicesData = services && Array.isArray(services.services) ? services.services : [];
            providerServiceTotals = (totals && Array.isArray(totals.service_totals)) ? totals.service_totals : [];
            const sentinelServices = [];
            renderEndpointPanel(sentinelConfig, prov, envMeta);
            if (sentinelConfig && sentinelConfig.config && Array.isArray(sentinelConfig.config.services)) {
                sentinelConfig.config.services.forEach(ss => {
                    if (!ss || typeof ss !== "object") return;
                    const sid = ss.id !== undefined && ss.id !== null ? String(ss.id) : "";
                    const sname = ss.name || ss.service;
                    if (sid) sentinelServices.push({ id: sid, name: sname });
                    else if (sname) sentinelServices.push({ name: sname });
                });
            }
            if (providerServicesData && providerServicesData.length) {
                const items = providerServicesData.map((s, idx) => {
                    let rawId = "";
                    let rawName = "";
                    if (s && typeof s === "object") {
                        const candidateId = s.id ?? s.service_id ?? s.serviceID;
                        rawId = candidateId !== undefined && candidateId !== null ? String(candidateId) : "";
                        rawName = s.name || s.service || s.label || "";
                    } else if (typeof s === "string" || typeof s === "number") {
                        rawName = String(s);
                    }
                    if (!rawId && rawName && /^[0-9]+$/.test(rawName)) {
                        rawId = rawName;
                    }

                    let resolvedName = rawName;
                    const lookupById = rawId ? svcLookup[rawId] : "";
                    // lookupById may be string or object; normalize
                    const lookupName = lookupById && typeof lookupById === "object" ? (lookupById.name || lookupById.label || lookupById.service || "") : lookupById;
                    const lookupDesc = lookupById && typeof lookupById === "object" ? lookupById.description : "";
                    if (!resolvedName || resolvedName === rawId || /^[0-9]+$/.test(resolvedName)) {
                        resolvedName = lookupName || resolvedName || "(unknown service)";
                    }
                    if (!rawId && lookupName) {
                        rawId = Object.keys(svcLookup).find(k => {
                            const v = svcLookup[k];
                            if (typeof v === "object") return v.name === lookupName || v.service === lookupName;
                            return v === lookupName;
                        }) || "";
                    }
                    const resolvedDisplay = lookupDesc || resolvedName;

                    const statusVal = s && s.status;
                    const statusStr = statusVal === undefined ? "active" : String(statusVal).toLowerCase();
                    const isActive =
                        statusStr === "1" ||
                        statusStr === "active" ||
                        statusStr === "online" ||
                        statusStr === "true";
                    const statusLabel = isActive ? "Active" : "Inactive";
                    const statusClass = isActive ? "ok" : "err";
                    const inSentinel = sentinelServices.some(ss => {
                        if (!ss) return false;
                        const idMatch = rawId && (ss.id === rawId || String(ss.id) === String(rawId));
                        const nameMatch = resolvedName && ss.name && String(ss.name) === String(resolvedName);
                        return idMatch || nameMatch;
                    });
                    const sentinelBadge = inSentinel
                        ? '<span class="status-pill status-ok">In Sentinel</span>'
                        : '<span class="status-pill status-err">Not in Sentinel</span>';
                    const subtitle = rawId ? `${resolvedName} (${rawId})` : resolvedName;
                    return `
                        <div class="service-row full-width service-row-padded">
                            <div class="service-name full-width">
                                <div class="full-width"><strong>${resolvedDisplay}</strong></div>
                                ${subtitle ? `<div class="full-width muted normal-weight">${subtitle}</div>` : ""}
                                <div class="full-width mt-4">
                                    <span class="status-pill ${statusClass}">${statusLabel}</span>
                                    ${sentinelBadge}
                                </div>
                            </div>
                            <div class="service-actions-row">
                                <button class="primary" onclick="editService(${idx})">Edit</button>
                            </div>
                        </div>
                    `;
                });
                svcEl.innerHTML = `<div class="service-grid full-width">${items.join("")}</div>`;
            } else if (services && services.error) {
                svcEl.textContent = "Provider services unavailable";
            } else {
                svcEl.textContent = "No provider services found";
            }
            renderClaimTotals();
            debugEl.textContent = JSON.stringify(
                {
                    provider_info: prov,
                    balance: bal,
                    key: key,
                    sentinel_metadata: meta,
                    sentinel_config: sentinelConfig,
                    provider_services: services,
                    all_services: allServices,
                    sentinel_status: sentinelStatus,
                    block_height: height,
                    provider_totals: totals,
                },
                null,
                2
            );
            if (sentinelConfig && sentinelConfig.raw) {
                const sentinelYamlEl = document.getElementById("sentinelYamlStatus");
                if (sentinelYamlEl) {
                    sentinelYamlEl.textContent = sentinelConfig.raw;
                }
                const sentinelEnvEl = document.getElementById("sentinelEnvStatus");
                if (sentinelEnvEl && sentinelConfig.env_file) {
                    sentinelEnvEl.textContent = JSON.stringify(sentinelConfig.env_file, null, 2);
                }
            }
            updateSentinelStatusDisplay(sentinelStatus);
        } catch (e) {
            debugEl.textContent = "Failed to load info: " + e;
        }
        if (refreshBadge) refreshBadge.style.display = "none";
        if (headerPill) headerPill.style.display = "none";
    }

    function updateSentinelStatusDisplay(sentinelStatus) {
        const statusEl = document.getElementById("sentinelStatus");
        const badgeTop = document.getElementById("sentinelStatusBadgeTop");
        const rawStatus = (sentinelStatus && sentinelStatus.status) || "";
        const upper = rawStatus.toUpperCase();
        let cls = "status-warn";
        if (upper.includes("RUNNING")) cls = "status-ok";
        else if (upper.includes("FATAL") || upper.includes("STOP") || upper.includes("EXIT")) cls = "status-err";
        if (sentinelStatus && !sentinelStatus.error) {
            let cleaned = rawStatus.replace(/pid\s+\d+,\s*/gi, "").trim();
            cleaned = cleaned.replace(/^sentinel\s*/i, "").trim();
            const display = `Sentinel ${cleaned.replace(",", " :").trim() || "(unknown)"}`
                .replace(/\s+uptime\s+/i, " : Uptime ");
            if (badgeTop) {
                badgeTop.className = `status-badge ${cls}`;
                badgeTop.textContent = display;
            }
            statusEl.textContent = display;
        } else {
            statusEl.textContent = "Sentinel status unavailable";
        }
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "(unknown)";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ${denom}`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(heightObj) {
        const h =
            (heightObj && heightObj.height) ||
            (heightObj && heightObj.status && (heightObj.status.latest_block_height || (heightObj.status.SyncInfo && heightObj.status.SyncInfo.latest_block_height)));
        if (!h) return "(unknown)";
        const num = Number(h);
        if (!Number.isFinite(num)) return String(h);
        return num.toLocaleString("en-US");
    }

    function formatPubkeyShort(pk) {
        if (!pk) return "";
        const str = String(pk);
        if (str.length <= 17) return str;
        return `${str.slice(0, 9)}...${str.slice(-8)}`;
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    function isServiceActive(statusVal) {
        const rawStatus = statusVal === undefined ? "active" : String(statusVal).toLowerCase();
        return rawStatus === "1" || rawStatus === "active" || rawStatus === "online" || rawStatus === "true";
    }

    function formatArkeoTotals(uarkeoVal) {
        const num = Number(uarkeoVal || 0);
        const arkeo = num / 1_000_000;
        const arkeoStr = arkeo.toLocaleString("en-US", { minimumFractionDigits: 3, maximumFractionDigits: 3 });
        const uStr = num.toLocaleString("en-US");
        return { arkeo: `${arkeoStr} ARKEO`, uarkeo: `${uStr} uarkeo` };
    }

    function renderClaimTotals() {
        const el = document.getElementById("claimTotals");
        if (!el) return;
        if (!providerServicesData || !providerServicesData.length) {
            el.textContent = "No provider services found.";
            el.classList.add("muted");
            return;
        }
        const active = providerServicesData.filter((s) => isServiceActive(s && s.status));
        if (!active.length) {
            el.textContent = "No active services.";
            el.classList.add("muted");
            return;
        }
        const totalsMap = new Map();
        (providerServiceTotals || []).forEach((t) => {
            if (!t || !t.service) return;
            const key = String(t.service).toLowerCase();
            totalsMap.set(key, t);
        });
        const cards = active.map((s) => {
            const rawId = s?.id ?? s?.service_id ?? s?.serviceID ?? s?.service ?? "";
            const rawName = s?.name || s?.service || s?.label || String(rawId);
            const serviceKey = String(rawName || rawId).toLowerCase();
            const lookup = providerServiceLookup[rawId] || providerServiceLookup[String(rawId)] || providerServiceLookup[serviceKey];
            const displayName = (lookup && (lookup.description || lookup.name || lookup.service)) || rawName || rawId;
            const totalEntry = totalsMap.get(serviceKey);
            const { arkeo, uarkeo } = formatArkeoTotals(totalEntry ? totalEntry.total_paid_uarkeo : 0);
            const txCount = totalEntry ? totalEntry.tx_count || 0 : 0;
            const contracts = totalEntry && Array.isArray(totalEntry.contracts) ? totalEntry.contracts.length : 0;
            return `
                <div class="claim-card">
                    <div class="claim-title">${displayName || "(unknown service)"}</div>
                    <div class="claim-metric">${arkeo}</div>
                    <div class="claim-meta">${uarkeo} · txs: ${txCount}${contracts ? ` · contracts: ${contracts}` : ""}</div>
                </div>
            `;
        });
        el.classList.remove("muted");
        el.innerHTML = cards.join("");
    }

    function setStatusDot(statusId, state) {
        const badge = document.getElementById(statusId);
        if (!badge) return;
        let cls = "err";
        if (state === "ok") cls = "ok";
        else if (state === "warn") cls = "warn";
        badge.className = `status-dot ${cls}`;
    }

    async function refreshEndpointStatuses() {
        try {
            const res = await fetch(resolveApi("/api/endpoint-checks"));
            const data = await res.json();
            const ep = (data && data.endpoints) || {};
            const map = [
                ["arkeod-status", ep.arkeod_status],
                ["arkeorpc-status", ep.arkeorpc],
                ["sentinel-external-status", ep.sentinel_external],
                ["internal-sentinel-status", ep.sentinel_internal],
                ["internal-adminapi-status", ep.admin_api],
                ["internal-admin-status", ep.admin_ui],
            ];
            for (const [id, entry] of map) {
                if (!entry) {
                    setStatusDot(id, "err");
                    continue;
                }
                setStatusDot(id, entry.ok ? "ok" : "err");
            }
        } catch (e) {
            const ids = ["arkeod-status", "arkeorpc-status", "sentinel-external-status", "internal-sentinel-status", "internal-adminapi-status", "internal-admin-status"];
            ids.forEach((id) => setStatusDot(id, "err"));
        }
    }

    async function refreshSentinelStatus() {
        try {
            const res = await fetch(resolveApi("/api/sentinel-status"));
            const data = await res.json();
            updateSentinelStatusDisplay(data);
        } catch (e) {
            const badgeTop = document.getElementById("sentinelStatusBadgeTop");
            if (badgeTop) { badgeTop.className = "status-badge status-warn"; badgeTop.textContent = "unavailable"; }
        }
    }

    async function controlSentinel(action) {
        showResultModal("Sentinel Control", `Sending ${action}...`);
        try {
            const res = await fetch(resolveApi("/api/sentinel-control"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ action }),
            });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Sentinel Control", `${action} ok: ${JSON.stringify(data)}`);
                refreshInfo();
            } else {
                showResultModal("Sentinel Control", `${action} failed: ${JSON.stringify(data)}`);
            }
        } catch (e) {
                showResultModal("Sentinel Control", `${action} request error: ${e}`);
        }
    }

    async function runProviderClaims() {
        showResultModal("Provider Claims", "Running provider claims...");
        try {
            const res = await fetch(resolveApi("/api/provider-claims"), { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Provider Claims", JSON.stringify(data, null, 2));
            } else {
                showResultModal("Provider Claims", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Claims", "Request failed: " + e);
        }
    }

    async function runProviderTotals() {
        showResultModal("Provider Totals", "Running provider totals...");
        try {
            const res = await fetch(resolveApi("/api/provider-totals"), { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify({}) });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Provider Totals", JSON.stringify(data, null, 2));
            } else {
                showResultModal("Provider Totals", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Totals", "Request failed: " + e);
        }
    }

    async function runProviderExport() {
        showResultModal("Provider Export", "Exporting...");
        try {
            const res = await fetch(resolveApi("/api/provider-export"), { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                const content = JSON.stringify(data.export || data, null, 2);
                const blob = new Blob([content], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                a.download = "provider-export.json";
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                showResultModal("Provider Export", `Exported to ${data.path || "(unknown)"}${data.bytes ? ` (${data.bytes} bytes)` : ""}`);
            } else {
                showResultModal("Provider Export", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Export", "Request failed: " + e);
        }
    }

    function triggerProviderImport() {
        const input = document.getElementById("providerImportInput");
        if (input) input.click();
    }

    async function handleProviderImport(event) {
        const file = event.target.files && event.target.files[0];
        if (!file) return;
        try {
            const text = await file.text();
            const json = JSON.parse(text);
            showResultModal("Provider Import", "Uploading...");
            const res = await fetch(resolveApi("/api/provider-import"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(json),
            });
            let data;
            try {
                data = await res.json();
            } catch (e) {
                const txt = await res.text().catch(() => "");
                showResultModal("Provider Import", `Import error: non-JSON response (${res.status})\n${txt}`);
                return;
            }
            if (res.ok) {
                showResultModal("Provider Import", `Imported and cached to ${data.path || "(unknown)"}`);
            } else {
                showResultModal("Provider Import", "Import error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Provider Import", "Failed to import: " + e);
        } finally {
            event.target.value = "";
        }
    }

    async function runSentinelSync() {
        showResultModal("Sync Sentinel", "Syncing...");
        try {
            const res = await fetch(resolveApi("/api/sentinel-sync"), { method: "POST" });
            const data = await res.json();
            if (res.ok) {
                showResultModal("Sync Sentinel", `Synced:\n${JSON.stringify(data, null, 2)}`);
            } else {
                showResultModal("Sync Sentinel", "Error: " + JSON.stringify(data, null, 2));
            }
        } catch (e) {
            showResultModal("Sync Sentinel", "Request failed: " + e);
        }
    }

    function showResultModal(title, bodyText) {
        const modal = document.getElementById("resultModal");
        const t = document.getElementById("modalTitle");
        const b = document.getElementById("modalBody");
        if (t) t.textContent = title || "Result";
        if (b) b.textContent = bodyText || "";
        if (modal) modal.style.display = "flex";
    }

    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.style.display = "none";
    }

    async function renderEndpointPanel(sCfg, provObj, envMeta) {
        const el = document.getElementById("endpointList");
        if (!el) return;
        const envLower = (sCfg && sCfg.env) || {};
        const envFile = (sCfg && sCfg.env_file) || {};
        const pickEnv = (keyUpper) => {
            const lower = keyUpper.toLowerCase();
            return (envFile[keyUpper] ?? envLower[lower] ?? "");
        };
        const meta = (provObj && provObj.provider_metadata) || envMeta || {};
        const pickMeta = (key) => meta[key] || meta[key.toUpperCase()] || meta[key.toLowerCase()] || "";

        const arkeodNode = pickEnv("EXTERNAL_ARKEOD_NODE") || pickEnv("ARKEOD_NODE") || pickMeta("EXTERNAL_ARKEOD_NODE") || pickMeta("ARKEOD_NODE");
        const restApi = pickEnv("ARKEO_REST_API_PORT") || pickEnv("PROVIDER_HUB_URI") || pickMeta("ARKEO_REST_API_PORT") || pickMeta("PROVIDER_HUB_URI");
        const sentinelNode = pickEnv("SENTINEL_NODE") || pickMeta("SENTINEL_NODE");
        const sentinelPort = pickEnv("SENTINEL_PORT") || pickMeta("SENTINEL_PORT") || "3636";
        const resolvedHost = extractHostFromValue(sentinelNode) || adminHost;
        const sentinelFull = sentinelNode ? `${sentinelNode}:${sentinelPort}` : `(not set):${sentinelPort}`;
        // Always use loopback for the internal check
        const sentinelInternalUrl = buildBaseUrl("127.0.0.1", sentinelPort);
        const sentinelExternalHost = extractHostFromValue(sentinelNode) || adminHost;
        const sentinelExternalUrl = buildBaseUrl(sentinelExternalHost, sentinelPort);
        const adminApiPort = pickEnv("ADMIN_API_PORT") || pickMeta("ADMIN_API_PORT") || "9999";
        const adminPort = pickEnv("ADMIN_PORT") || pickMeta("ADMIN_PORT") || "8080";
        const pageHost = (window.location && window.location.hostname) || adminHost;
        const adminApiUrl = buildBaseUrl(pageHost, adminApiPort);
        const adminUiUrl = buildBaseUrl(pageHost, adminPort);

        const makeRow = (label, value, statusId) => {
            return `<div class="endpoint-row">
                <strong>${label}: </strong><br>
                <span id="${statusId}" class="status-dot warn"></span>
                <span class="muted endpoint-url">${value || "(not set)"}</span>
            </div>`;
        };

        el.innerHTML = [
            `<div class="endpoint-section-title"><h3>External Access</h3></div>`,
            makeRow("Arkeo Node", arkeodNode, "arkeod-status"),
            makeRow("Arkeo RPC", restApi, "arkeorpc-status"),
            makeRow("Sentinel RPC (External)", sentinelExternalUrl, "sentinel-external-status"),
            `<div class="endpoint-section-title"><h3>Internal Access</h3></div>`,
            makeRow("Sentinel RPC (Internal)", sentinelInternalUrl, "internal-sentinel-status"),
            makeRow("Admin API", `${adminApiUrl}/api/version`, "internal-adminapi-status"),
            makeRow("Admin UI", `${adminUiUrl}`, "internal-admin-status")
        ].join("");

        // Kick off reachability checks from the backend
        refreshEndpointStatuses();
    }

    async function getVersion() {
        try {
            let res = await fetch(resolveApi("/api/version"));
            let data = await res.json();
            if (data.arkeod_version) {
                document.getElementById("version").textContent = "arkeod version: " + data.arkeod_version;
            } else if (data.error) {
                document.getElementById("version").textContent = "Error getting version: " + data.error;
            } else {
                document.getElementById("version").textContent = "Unknown version response";
            }
        } catch (e) {
            document.getElementById("version").textContent = "Error fetching version: " + e;
        }
    }

    function editService(idx) {
        if (!providerServicesData || !providerServicesData[idx]) return;
        try {
            localStorage.setItem("providerServiceEdit", JSON.stringify(providerServicesData[idx]));
        } catch (e) {
            console.warn("Failed to cache service for edit", e);
        }
        window.location.href = "provider.html";
    }

    async function copyPubkeyFromHeader() {
        const el = document.getElementById("headerPubkey");
        const full = (el && el.dataset.fullPubkey) || currentPubkey || "";
        if (full) {
            await copyPubkey(full);
        } else {
            showResultModal("Copy Provider Pubkey", "Pubkey unavailable");
        }
    }

    async function copyPubkey(val) {
        try {
            await navigator.clipboard.writeText(val);
            showResultModal("Copy Provider Pubkey", `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            const msg = [
                "Failed to copy pubkey (clipboard is blocked in insecure contexts).",
                "",
                "You can copy it manually:",
                val || "(unavailable)"
            ].join("\n");
            showResultModal("Copy Provider Pubkey", msg);
        }
    }

    async function copyAddressFromHeader() {
        const el = document.getElementById("headerAddress");
        const full = (el && el.dataset.fullAddress) || "";
        const fallback = document.getElementById("headerAddressValue")?.textContent || "";
        const val = full || fallback;
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Provider Address", "Provider address unavailable");
            return;
        }
        try {
            await navigator.clipboard.writeText(val);
            showResultModal("Copy Provider Address", `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const msg = [
                "Failed to copy address (clipboard is blocked in insecure contexts).",
                "",
                "You can copy it manually:",
                val
            ].join("\n");
            showResultModal("Copy Provider Address", msg);
        }
    }

    window.addEventListener('load', () => {
        getVersion();
        refreshInfo();
        refreshSentinelStatus();
        setInterval(refreshSentinelStatus, 5000);
        setInterval(refreshInfo, 10000);
    });
    document.addEventListener('visibilitychange', () => {
        if (!document.hidden) {
            refreshInfo();
        }
    });
    window.addEventListener('pageshow', (event) => {
        if (event.persisted) {
            refreshInfo();
        }
    });
</script>

</body>
</html>
