<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Marketplace | Provider Management</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>

<div id="savingOverlay" class="overlay hidden">
    <div class="overlay-card">
        <h3>Please wait…</h3>
        <p>Submitting two on-chain contracts, updating sentinel config, and restarting the sentinel. This can take up to ~15 seconds.</p>
    </div>
</div>

<div class="card header-card">
    <div class="row-between header-top">
        <div class="header-left">
            <div class="header-brand-row">
                <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                <div class="header-brand">
                    <span class="brand-main">Arkeo Marketplace</span>
                    <span class="brand-sep">|</span>
                    <span class="brand-sub">Provider Manager</span>
                </div>
            </div>
            <h1>Provider Service Management</h1>
        </div>
        <div class="header-right">
            <a class="btn primary" href="index.html">Back to Admin Home</a>
        </div>
    </div>
</div>

<div class="card">
    <h2 class="mt-0">Bond Provider Service</h2>
    <div class="hint mt-6">
        Saving can take up to ~15 seconds. Two contracts are submitted and verified on-chain, the sentinel config is updated, and the sentinel restarts. Please be patient.
    </div>
    <form id="bondForm" onsubmit="bondProvider(event)">
        <table>
            <tr>
                <td class="label">
                    Provider Service
                    <div class="hint">Select an Arkeo supported service you want to provide on the Arkeo Marketplace.</div>
                </td>
                <td class="value">
                    <select id="bondService" required>
                        <option value="">Select a service</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Status
                    <div class="hint">Choose Active or Inactive on this provider service.</div>
                </td>
                <td class="value">
                    <select id="status">
                        <option value="1" selected>Active</option>
                        <option value="0">Inactive</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Min Contract Duration
                    <div class="hint">Minimum supported contract time you want to support, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="minContractDur" value="5" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Max Contract Duration
                    <div class="hint">Maximum supported contract time you want to support, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="maxContractDur" value="432000" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Subscription Rate
                    <div class="hint">Cost per service transaction.</div>
                </td>
                <td class="value">
                    <input type="text" id="subscriptionRates" value="200uarkeo" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Pay As You Go Rate
                    <div class="hint">Cost per service transaction.</div>
                </td>
                <td class="value">
                    <input type="text" id="payAsYouGoRates" value="200uarkeo" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Settlement Duration
                    <div class="hint">After a contract closes, the time to reconcile transactions before releasing remainder, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="settlementDur" value="1000" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Bond Amount
                    <div class="hint">On a new provider, 100000000uarkeo is required. On an edit, a minimum of 1uarkeo is required.</div>
                </td>
                <td class="value">
                    <input type="text" id="bondAmountInput" value="1" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Current Bond Amount
                    <div class="hint">The minimum total bond amount is 100000000uarkeo.</div>
                </td>
                <td class="value">
                    <span id="currentBondAmountLabel">–</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Sentinel URI
                    <div class="hint">The URI and port for the sentinel service for your provider.</div>
                </td>
                <td class="value">
                    <input type="text" id="sentinelUri" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC URL
                    <div class="hint">Endpoint for this service (e.g., http://localhost:8332).</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcUrl" placeholder="http://localhost:8332" required />
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC User
                    <div class="hint">Optional RPC username.</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcUser" placeholder="rpc-username" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC Password
                    <div class="hint">Optional RPC password.</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcPass" placeholder="rpc-password" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Key
                    <div class="hint">The hot wallet key used.</div>
                </td>
                <td class="value">
                    <span id="walletKey">(loading...)</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Key Backend
                    <div class="hint">The keyring backend used.</div>
                </td>
                <td class="value">
                    <span id="bondKeyringLabel">test</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Pubkey
                    <div class="hint">The pubkey shown on the blockchain contracts.</div>
                </td>
                <td class="value">
                    <span id="bech32PubkeyLabel">(pending)</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Bond Fees
                    <div class="hint">Default bond fees.</div>
                </td>
                <td class="value">
                    <span id="bondFeesLabel">200uarkeo</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Mod Nonce
                    <div class="hint">Used to increment updates.</div>
                </td>
                <td class="value">
                    <span id="metadataNonceLabel">1</span>
                    <input type="hidden" id="metadataNonceHidden" value="1" />
                </td>
            </tr>
        </table>
        <button type="submit" id="bondSubmit" class="primary">Submit Provider Info</button>
    </form>
    </div>
</div>

<pre id="bondResult"></pre>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<pre id="servicesDebug" class="pre-wrap"></pre>

<script>
    const DEFAULT_ADMIN_API_PORT = "9999";
    let adminHost = (window.location && window.location.hostname) || "localhost";
    let adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);

    function buildBaseUrl(host, port) {
        const proto = (window.location && window.location.protocol === "https:") ? "https:" : "http:";
        const cleaned = (host || "").replace(/^https?:\/\//, "").replace(/\/+$/, "");
        return `${proto}//${cleaned}${port ? `:${port}` : ""}`;
    }

    function extractHostFromValue(val) {
        if (!val) return "";
        try {
            const u = val.startsWith("http") ? new URL(val) : new URL(`http://${val}`);
            return u.hostname || "";
        } catch (e) {
            return "";
        }
    }

    function setAdminHost(candidateHost) {
        if (!candidateHost) return;
        const cleaned = extractHostFromValue(candidateHost) || candidateHost;
        if (cleaned && cleaned !== adminHost) {
            adminHost = cleaned;
            adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);
        }
    }

    function resolveApi(path) {
        if (!path.startsWith("/")) path = `/${path}`;
        return `${adminApiBase}${path}`;
    }

    let pendingEditService = null;
    let cachedProviderForm = null;
    let cachedServiceChoice = null;
    let servicesLoaded = false;
    let servicesCatalog = [];
    let editingExisting = false;
    let noncePrimed = false;
    let nonceLockedFromEdit = false;
    let sentinelServices = [];

    function setBondAmountForMode() {
        const input = document.getElementById("bondAmountInput");
        if (!input) return;
        // Default to 1; respect any user-entered value.
        if (!input.value) input.value = "1";
    }

    function formatBondDisplay(val) {
        if (!val) return "–";
        const trimmed = String(val).trim();
        if (!trimmed) return "–";
        // If it already ends with uarkeo (case-insensitive), keep it; otherwise append for display.
        if (trimmed.toLowerCase().endsWith("uarkeo")) return trimmed;
        return `${trimmed}uarkeo`;
    }

    function parseBondAmountUnits(val) {
        if (!val) return NaN;
        const m = String(val).trim().match(/^(\d+)/);
        if (!m) return NaN;
        return Number(m[1]);
    }

    function showSavingOverlay(show) {
        const el = document.getElementById("savingOverlay");
        if (!el) return;
        el.style.display = show ? "flex" : "none";
    }

    function pullPendingEdit() {
        try {
            const raw = localStorage.getItem("providerServiceEdit");
            if (raw) {
                pendingEditService = JSON.parse(raw);
                editingExisting = true;
                localStorage.removeItem("providerServiceEdit");
            } else {
                editingExisting = false;
            }
        } catch (e) {
            console.warn("Failed to read cached service edit", e);
            editingExisting = false;
        }
        setBondAmountForMode();
    }

    async function loadServices() {
        const select = document.getElementById("bondService");
        select.innerHTML = '<option value="">Loading services...</option>';
        try {
            const res = await fetch(resolveApi("/api/services"));
            const data = await res.json();
            setPre("servicesDebug", "");
            if (!res.ok) {
                select.innerHTML = '<option value="">Error loading services</option>';
                setPre("bondResult", "Error: " + JSON.stringify(data, null, 2));
                setPre("servicesDebug", "Debug services response:\n" + JSON.stringify(data, null, 2));
                return;
            }
            const services = data.services || [];
            servicesCatalog = services;
            if (!services.length) {
                select.innerHTML = '<option value="">No services found</option>';
                setPre("servicesDebug", "Debug services response:\n" + JSON.stringify(data, null, 2));
                return;
            }
            select.innerHTML = '<option value="">Select a service</option>';
            for (const svc of services) {
                const id = svc.id ?? "";
                const name = svc.name ?? "";
                const desc = svc.description ?? "";
                if (!id && !name) continue;
                const opt = document.createElement("option");
                // Use the service name as the value; fall back to id only if name missing
                opt.value = name || id;
                opt.dataset.id = id;
                const label = name ? `${name} (${id})` : id;
                const extra = desc ? `${desc} (${name || id} : ${id})` : label;
                opt.textContent = desc ? extra : label;
                select.appendChild(opt);
            }
            setPre("servicesDebug", "");
            servicesLoaded = true;
            applyPendingEdit();
            applyCachedProviderForm();
        } catch (e) {
            select.innerHTML = '<option value="">Failed to load services</option>';
            setPre("bondResult", "Request failed: " + e);
            setPre("servicesDebug", "Request failed: " + e);
        }
    }

    async function bondProvider(event) {
        event.preventDefault();
        const submitBtn = document.getElementById("bondSubmit");
        submitBtn.disabled = true;
        submitBtn.textContent = "Submitting...";
        const bondAmountInput = document.getElementById("bondAmountInput");
        const bondAmount = (bondAmountInput?.value || "").trim() || "1";
        if (!/^[0-9]+$/.test(bondAmount)) {
            alert("Bond amount must be an integer (no letters or symbols).");
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            return;
        }
        const bondUnits = parseBondAmountUnits(bondAmount);
        if (!editingExisting && (!Number.isFinite(bondUnits) || bondUnits < 100000000)) {
            alert("Bond amount must be at least 100000000 for a new provider.");
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            return;
        }
        // Always increment the metadata nonce immediately before submitting
        const metadataNonce = incrementMetadataNonce();
        const select = document.getElementById("bondService");
        const selectedOption = select.options[select.selectedIndex];
        const serviceId = selectedOption ? selectedOption.dataset.id || "" : "";
        const serviceName = document.getElementById("bondService").value.trim();
        const payload = {
            service: document.getElementById("bondService").value.trim(),
            bond: bondAmount,
            sentinel_uri: document.getElementById("sentinelUri").value.trim(),
            metadata_nonce: metadataNonce,
            status: document.getElementById("status").value.trim(),
            min_contract_dur: document.getElementById("minContractDur").value.trim(),
            max_contract_dur: document.getElementById("maxContractDur").value.trim(),
            subscription_rates: document.getElementById("subscriptionRates").value.trim(),
            pay_as_you_go_rates: document.getElementById("payAsYouGoRates").value.trim(),
            settlement_dur: document.getElementById("settlementDur").value.trim(),
            rpc_url: document.getElementById("rpcUrl").value.trim(),
            rpc_user: document.getElementById("rpcUser").value.trim(),
            rpc_pass: document.getElementById("rpcPass").value.trim(),
        };
        setPre("bondResult", "Submitting bond and mod...");
        showSavingOverlay(true);
        try {
            const res = await fetch(resolveApi("/api/bond-mod-provider"), {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(payload),
            });
            const data = await res.json();
            const resOk = res.ok;
            updateDerivedFields(data);
            try {
                const rebuildRes = await fetch(resolveApi("/api/sentinel-rebuild"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        service_overrides: [
                            {
                                name: payload.service,
                                id: serviceId,
                                service: serviceName,
                                status: payload.status,
                                rpc_url: payload.rpc_url,
                                rpc_user: payload.rpc_user,
                                rpc_pass: payload.rpc_pass,
                            },
                        ],
                    }),
                });
                const rebuildData = await rebuildRes.json();
                if (!rebuildRes.ok) {
                    setPre("bondResult", "Sentinel rebuild failed: " + JSON.stringify(rebuildData, null, 2));
                    return;
                }
                setPre("bondResult", "Sentinel rebuild ok:\n" + JSON.stringify(rebuildData, null, 2));
            } catch (e) {
                console.warn("sentinel rebuild failed", e);
                setPre("bondResult", "Sentinel rebuild failed: " + e);
                return;
            }
            if (!resOk) {
                setPre("bondResult", "Error: " + JSON.stringify(data, null, 2));
                return;
            }
            setPre("bondResult", JSON.stringify(data, null, 2));
            // Do not auto-redirect; keep the user on the form to review results.
        } catch (e) {
            setPre("bondResult", "Request failed: " + e);
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            // Overlay will be hidden only if we remain on the page (errors)
            showSavingOverlay(false);
        }
    }

    function incrementMetadataNonce() {
        const hidden = document.getElementById("metadataNonceHidden");
        const label = document.getElementById("metadataNonceLabel");
        const current = parseInt(hidden.value || "0", 10);
        const next = Number.isFinite(current) ? current + 1 : 1;
        hidden.value = String(next);
        if (label) label.textContent = String(next);
        return String(next);
    }

    function updateDerivedFields(data) {
        if (!data) return;
        const pubkeyLabel = document.getElementById("bech32PubkeyLabel");
        if (data.pubkey && data.pubkey.bech32) {
            pubkeyLabel.textContent = data.pubkey.bech32;
        } else if (data.pubkey_error) {
            pubkeyLabel.textContent = data.pubkey_error;
        }
        if (data.bond && !editingExisting) {
            const currentBond = document.getElementById("currentBondAmountLabel");
            if (currentBond) currentBond.textContent = formatBondDisplay(data.bond);
        }
        setBondAmountForMode();
        if (data.fees) {
            document.getElementById("bondFeesLabel").textContent = data.fees;
        }
        if (data.keyring_backend) {
            document.getElementById("bondKeyringLabel").textContent = data.keyring_backend;
        }
        if (data.user) {
            document.getElementById("walletKey").textContent = data.user;
        }
        if (data.sentinel_uri) {
            document.getElementById("sentinelUri").value = data.sentinel_uri;
        }
        if (data.inputs) {
            if (data.inputs.sentinel_uri) document.getElementById("sentinelUri").value = data.inputs.sentinel_uri;
            if (data.inputs.metadata_nonce && !nonceLockedFromEdit) {
                document.getElementById("metadataNonceHidden").value = data.inputs.metadata_nonce;
                document.getElementById("metadataNonceLabel").textContent = data.inputs.metadata_nonce;
            }
            if (data.inputs.status) document.getElementById("status").value = data.inputs.status;
            if (data.inputs.min_contract_dur) document.getElementById("minContractDur").value = data.inputs.min_contract_dur;
            if (data.inputs.max_contract_dur) document.getElementById("maxContractDur").value = data.inputs.max_contract_dur;
            if (data.inputs.subscription_rates) document.getElementById("subscriptionRates").value = data.inputs.subscription_rates;
            if (data.inputs.pay_as_you_go_rates) document.getElementById("payAsYouGoRates").value = data.inputs.pay_as_you_go_rates;
            if (data.inputs.settlement_dur) document.getElementById("settlementDur").value = data.inputs.settlement_dur;
        }
        applyPendingEdit();
        applyCachedProviderForm();
    }

    async function loadProviderInfo() {
        try {
            const res = await fetch(resolveApi("/api/provider-info"));
            const data = await res.json();
            if (!res.ok) {
                setPre("bondResult", "Error loading provider info: " + JSON.stringify(data, null, 2));
                return;
            }
            cachedProviderForm = (data.provider_export && data.provider_export.provider_form) || null;
            if (cachedProviderForm && cachedProviderForm.service) {
                cachedServiceChoice = cachedProviderForm.service;
            }
            updateDerivedFields(data);
            if (data.fees) document.getElementById("bondFeesLabel").textContent = data.fees;
            if (data.keyring_backend) document.getElementById("bondKeyringLabel").textContent = data.keyring_backend;
            if (data.user) document.getElementById("walletKey").textContent = data.user;
            if (data.pubkey_error) setPre("bondResult", data.pubkey_error);
            if (data.metadata_nonce && !nonceLockedFromEdit) {
                document.getElementById("metadataNonceHidden").value = data.metadata_nonce;
                document.getElementById("metadataNonceLabel").textContent = data.metadata_nonce;
            }
            if (data.sentinel_uri) {
                document.getElementById("sentinelUri").value = data.sentinel_uri;
                setAdminHost(data.sentinel_uri);
            }
            applyPendingEdit();
            applyCachedProviderForm();
        } catch (e) {
            setPre("bondResult", "Request failed: " + e);
        }
    }

    async function loadSentinelConfig() {
        try {
            const res = await fetch(resolveApi("/api/sentinel-config"));
            const data = await res.json();
            if (res.ok && data && data.config && Array.isArray(data.config.services)) {
                sentinelServices = data.config.services;
            }
            applyPendingEdit();
        } catch (e) {
            console.warn("Failed to load sentinel config", e);
        }
    }

    function setPre(id, text) {
        const el = document.getElementById(id);
        if (!el) return;
        if (text === "" || text === null || text === undefined) {
            el.style.display = "none";
            el.textContent = "";
            return;
        }
        el.style.display = "block";
        el.textContent = text;
    }

    function setSelectFromCandidates(select, candidates) {
        if (!select || !Array.isArray(candidates)) return false;
        for (const cand of candidates) {
            if (!cand) continue;
            const val = String(cand);
            for (const opt of select.options) {
                const txt = opt.text || "";
                const normalizedText = txt.toLowerCase();
                const normalizedVal = val.toLowerCase();
                const dataId = (opt.dataset && opt.dataset.id) ? opt.dataset.id.toLowerCase() : "";
                if (
                    opt.value.toLowerCase() === normalizedVal ||
                    dataId === normalizedVal ||
                    normalizedText === normalizedVal ||
                    normalizedText.includes(`(${normalizedVal} :`) ||
                    normalizedText.includes(`(${normalizedVal}:`) ||
                    normalizedText.includes(`(${normalizedVal})`)
                ) {
                    select.value = opt.value;
                    return true;
                }
            }
        }
        return false;
    }

    function applyPendingEdit() {
        if (!pendingEditService) return;
        if (!servicesLoaded) return;
        const svc = pendingEditService;
        const select = document.getElementById("bondService");
        const svcId =
            svc.id ??
            svc.service_id ??
            svc.serviceID ??
            (typeof svc.service === "number" || typeof svc.service === "string" ? svc.service : null);
        let resolvedName = svc.name || svc.service || svc.label || "";
        if (!resolvedName && servicesCatalog && svcId !== undefined && svcId !== null) {
            const found = servicesCatalog.find(
                (s) => s && String(s.id ?? "") === String(svcId)
            );
            if (found && found.name) {
                resolvedName = found.name;
            }
        }
        const candidates = [
            resolvedName,
            svc.name,
            svc.service,
            svc.label,
            svcId,
        ].filter(Boolean).map(String);
        setSelectFromCandidates(select, candidates);

        if (svc.status !== undefined && svc.status !== null) {
            const rawStatus = String(svc.status).toLowerCase();
            const statusVal = rawStatus === "online" || rawStatus === "active" || rawStatus === "1" ? "1" : "0";
            document.getElementById("status").value = statusVal;
        }
        if (svc.min_contract_dur) document.getElementById("minContractDur").value = svc.min_contract_dur;
        if (svc.max_contract_dur) document.getElementById("maxContractDur").value = svc.max_contract_dur;
        if (svc.subscription_rates) document.getElementById("subscriptionRates").value = svc.subscription_rates;
        if (svc.pay_as_you_go_rates) document.getElementById("payAsYouGoRates").value = svc.pay_as_you_go_rates;
        if (svc.settlement_dur) document.getElementById("settlementDur").value = svc.settlement_dur;
        if (svc.bond !== undefined) {
            const currentBond = document.getElementById("currentBondAmountLabel");
            if (currentBond) currentBond.textContent = formatBondDisplay(svc.bond);
        }
        if (svc.metadata_uri) document.getElementById("sentinelUri").value = svc.metadata_uri;
        if (svc.metadata_nonce) {
            document.getElementById("metadataNonceHidden").value = svc.metadata_nonce;
            document.getElementById("metadataNonceLabel").textContent = svc.metadata_nonce;
            noncePrimed = true;
            nonceLockedFromEdit = true;
        }
        // Fill RPC creds from sentinel.yaml if present
        if (sentinelServices && sentinelServices.length) {
            const match = sentinelServices.find((s) => {
                if (!s) return false;
                const sid = String(s.id ?? "");
                const sname = String(s.name ?? s.service ?? "");
                if (svcId !== undefined && svcId !== null && String(svcId) === sid) return true;
                if (resolvedName && resolvedName === sname) return true;
                return false;
            });
                if (match) {
                    if (match.rpc_url) document.getElementById("rpcUrl").value = match.rpc_url;
                    if (match.rpc_user !== undefined) document.getElementById("rpcUser").value = match.rpc_user;
                    if (match.rpc_pass !== undefined) document.getElementById("rpcPass").value = match.rpc_pass;
                }
        }
        setBondAmountForMode();
        pendingEditService = null;
    }

    function applyCachedProviderForm() {
        if (!cachedProviderForm || editingExisting) return;
        const cf = cachedProviderForm;
        const setVal = (id, val) => {
            const el = document.getElementById(id);
            if (!el) return;
            if (el.value === "" || el.value === el.placeholder) {
                el.value = val;
            }
        };
        if (cf.sentinel_uri) setVal("sentinelUri", cf.sentinel_uri);
        if (cf.status) setVal("status", cf.status);
        if (cf.min_contract_dur) setVal("minContractDur", cf.min_contract_dur);
        if (cf.max_contract_dur) setVal("maxContractDur", cf.max_contract_dur);
        if (cf.subscription_rates) setVal("subscriptionRates", cf.subscription_rates);
        if (cf.pay_as_you_go_rates) setVal("payAsYouGoRates", cf.pay_as_you_go_rates);
        if (cf.settlement_dur) setVal("settlementDur", cf.settlement_dur);
        if (cf.rpc_url) setVal("rpcUrl", cf.rpc_url);
        if (cf.rpc_user) setVal("rpcUser", cf.rpc_user);
        if (cf.rpc_pass) setVal("rpcPass", cf.rpc_pass);
        if (cf.service && servicesLoaded) {
            const select = document.getElementById("bondService");
            setSelectFromCandidates(select, [cf.service]);
        } else if (cf.service) {
            cachedServiceChoice = cf.service;
        }
    }

    function txSucceeded(tx) {
        if (!tx) return false;
        if (tx.exit_code !== 0) return false;
        if (typeof tx.output === "string") {
            const m = tx.output.match(/code:\s*(\d+)/);
            if (m && m[1] && m[1] !== "0") return false;
        }
        return true;
    }

    function bondAndModSucceeded(data) {
        return txSucceeded(data?.bond_tx) && txSucceeded(data?.mod_tx);
    }

    window.addEventListener("load", () => {
        pullPendingEdit();
        loadServices();
        loadProviderInfo();
        loadSentinelConfig();
    });
</script>
</body>
</html>
