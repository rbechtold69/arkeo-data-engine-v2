<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Marketplace | Provider Management</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>

<div class="card header-card">
    <div class="row-between header-top">
        <div class="header-left">
            <div class="header-brand-row">
                <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                <div class="header-brand">
                    <span class="brand-main">Arkeo Marketplace</span>
                    <span class="brand-sep">|</span>
                    <span class="brand-sub">Provider Manager</span>
                </div>
            </div>
            <h1>Provider Service Management</h1>
        </div>
        <div class="header-right header-right-with-actions">
            <a class="btn-ghost" href="index.html">Back to Dashboard</a>
        </div>
    </div>
</div>

<div class="card">
    <h2 class="mt-0">Bond Provider Service</h2>
    <div class="hint mt-6">
        Saving can take up to ~15 seconds. Two contracts are submitted and verified on-chain, the sentinel config is updated, and the sentinel restarts. Please be patient.
    </div>
    <div id="resultModal" class="overlay hidden">
        <div class="overlay-card modal-card fixed-modal">
            <h3 id="modalTitle">Result</h3>
            <div id="modalBody" class="modal-body scroll-body"></div>
            <div class="modal-actions">
                <button id="modalCloseBtn" class="primary" type="button" onclick="closeModal()">OK</button>
            </div>
        </div>
    </div>
    <form id="bondForm" onsubmit="bondProvider(event)">
        <table>
            <tr>
                <td class="label">
                    Provider Service
                    <div class="hint">Select an Arkeo supported service you want to provide on the Arkeo Marketplace.</div>
                </td>
                <td class="value">
                    <div class="combo-select">
                        <div id="bondServiceDropdown" class="combo-display" onclick="toggleBondServiceMenu(event)">
                            <span id="bondServiceSelected">Select a service</span>
                            <span class="combo-caret">▾</span>
                        </div>
                        <div id="bondServiceMenu" class="combo-menu hidden">
                            <input type="text" id="bondServiceSearchInput" class="full combo-search" placeholder="Search services..." oninput="filterBondServiceOptions()" autocomplete="off" />
                            <div id="bondServiceOptions" class="combo-options"></div>
                        </div>
                        <select id="bondService" class="hidden" required>
                            <option value="">Select a service</option>
                        </select>
                    </div>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Status
                    <div class="hint">Choose Active or Inactive on this provider service.</div>
                </td>
                <td class="value">
                    <select id="status">
                        <option value="1" selected>Active</option>
                        <option value="0">Inactive</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Min Contract Duration
                    <div class="hint">Minimum supported contract time you want to support, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="minContractDur" value="5" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Max Contract Duration
                    <div class="hint">Maximum supported contract time you want to support, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="maxContractDur" value="432000" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Subscription Rate
                    <div class="hint">Cost per service transaction.</div>
                </td>
                <td class="value">
                    <input type="text" id="subscriptionRates" value="200uarkeo" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Pay As You Go Rate
                    <div class="hint">Cost per service transaction.</div>
                </td>
                <td class="value">
                    <input type="text" id="payAsYouGoRates" value="200uarkeo" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Settlement Duration
                    <div class="hint">After a contract closes, the time to reconcile transactions before releasing remainder, in blocks (5-6 seconds per block).</div>
                </td>
                <td class="value">
                    <input type="number" id="settlementDur" value="1000" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Bond Amount
                    <div class="hint">On a new provider, 100000000uarkeo is required. On an edit, a minimum of 1uarkeo is required.</div>
                </td>
                <td class="value">
                    <input type="number" id="bondAmountInput" value="" placeholder="100000000" min="-1000000000" max="1000000000" step="1" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Current Bond Amount
                    <div class="hint">The minimum total bond amount is 100000000uarkeo.</div>
                </td>
                <td class="value">
                    <span id="currentBondAmountLabel">–</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Sentinel URI
                    <div class="hint">The URI and port for the sentinel service for your provider.</div>
                </td>
                <td class="value">
                    <div id="sentinelUriDisplay" class="muted"></div>
                    <input type="hidden" id="sentinelUri" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Location
                    <div class="hint">Select the region for this service.</div>
                </td>
                <td class="value">
                    <select id="locationSelect" required>
                        <option value="">Select a region</option>
                        <option>Africa</option>
                        <option>Africa – Northern</option>
                        <option>Africa – Eastern</option>
                        <option>Africa – Middle</option>
                        <option>Africa – Western</option>
                        <option>Africa – Southern</option>
                        <option>Americas</option>
                        <option>Americas – Northern</option>
                        <option>Americas – Caribbean</option>
                        <option>Americas – Central</option>
                        <option>Americas – South</option>
                        <option>Asia</option>
                        <option>Asia – Central</option>
                        <option>Asia – Eastern</option>
                        <option>Asia – Southeastern</option>
                        <option>Asia – Southern</option>
                        <option>Asia – Western</option>
                        <option>Europe</option>
                        <option>Europe – Northern</option>
                        <option>Europe – Eastern</option>
                        <option>Europe – Southern</option>
                        <option>Europe – Western</option>
                        <option>Oceania</option>
                        <option>Oceania – Australia & New Zealand</option>
                        <option>Oceania – Melanesia</option>
                        <option>Oceania – Micronesia</option>
                        <option>Oceania – Polynesia</option>
                        <option>Antarctica</option>
                    </select>
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC URL
                    <div class="hint">Endpoint for this service (e.g., http://localhost:8332).</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcUrl" placeholder="http://localhost:8332" required />
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC User
                    <div class="hint">Optional RPC username.</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcUser" placeholder="rpc-username" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    RPC Password
                    <div class="hint">Optional RPC password.</div>
                </td>
                <td class="value">
                    <input type="text" id="rpcPass" placeholder="rpc-password" />
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Key
                    <div class="hint">The hot wallet key used.</div>
                </td>
                <td class="value">
                    <span id="walletKey">(loading...)</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Key Backend
                    <div class="hint">The keyring backend used.</div>
                </td>
                <td class="value">
                    <span id="bondKeyringLabel">test</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Hotwallet Pubkey
                    <div class="hint">The pubkey shown on the blockchain contracts.</div>
                </td>
                <td class="value">
                    <span id="bech32PubkeyLabel">(pending)</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Bond Fees
                    <div class="hint">Default bond fees.</div>
                </td>
                <td class="value">
                    <span id="bondFeesLabel">200uarkeo</span>
                </td>
            </tr>
            <tr>
                <td class="label">
                    Mod Nonce
                    <div class="hint">Used to increment updates.</div>
                </td>
                <td class="value">
                    <span id="metadataNonceLabel">1</span>
                    <input type="hidden" id="metadataNonceHidden" value="1" />
                </td>
            </tr>
        </table>
        <button type="submit" id="bondSubmit" class="primary">Submit Provider Info</button>
    </form>
    </div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<script>
    let DEFAULT_ADMIN_API_PORT = (() => {
        try {
            const u = new URL(window.location.href);
            return u.searchParams.get("api_port") || "9999";
        } catch (e) {
            return "9999";
        }
    })();
    // Always anchor to the page host
    let adminHost = (window.location && window.location.hostname) || "localhost";
    let adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);

    async function loadRuntimePorts() {
        try {
            const res = await fetch("/runtime-ports.json", { cache: "no-store" });
            if (res.ok) {
                const data = await res.json();
                if (data && data.ADMIN_API_PORT) {
                    DEFAULT_ADMIN_API_PORT = String(data.ADMIN_API_PORT);
                    adminApiBase = buildBaseUrl(adminHost, DEFAULT_ADMIN_API_PORT);
                }
            }
        } catch (e) {
            // ignore
        }
    }

    function buildBaseUrl(host, port) {
        const proto = (window.location && window.location.protocol === "https:") ? "https:" : "http:";
        const cleaned = (host || "").replace(/^https?:\/\//, "").replace(/\/+$/, "");
        return `${proto}//${cleaned}${port ? `:${port}` : ""}`;
    }

    function extractHostFromValue(val) {
        if (!val) return "";
        try {
            const u = val.startsWith("http") ? new URL(val) : new URL(`http://${val}`);
            return u.hostname || "";
        } catch (e) {
            return "";
        }
    }

    function setAdminHost(candidateHost) {
        // Do not override adminApiBase; keep using the page host for API calls
        return;
    }

    function resolveApi(path) {
        if (!path.startsWith("/")) path = `/${path}`;
        return `${adminApiBase}${path}`;
    }

    async function detectAdminApiBase() {
        const tried = new Set();
        let apiHostOverride = null;
        let apiPortOverride = null;
        try {
            const u = new URL(window.location.href);
            apiHostOverride = u.searchParams.get("api_host") || null;
            apiPortOverride = u.searchParams.get("api_port") || null;
        } catch (e) {}
        if (apiPortOverride) {
            adminApiBase = buildBaseUrl(apiHostOverride || adminHost, apiPortOverride);
            return;
        }
        const candidatePorts = [DEFAULT_ADMIN_API_PORT].filter(Boolean);
        for (const port of candidatePorts) {
            const base = buildBaseUrl(apiHostOverride || adminHost, port);
            if (tried.has(base)) continue;
            tried.add(base);
            try {
                const res = await fetch(`${base}/api/ping`, { cache: "no-store" });
                if (res.ok) {
                    adminApiBase = base;
                    return;
                }
            } catch (e) {
                continue;
            }
        }
    }

    function showResultModal(title, body) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) modalBody.textContent = body || "";
        if (modal) modal.style.display = "flex";
    }

    function resetModal(title, body) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) modalBody.textContent = body || "";
        setModalCloseEnabled(false);
        if (modal) modal.style.display = "flex";
    }

    function appendModalLine(text) {
        const modalBody = document.getElementById("modalBody");
        if (!modalBody) return;
        const current = modalBody.textContent || "";
        modalBody.textContent = current ? `${current}\n${text}` : text;
    }

    function setModalCloseEnabled(enabled) {
        const btn = document.getElementById("modalCloseBtn");
        if (!btn) return;
        btn.disabled = !enabled;
        if (enabled) {
            btn.removeAttribute("disabled");
        } else {
            btn.setAttribute("disabled", "disabled");
        }
    }

    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.style.display = "none";
        window.location.href = "index.html";
    }

let pendingEditService = null;
let cachedProviderForm = null;
let cachedServiceChoice = null;
let servicesLoaded = false;
let servicesCatalog = [];
let editingExisting = false;
let noncePrimed = false;
let nonceLockedFromEdit = false;
let sentinelServices = [];
let adminPasswordEnabled = false;
let adminSessionAuthed = false;
function requirePasswordGate() {
    sessionStorage.removeItem("adminAuthed");
    adminSessionAuthed = false;
    const gate = document.getElementById("adminPasswordGate");
    if (gate) gate.classList.remove("hidden");
}
const realFetch = window.fetch.bind(window);
window.fetch = (url, options = {}) =>
    realFetch(url, { credentials: "include", ...options }).then((resp) => {
        if (resp && resp.status === 401) {
            requirePasswordGate();
        }
        return resp;
    });

    function setBondAmountForMode() {
        const input = document.getElementById("bondAmountInput");
        if (!input) return;
        // Default new provider to 100000000; edits to 1; respect user-entered value.
        if (!input.value) input.value = editingExisting ? "1" : "100000000";
    }

    function formatBondDisplay(val) {
        if (!val) return "–";
        const trimmed = String(val).trim();
        if (!trimmed) return "–";
        // If it already ends with uarkeo (case-insensitive), keep it; otherwise append for display.
        if (trimmed.toLowerCase().endsWith("uarkeo")) return trimmed;
        return `${trimmed}uarkeo`;
    }

    function parseBondAmountUnits(val) {
        if (!val) return NaN;
        const m = String(val).trim().match(/^([+-]?\d+)/);
        if (!m) return NaN;
        return Number(m[1]);
    }

    function showSavingOverlay(show) {
        // Overlay removed; keep function no-op for compatibility.
        return;
    }

    function normalizeSentinelUri(uri) {
        if (!uri) return "";
        let cleaned = String(uri).trim();
        // If it already ends with /metadata.json (case-insensitive), keep it.
        if (/\/metadata\.json$/i.test(cleaned)) return cleaned;
        cleaned = cleaned.replace(/\/+$/, "");
        return `${cleaned}/metadata.json`;
    }

    function setSentinelUriDisplay(val) {
        const normalized = normalizeSentinelUri(val || "");
        const hidden = document.getElementById("sentinelUri");
        const label = document.getElementById("sentinelUriDisplay");
        if (hidden) hidden.value = normalized;
        if (label) label.textContent = normalized || "(not set)";
    }

    document.addEventListener("click", (e) => {
        const menu = document.getElementById("bondServiceMenu");
        const dd = document.getElementById("bondServiceDropdown");
        if (!menu || !dd) return;
        if (!dd.contains(e.target) && !menu.contains(e.target)) {
            menu.classList.add("hidden");
        }
    });

    function pullPendingEdit() {
        try {
            const raw = localStorage.getItem("providerServiceEdit");
            if (raw) {
                pendingEditService = JSON.parse(raw);
                editingExisting = true;
                localStorage.removeItem("providerServiceEdit");
            } else {
                editingExisting = false;
            }
        } catch (e) {
            console.warn("Failed to read cached service edit", e);
            editingExisting = false;
        }
        setBondAmountForMode();
    }

    async function loadServices() {
        const select = document.getElementById("bondService");
        const search = document.getElementById("bondServiceSearchInput");
        if (search) search.value = "";
        select.innerHTML = '<option value="">Loading services...</option>';
        try {
            const res = await fetch(resolveApi("/api/services"));
            const data = await res.json();
            setPre("servicesDebug", "");
            if (!res.ok) {
                select.innerHTML = '<option value="">Error loading services</option>';
                setPre("bondResult", "Error: " + JSON.stringify(data, null, 2));
                setPre("servicesDebug", "Debug services response:\n" + JSON.stringify(data, null, 2));
                return;
            }
            const services = data.services || [];
            servicesCatalog = services;
            if (!services.length) {
                select.innerHTML = '<option value="">No services found</option>';
                setPre("servicesDebug", "Debug services response:\n" + JSON.stringify(data, null, 2));
                return;
            }
            select.innerHTML = '<option value="">Select a service</option>';
            const sorted = services.slice().sort((a, b) => {
                const da = (a.description || "").toLowerCase();
                const db = (b.description || "").toLowerCase();
                if (da && db && da !== db) return da.localeCompare(db);
                const na = (a.name || "").toLowerCase();
                const nb = (b.name || "").toLowerCase();
                if (na && nb && na !== nb) return na.localeCompare(nb);
                const ia = String(a.id ?? "");
                const ib = String(b.id ?? "");
                return ia.localeCompare(ib);
            });
            for (const svc of sorted) {
                const id = svc.id ?? "";
                const name = svc.name ?? "";
                const desc = svc.description ?? "";
                if (!id && !name) continue;
                const opt = document.createElement("option");
                // Use the service name as the value; fall back to id only if name missing
                opt.value = name || id;
                opt.dataset.id = id;
                const label = name ? `${name} (${id})` : id;
                const extra = desc ? `${desc} (${name || id} : ${id})` : label;
                opt.textContent = desc ? extra : label;
                select.appendChild(opt);
            }
            setPre("servicesDebug", "");
            servicesLoaded = true;
            renderBondServiceOptions(sorted);
            applyPendingEdit();
            applyCachedProviderForm();
        } catch (e) {
            select.innerHTML = '<option value="">Failed to load services</option>';
            setPre("bondResult", "Request failed: " + e);
            setPre("servicesDebug", "Request failed: " + e);
        }
    }

    async function bondProvider(event) {
        event.preventDefault();
        const submitBtn = document.getElementById("bondSubmit");
        submitBtn.disabled = true;
        submitBtn.textContent = "Submitting...";
        const bondAmountInput = document.getElementById("bondAmountInput");
        const bondAmount = (bondAmountInput?.value || "").trim() || (editingExisting ? "1" : "100000000");
        if (!/^[+-]?\d+$/.test(bondAmount)) {
            alert("Bond amount must be an integer (no letters or symbols). Use positive or negative values between -1000000000 and 1000000000, excluding 0.");
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            return;
        }
        const bondUnits = parseBondAmountUnits(bondAmount);
        if (!Number.isFinite(bondUnits) || bondUnits === 0 || Math.abs(bondUnits) > 1_000_000_000) {
            alert("Bond amount must be between -1000000000 and 1000000000, and cannot be 0.");
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            return;
        }
        showResultModal("Provider Service", "Submitting bond/mod contracts...");
        // Always increment the metadata nonce immediately before submitting
        const metadataNonce = incrementMetadataNonce();
        const select = document.getElementById("bondService");
        const selectedOption = select.options[select.selectedIndex];
        const serviceId = selectedOption ? selectedOption.dataset.id || "" : "";
        const serviceName = document.getElementById("bondService").value.trim();
        const rpcUrlVal = document.getElementById("rpcUrl").value.trim();
        const rpcUserVal = document.getElementById("rpcUser").value.trim();
        const rpcPassVal = document.getElementById("rpcPass").value.trim();
        const locationSelect = document.getElementById("locationSelect");
        const locationVal = (locationSelect && locationSelect.value ? locationSelect.value : "").trim();
        const allowedLocations = locationSelect ? Array.from(locationSelect.options).map((o) => o.value) : [];
        const normalizedLoc = locationVal.toLowerCase();
        const isAllowed = !allowedLocations.length || allowedLocations.includes(locationVal);
        const finalLocation = locationVal && normalizedLoc !== "default location" && isAllowed ? locationVal : "";
        if (!locationVal) {
            alert("Please select a location.");
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            return;
        }
        const rawSentinelUri = document.getElementById("sentinelUri").value.trim();
        const sentinelUriNormalized = normalizeSentinelUri(rawSentinelUri);
        setSentinelUriDisplay(sentinelUriNormalized);
        const payload = {
            service: document.getElementById("bondService").value.trim(),
            bond: bondAmount,
            sentinel_uri: sentinelUriNormalized,
            metadata_nonce: metadataNonce,
            status: document.getElementById("status").value.trim(),
            min_contract_dur: document.getElementById("minContractDur").value.trim(),
            max_contract_dur: document.getElementById("maxContractDur").value.trim(),
            subscription_rates: document.getElementById("subscriptionRates").value.trim(),
            pay_as_you_go_rates: document.getElementById("payAsYouGoRates").value.trim(),
            settlement_dur: document.getElementById("settlementDur").value.trim(),
            location: finalLocation,
        };
        resetModal("Provider Service", "");
        appendModalLine("Submitting bond/mod contracts...");
        setModalCloseEnabled(false);
        try {
            const res = await fetch(resolveApi("/api/bond-mod-provider"), {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify(payload),
            });
            const data = await res.json();
            const resOk = res.ok;
            updateDerivedFields(data);
            if (!resOk) {
                appendModalLine("Bond contract error.");
                appendModalLine("Mod contract error.");
                appendModalLine(JSON.stringify(data, null, 2));
                appendModalLine("");
                appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                setModalCloseEnabled(true);
                return;
            }
            if (!bondAndModSucceeded(data)) {
                appendModalLine("Bond contract error.");
                appendModalLine("Mod contract error.");
                appendModalLine(JSON.stringify(data, null, 2));
                appendModalLine("");
                appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                setModalCloseEnabled(true);
                return;
            }
            appendModalLine("Bond contract success.");
            appendModalLine("Mod contract success.");
            appendModalLine("");
            // Determine service type from catalog for sentinel.yaml
            let resolvedType = payload.service;
            const catalogEntry = servicesCatalog.find(
                (s) =>
                    String(s.id ?? s.service_id ?? s.service ?? "") === String(serviceId) ||
                    s.name === payload.service ||
                    s.service === payload.service
            );
            if (catalogEntry && catalogEntry.service_type) {
                resolvedType = catalogEntry.service_type;
            }
            // Only rebuild sentinel if bond+mod succeeded (no restart here)
            try {
                appendModalLine("Updating Sentinel...");
                const rebuildRes = await fetch(resolveApi("/api/sentinel-rebuild"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        service_overrides: [
                            {
                                name: payload.service,
                                id: serviceId,
                                service: serviceName,
                                status: payload.status,
                                rpc_url: rpcUrlVal,
                                rpc_user: rpcUserVal,
                                rpc_pass: rpcPassVal,
                                type: resolvedType,
                                service_type: resolvedType,
                            },
                        ],
                    }),
                });
                const rebuildData = await rebuildRes.json();
                if (!rebuildRes.ok) {
                    appendModalLine("Sentinel update error.");
                    appendModalLine("Sentinel rebuild error.");
                    appendModalLine(JSON.stringify(rebuildData, null, 2));
                    appendModalLine("");
                    appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                    setModalCloseEnabled(true);
                    return;
                }
                appendModalLine("Sentinel update success.");
                appendModalLine("");
                appendModalLine("Rebuilding Sentinel...");
                appendModalLine("Sentinel rebuild success.");
                appendModalLine("");
            } catch (e) {
                console.warn("sentinel rebuild failed", e);
                appendModalLine("Sentinel update error.");
                appendModalLine("Sentinel rebuild error.");
                appendModalLine(String(e));
                appendModalLine("");
                appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                setModalCloseEnabled(true);
                return;
            }
            // Optional: sync sentinel.yaml with on-chain active services after a short delay (restart happens here)
            try {
                await new Promise((resolve) => setTimeout(resolve, 6500)); // ~1 block
                const syncRes = await fetch(resolveApi("/api/sentinel-sync"), { method: "POST" });
                const syncData = await syncRes.json();
                if (syncRes.ok) {
                    appendModalLine("Resyncing Sentinel...");
                    appendModalLine("Sentinel resync success.");
                    appendModalLine("");
                } else {
                    appendModalLine("Resyncing Sentinel... Error.");
                    appendModalLine(JSON.stringify(syncData, null, 2));
                    appendModalLine("");
                    appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                    setModalCloseEnabled(true);
                    return;
                }
            } catch (e) {
                appendModalLine("Resyncing Sentinel... Error.");
                appendModalLine(String(e));
                appendModalLine("");
                appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
                setModalCloseEnabled(true);
                return;
            }
            appendModalLine("Provider service and Sentinel updated successfully.");
            setModalCloseEnabled(true);
        } catch (e) {
            appendModalLine("Request failed: " + e);
            appendModalLine("");
            appendModalLine("Provider service and Sentinel errored. Check the logs for more info.");
            setModalCloseEnabled(true);
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = "Submit Bond + Mod";
            // Overlay will be hidden only if we remain on the page (errors)
        }
    }

    function incrementMetadataNonce() {
        const hidden = document.getElementById("metadataNonceHidden");
        const label = document.getElementById("metadataNonceLabel");
        const current = parseInt(hidden.value || "0", 10);
        const next = Number.isFinite(current) ? current + 1 : 1;
        hidden.value = String(next);
        if (label) label.textContent = String(next);
        return String(next);
    }

    function updateDerivedFields(data) {
        if (!data) return;
        const pubkeyLabel = document.getElementById("bech32PubkeyLabel");
        if (data.pubkey && data.pubkey.bech32) {
            pubkeyLabel.textContent = data.pubkey.bech32;
        } else if (data.pubkey_error) {
            pubkeyLabel.textContent = data.pubkey_error;
        }
        if (data.bond && !editingExisting) {
            const currentBond = document.getElementById("currentBondAmountLabel");
            if (currentBond) currentBond.textContent = formatBondDisplay(data.bond);
        }
        setBondAmountForMode();
        if (data.fees) {
            document.getElementById("bondFeesLabel").textContent = data.fees;
        }
        if (data.keyring_backend) {
            document.getElementById("bondKeyringLabel").textContent = data.keyring_backend;
        }
        if (data.user) {
            document.getElementById("walletKey").textContent = data.user;
        }
        if (data.sentinel_uri && !editingExisting) {
            setSentinelUriDisplay(data.sentinel_uri);
        }
        if (data.inputs) {
            if (data.inputs.sentinel_uri && !editingExisting) setSentinelUriDisplay(data.inputs.sentinel_uri);
            if (data.inputs.metadata_nonce && !nonceLockedFromEdit) {
                document.getElementById("metadataNonceHidden").value = data.inputs.metadata_nonce;
                document.getElementById("metadataNonceLabel").textContent = data.inputs.metadata_nonce;
            }
            if (data.inputs.status) document.getElementById("status").value = data.inputs.status;
            if (data.inputs.min_contract_dur) document.getElementById("minContractDur").value = data.inputs.min_contract_dur;
            if (data.inputs.max_contract_dur) document.getElementById("maxContractDur").value = data.inputs.max_contract_dur;
            if (data.inputs.subscription_rates) document.getElementById("subscriptionRates").value = data.inputs.subscription_rates;
            if (data.inputs.pay_as_you_go_rates) document.getElementById("payAsYouGoRates").value = data.inputs.pay_as_you_go_rates;
            if (data.inputs.settlement_dur) document.getElementById("settlementDur").value = data.inputs.settlement_dur;
        }
        applyPendingEdit();
        applyCachedProviderForm();
        // Write blockchain-derived provider info to debug field
        setPre("bondResult", JSON.stringify(data, null, 2));
    }

    async function loadProviderInfo() {
        try {
            const [res, settingsRes] = await Promise.all([
                fetch(resolveApi("/api/provider-info")),
                fetch(resolveApi("/api/provider-settings"), { cache: "no-store" }),
            ]);
            const data = await res.json();
            const settingsJson = settingsRes.ok ? await settingsRes.json() : {};
            const settings = (settingsJson && settingsJson.settings) || settingsJson || {};
            if (!res.ok) {
                setPre("bondResult", "Error loading provider info: " + JSON.stringify(data, null, 2));
                return;
            }
            cachedProviderForm = (data.provider_export && data.provider_export.provider_form) || null;
            if (cachedProviderForm && cachedProviderForm.service) {
                cachedServiceChoice = cachedProviderForm.service;
            }
            updateDerivedFields(data);
            if (data.fees) document.getElementById("bondFeesLabel").textContent = data.fees;
            if (data.keyring_backend) document.getElementById("bondKeyringLabel").textContent = data.keyring_backend;
            if (data.user) document.getElementById("walletKey").textContent = data.user;
            if (data.pubkey_error) setPre("bondResult", data.pubkey_error);
            if (data.metadata_nonce && !nonceLockedFromEdit) {
                document.getElementById("metadataNonceHidden").value = data.metadata_nonce;
                document.getElementById("metadataNonceLabel").textContent = data.metadata_nonce;
            }
            // Always populate Sentinel URI from provider settings (SENTINEL_NODE:SENTINEL_PORT) and normalize
            const baseNode = (settings.SENTINEL_NODE || "").replace(/\/+$/, "");
            const port = settings.SENTINEL_PORT || "";
            let sentinelFromSettings = baseNode;
            if (sentinelFromSettings && port) {
                sentinelFromSettings = `${sentinelFromSettings}:${port}`;
            }
            const normalizedFromSettings = normalizeSentinelUri(sentinelFromSettings);
            if (normalizedFromSettings) {
                setSentinelUriDisplay(normalizedFromSettings);
                setAdminHost(normalizedFromSettings);
            } else if (data.sentinel_uri) {
                const normalized = normalizeSentinelUri(data.sentinel_uri);
                setSentinelUriDisplay(normalized);
                setAdminHost(normalized);
            }
        // Prefill location from export/env if available
        const envMeta = (data.provider_metadata) || {};
        const formLocation =
            (cachedProviderForm && cachedProviderForm.location) ||
            envMeta.LOCATION ||
            envMeta.location ||
            "";
        const locSel = document.getElementById("locationSelect");
        if (locSel) {
            const exists = Array.from(locSel.options).some((o) => o.value === formLocation);
            // If location missing or not in the allowed list, force placeholder.
            if (!formLocation || !exists) {
                locSel.selectedIndex = 0;
            } else {
                locSel.value = formLocation;
            }
        }
        applyPendingEdit();
        applyCachedProviderForm();
    } catch (e) {
        setPre("bondResult", "Request failed: " + e);
    }
    }

    async function loadSentinelConfig() {
        try {
            const res = await fetch(resolveApi("/api/sentinel-config"));
            const data = await res.json();
            if (res.ok && data && data.config && Array.isArray(data.config.services)) {
                sentinelServices = data.config.services;
            }
            applyPendingEdit();
        } catch (e) {
            console.warn("Failed to load sentinel config", e);
        }
    }

    function setPre(_id, _text) {
        // Deprecated: debug div removed; use modal for messages.
        return;
    }

    function setSelectFromCandidates(select, candidates) {
        if (!select || !Array.isArray(candidates)) return false;
        for (const cand of candidates) {
            if (!cand) continue;
            const val = String(cand);
            for (const opt of select.options) {
                const txt = opt.text || "";
                const normalizedText = txt.toLowerCase();
                const normalizedVal = val.toLowerCase();
                const dataId = (opt.dataset && opt.dataset.id) ? opt.dataset.id.toLowerCase() : "";
                if (
                    opt.value.toLowerCase() === normalizedVal ||
                    dataId === normalizedVal ||
                    normalizedText === normalizedVal ||
                    normalizedText.includes(`(${normalizedVal} :`) ||
                    normalizedText.includes(`(${normalizedVal}:`) ||
                    normalizedText.includes(`(${normalizedVal})`)
                ) {
                    select.value = opt.value;
                    return true;
                }
            }
        }
        return false;
    }

    function renderBondServiceOptions(sorted) {
        const menu = document.getElementById("bondServiceOptions");
        const select = document.getElementById("bondService");
        if (!menu || !select) return;
        menu.innerHTML = "";
        for (const svc of sorted) {
            const id = svc.id ?? "";
            const name = svc.name ?? "";
            const desc = svc.description ?? "";
            if (!id && !name) continue;
            const opt = document.createElement("div");
            opt.className = "combo-option";
            opt.dataset.value = name || id;
            opt.dataset.id = id;
            const label = name ? `${name} (${id})` : id;
            opt.textContent = desc ? `${desc} (${name || id} : ${id})` : label;
            opt.onclick = () => {
                select.value = opt.dataset.value;
                updateBondServiceDisplay(opt.textContent || opt.dataset.value || "Select a service");
                closeBondServiceMenu();
            };
            menu.appendChild(opt);
        }
        updateBondServiceDisplay();
    }

    function filterBondServiceOptions() {
        const search = document.getElementById("bondServiceSearchInput");
        const menu = document.getElementById("bondServiceOptions");
        if (!menu) return;
        const q = (search && search.value ? search.value : "").trim().toLowerCase();
        for (const opt of Array.from(menu.children)) {
            const txt = (opt.textContent || "").toLowerCase();
            opt.style.display = q && !txt.includes(q) ? "none" : "block";
        }
    }

    function updateBondServiceDisplay(forceLabel) {
        const display = document.getElementById("bondServiceSelected");
        const select = document.getElementById("bondService");
        if (!display || !select) return;
        if (forceLabel) {
            display.textContent = forceLabel;
            return;
        }
        const opt = select.selectedIndex >= 0 ? select.options[select.selectedIndex] : null;
        display.textContent = (opt && opt.textContent) || "Select a service";
    }

    function toggleBondServiceMenu(evt) {
        evt?.stopPropagation();
        const menu = document.getElementById("bondServiceMenu");
        if (!menu) return;
        const isHidden = menu.classList.contains("hidden");
        document.querySelectorAll(".combo-menu").forEach((el) => el.classList.add("hidden"));
        if (isHidden) {
            menu.classList.remove("hidden");
            const search = document.getElementById("bondServiceSearchInput");
            if (search) search.focus();
        }
    }

    function closeBondServiceMenu() {
        const menu = document.getElementById("bondServiceMenu");
        if (menu) menu.classList.add("hidden");
    }

    function applyPendingEdit() {
        if (!pendingEditService) return;
        if (!servicesLoaded) {
            const select = document.getElementById("bondService");
            if (select) select.selectedIndex = 0;
            return;
        }
        const search = document.getElementById("bondServiceSearchInput");
        if (search) search.value = "";
        const svc = pendingEditService;
        const select = document.getElementById("bondService");
        const svcId =
            svc.id ??
            svc.service_id ??
            svc.serviceID ??
            (typeof svc.service === "number" || typeof svc.service === "string" ? svc.service : null);
        let resolvedName = svc.name || svc.service || svc.label || "";
        if (!resolvedName && servicesCatalog && svcId !== undefined && svcId !== null) {
            const found = servicesCatalog.find(
                (s) => s && String(s.id ?? "") === String(svcId)
            );
            if (found && found.name) {
                resolvedName = found.name;
            }
        }
        const candidates = [
            resolvedName,
            svc.name,
            svc.service,
            svc.label,
            svcId,
        ].filter(Boolean).map(String);
        setSelectFromCandidates(select, candidates);
        updateBondServiceDisplay();

        if (svc.status !== undefined && svc.status !== null) {
            const rawStatus = String(svc.status).toLowerCase();
            const statusVal = rawStatus === "online" || rawStatus === "active" || rawStatus === "1" ? "1" : "0";
            document.getElementById("status").value = statusVal;
        }
        if (svc.min_contract_dur) document.getElementById("minContractDur").value = svc.min_contract_dur;
        if (svc.max_contract_dur) document.getElementById("maxContractDur").value = svc.max_contract_dur;
        if (svc.subscription_rates) document.getElementById("subscriptionRates").value = svc.subscription_rates;
        if (svc.pay_as_you_go_rates) document.getElementById("payAsYouGoRates").value = svc.pay_as_you_go_rates;
        if (svc.settlement_dur) document.getElementById("settlementDur").value = svc.settlement_dur;
        if (svc.bond !== undefined) {
            const currentBond = document.getElementById("currentBondAmountLabel");
            if (currentBond) currentBond.textContent = formatBondDisplay(svc.bond);
        }
        if (svc.metadata_uri) setSentinelUriDisplay(normalizeSentinelUri(svc.metadata_uri));
        if (svc.metadata_nonce) {
            document.getElementById("metadataNonceHidden").value = svc.metadata_nonce;
            document.getElementById("metadataNonceLabel").textContent = svc.metadata_nonce;
            noncePrimed = true;
            nonceLockedFromEdit = true;
        }
        // Fill RPC creds from sentinel.yaml if present
        if (sentinelServices && sentinelServices.length) {
            const match = sentinelServices.find((s) => {
                if (!s) return false;
                const sid = String(s.id ?? "");
                const sname = String(s.name ?? s.service ?? "");
                if (svcId !== undefined && svcId !== null && String(svcId) === sid) return true;
                if (resolvedName && resolvedName === sname) return true;
                return false;
            });
                if (match) {
                    if (match.rpc_url) document.getElementById("rpcUrl").value = match.rpc_url;
                    if (match.rpc_user !== undefined) document.getElementById("rpcUser").value = match.rpc_user;
                    if (match.rpc_pass !== undefined) document.getElementById("rpcPass").value = match.rpc_pass;
                }
        }
        setBondAmountForMode();
        pendingEditService = null;
    }

    function applyCachedProviderForm() {
        // If editing an existing service, keep the select as chosen by applyPendingEdit.
        if (editingExisting) return;
        if (!cachedProviderForm) {
            const select = document.getElementById("bondService");
            const search = document.getElementById("bondServiceSearchInput");
            if (search) search.value = "";
            if (select) select.selectedIndex = 0;
            updateBondServiceDisplay();
            return;
        }
        const cf = cachedProviderForm;
        const setVal = (id, val) => {
            const el = document.getElementById(id);
            if (!el) return;
            if (id === "sentinelUri") {
                setSentinelUriDisplay(val);
                return;
            }
            if (el.value === "" || el.value === el.placeholder) {
                el.value = val;
            }
        };
        if (cf.sentinel_uri) setVal("sentinelUri", normalizeSentinelUri(cf.sentinel_uri));
        if (cf.status) setVal("status", cf.status);
        if (cf.min_contract_dur) setVal("minContractDur", cf.min_contract_dur);
        if (cf.max_contract_dur) setVal("maxContractDur", cf.max_contract_dur);
        if (cf.subscription_rates) setVal("subscriptionRates", cf.subscription_rates);
        if (cf.pay_as_you_go_rates) setVal("payAsYouGoRates", cf.pay_as_you_go_rates);
        if (cf.settlement_dur) setVal("settlementDur", cf.settlement_dur);
        if (cf.location) {
            const locSel = document.getElementById("locationSelect");
            if (locSel) {
                const exists = Array.from(locSel.options).some((o) => o.value === cf.location);
                if (!exists) {
                    const opt = document.createElement("option");
                    opt.value = cf.location;
                    opt.textContent = cf.location;
                    locSel.appendChild(opt);
                }
                locSel.value = cf.location;
            }
        }
        if (cf.rpc_url) setVal("rpcUrl", cf.rpc_url);
        if (cf.rpc_user) setVal("rpcUser", cf.rpc_user);
        if (cf.rpc_pass) setVal("rpcPass", cf.rpc_pass);
        // Always default to placeholder for new form; do not auto-select service from cached form.
        const select = document.getElementById("bondService");
        if (select) select.selectedIndex = 0;
    }

    function txSucceeded(tx) {
        if (!tx) return false;
        if (tx.exit_code !== 0) return false;
        if (typeof tx.output === "string") {
            const m = tx.output.match(/code:\s*(\d+)/);
            if (m && m[1] && m[1] !== "0") return false;
        }
        return true;
    }

    function bondAndModSucceeded(data) {
        return txSucceeded(data?.bond_tx) && txSucceeded(data?.mod_tx);
    }

    async function fetchAdminPasswordStatus(showGate = true) {
        try {
            const res = await fetch(resolveApi("/api/session"), { cache: "no-store" });
            const data = await res.json();
            adminPasswordEnabled = !!(data && data.enabled);
            adminSessionAuthed = !!(data && data.authed);
        } catch (e) {
            adminPasswordEnabled = false;
            adminSessionAuthed = false;
        }
        if (adminPasswordEnabled && !adminSessionAuthed) {
            sessionStorage.removeItem("adminAuthed");
        }
        const gateAuthed = sessionStorage.getItem("adminAuthed") === "1" || adminSessionAuthed;
        const gate = document.getElementById("adminPasswordGate");
        if (gate) {
            if (showGate && adminPasswordEnabled && !gateAuthed) {
                gate.classList.remove("hidden");
            } else {
                gate.classList.add("hidden");
            }
        }
    }

    async function submitAdminPasswordGate(event) {
        if (event && event.preventDefault) event.preventDefault();
        const input = document.getElementById("adminPasswordGateInput");
        const statusEl = document.getElementById("adminPasswordGateStatus");
        const pwd = (input && input.value) || "";
        if (statusEl) statusEl.textContent = "Verifying...";
        try {
            const res = await fetch(resolveApi("/api/login"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ password: pwd }),
            });
            const data = await res.json();
            if (data && data.ok) {
                sessionStorage.setItem("adminAuthed", "1");
                adminSessionAuthed = true;
                const gate = document.getElementById("adminPasswordGate");
                if (gate) gate.classList.add("hidden");
                if (statusEl) statusEl.textContent = "";
                window.location.href = "index.html";
            } else if (statusEl) {
                statusEl.textContent = "Incorrect password.";
            }
        } catch (e) {
            if (statusEl) statusEl.textContent = `Failed to verify: ${e}`;
        }
    }

    window.addEventListener("load", async () => {
        await loadRuntimePorts();
        await detectAdminApiBase();
        fetchAdminPasswordStatus(true);
        pullPendingEdit();
        loadServices();
        loadProviderInfo();
        loadSentinelConfig();
    });
</script>

<div id="adminPasswordGate" class="overlay overlay-strong hidden">
    <div class="overlay-card password-card">
        <div class="password-title">
            <span>Arkeo Data Marketplace</span>
            <span class="sep">|</span>
            <span class="sub">Provider Manager</span>
        </div>
        <form onsubmit="submitAdminPasswordGate(event); return false;">
            <div class="password-body">
                <h3 class="mt-6 mb-0">Password Required</h3>
                <p class="muted">Enter the admin password to continue.</p>
                <input type="text" name="admin-username-filler" autocomplete="username" value="admin" class="hidden" aria-hidden="true" tabindex="-1" />
                <input type="password" id="adminPasswordGateInput" autocomplete="current-password" placeholder="Admin password" />
            </div>
            <div class="actions center mt-6">
                <button class="primary" type="submit">Unlock</button>
            </div>
            <div id="adminPasswordGateStatus" class="muted mt-6"></div>
        </form>
    </div>
</div>

</body>
</html>
