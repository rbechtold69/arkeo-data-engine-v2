<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Marketplace | Provider Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>

<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Subscriber Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
            <div class="header-right">
                <div class="header-line" id="headerPubkey">
                    <strong>Subscriber Pubkey:</strong>
                    <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerAddress">
                <strong>Subscriber Address:</strong>
                <span class="inline">
                    <span id="headerAddressValue"></span>
                    <button class="copy-btn" onclick="copyAddressFromHeader()">Copy</button>
                </span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Subscriber Balance:</strong></div>
            <div class="header-line muted" id="headerBlock"><strong>Current Block:</strong></div>
            <div class="header-line fixed-pill"><span id="syncPill" class="status-badge status-warn hidden">Syncing...</span></div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Arkeo Data Marketplace</h2>
    <div class="metrics-grid header-metrics">
        <div class="metric-card">
            <div class="metric-label">Active Providers</div>
            <div class="metric-value" id="metricProviders">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Active Services</div>
            <div class="metric-value" id="metricServices">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Contracts</div>
            <div class="metric-value" id="metricContracts">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Subscribers</div>
            <div class="metric-value" id="metricSubscribers">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Supported Chains</div>
            <div class="metric-value" id="metricNodeTypes">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-value"><button class="primary block-btn" id="cacheRefreshBtn" onclick="refreshCache()">Refresh</button></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="row-between row-align-end">
        <div>
            <h2>Arkeo Subscriber Listeners</h2>
        </div>
        <div class="text-right">
            <div class="muted" id="listenerRange">Ports 62001-62100</div>
            <div class="muted small">Next available port: <span id="nextPortValue">–</span></div>
        </div>
    </div>
    <form id="listenerForm" class="listener-form" onsubmit="submitListenerForm(event)">
        <div class="listener-grid">
            <label>
                <div class="muted">Status</div>
                <select id="listenerStatus" class="select">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                </select>
                <div class="muted small">Active = serve, inactive = paused.</div>
            </label>
            <label>
                <div class="muted">Service Type</div>
                <select id="listenerService" class="select"></select>
                <div class="muted small">Choose an active service to bind.</div>
            </label>
            <label>
                <div class="muted">Whitelist IPs</div>
                <input id="listenerWhitelist" type="text" class="input" placeholder="0.0.0.0" />
                <div class="muted small">Empty = allow all, comma separated.</div>
            </label>
            <div class="listener-actions" style="align-self:flex-end;">
                <button type="submit" class="primary">Add Listener</button>
            </div>
        </div>
    </form>
    <div id="listenersTable" class="mt-2"></div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <pre id="modalBody"></pre>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<script>
    let currentPubkey = "";
    let currentAddress = "";

    function formatPubkeyShort(pubkey) {
        if (!pubkey || pubkey.length < 12) return pubkey || "";
        // Show first 10 and last 8 for a bit more context
        return `${pubkey.slice(0, 9)}...${pubkey.slice(-8)}`;
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "0.00000000 uarkeo";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ${denom}`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(resp) {
        if (!resp || resp.error || !resp.height) return "(unavailable)";
        return resp.height.toString();
    }

    const API_PORT_DEFAULT = 9998;
    const apiPort = new URLSearchParams(window.location.search).get("api_port") || window.API_PORT || API_PORT_DEFAULT;
    const API_BASE = `${window.location.protocol}//${window.location.hostname}${apiPort ? ":" + apiPort : ""}`;
    const apiUrl = (path) => `${API_BASE}${path}`;

    function escapeHtml(str) {
        if (str === undefined || str === null) return "";
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    async function refreshHeader() {
        const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
        const parseSafe = async (settled) => {
            if (!settled || settled.status !== "fulfilled") return { error: "request failed" };
            try {
                if (!settled.value.ok) return { error: `${settled.value.status}` };
                return await settled.value.json();
            } catch (err) {
                return { error: String(err) };
            }
        };
            const [infoRes, balRes, heightRes] = await Promise.allSettled([
            fetchNoStore(apiUrl("/api/subscriber-info")),
            fetchNoStore(apiUrl("/api/balance")),
            fetchNoStore(apiUrl("/api/block-height")),
        ]);
        const info = await parseSafe(infoRes);
        const bal = await parseSafe(balRes);
        const height = await parseSafe(heightRes);

        const moniker = (info && info.subscriber_name) ||
            (info && info.provider_metadata && (info.provider_metadata.MONIKER || info.provider_metadata.PROVIDER_NAME)) || "";
        const desc = "";
        const bechPub = info && info.pubkey && info.pubkey.bech32;
        currentPubkey = bechPub || "";
        currentAddress = (info && info.address) || "";

        const headerMonikerEl = document.getElementById("headerMoniker");
        const headerDescEl = document.getElementById("headerDescription");
        const headerPubVal = document.getElementById("headerPubkeyValue");
        const headerAddrEl = document.getElementById("headerAddress");
        const headerBalEl = document.getElementById("headerBalance");
        const headerBlockEl = document.getElementById("headerBlock");

        if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
        if (headerDescEl) headerDescEl.textContent = desc || "";
        if (headerPubVal) headerPubVal.textContent = bechPub ? formatPubkeyShort(bechPub) : "(unavailable)";
        if (headerAddrEl) {
            const addrVal = currentAddress || "(unavailable)";
            const addrSpan = document.getElementById("headerAddressValue");
            if (addrSpan) addrSpan.textContent = formatAddressShort(addrVal);
        }
        if (headerBalEl) headerBalEl.innerHTML = `<strong>Subscriber Balance:</strong> ${formatBalance(bal)}`;
        if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${formatBlockHeight(height)}`;

    }

    async function copyPubkeyFromHeader() {
        const val = currentPubkey || document.getElementById("headerPubkeyValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Pubkey", "Pubkey unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Pubkey";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            // fallback for non-HTTPS contexts
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Pubkey copied (fallback):\n${val}`);
            } else {
                showResultModal(
                    msgTitle,
                    `Failed to copy. Clipboard access may require HTTPS. Here is the value:\n${val}`
                );
            }
        }
    }

    async function copyAddressFromHeader() {
        const val = currentAddress || document.getElementById("headerAddressValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Address", "Subscriber address unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Address";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Address copied (fallback):\n${val}`);
            } else {
                showResultModal(
                    msgTitle,
                    `Failed to copy. Clipboard access may require HTTPS. Here is the value:\n${val}`
                );
            }
        }
    }

    async function refreshCache() {
        const statusEl = document.getElementById("cacheStatus");
        const btn = document.getElementById("cacheRefreshBtn");
        const startMsg = `Starting cache refresh at ${new Date().toISOString()}...\n` +
            [
                "Providers: syncing...",
                "Contracts: syncing...",
                "Services: syncing...",
                "Active Providers: deriving...",
                "Active Services: deriving...",
                "Subscribers: deriving..."
            ].join("\n");
        if (statusEl) statusEl.textContent = "Refreshing cache...";
        if (btn) btn.disabled = true;
        // keep syncing state across full refresh flow to avoid flicker
        setSyncingLocal(true);
        showResultModal("Cache Refresh", startMsg);
        try {
            const res = await fetch(apiUrl("/api/cache-refresh"), { method: "POST" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                const detail = (data && (data.detail || data.error)) || `${res.status}`;
                throw new Error(detail);
            }
            const results = (data && data.results) || {};
            const summarize = (key, payload) => {
                const tryParse = (val) => {
                    if (typeof val === "string") {
                        try { return JSON.parse(val); } catch (e) { return null; }
                    }
                    return val;
                };
                const pickList = (obj, candidates) => {
                    for (const c of candidates) {
                        const v = c && typeof c === "string" ? obj[c] : obj?.[c];
                        const parsed = tryParse(v);
                        if (Array.isArray(parsed)) return parsed;
                    }
                    return [];
                };
                if (!payload || typeof payload !== "object") return `${key}: (no data)`;
                let d = payload.data ?? payload;
                d = tryParse(d) ?? {};
                let items = [];
                if (Array.isArray(d)) {
                    items = d;
                } else if (typeof d === "object") {
                    if (key === "provider-services" || key === "providers" || key === "active_providers") {
                        items = pickList(d, ["providers", "provider", "result"]);
                    } else if (key === "provider-contracts" || key === "contracts") {
                        items = pickList(d, ["contracts", "contract", "result"]);
                    } else if (key === "active_services") {
                        items = pickList(d, ["active_services"]);
                    } else if (key === "service-types" || key === "services") {
                        // handle nested under data as well
                        items = pickList(d, ["services", "service", "result"]);
                        if (!items.length && d.data) {
                            items = pickList(d.data, ["services", "service", "result"]);
                        }
                    } else if (key === "subscribers") {
                        items = pickList(d, ["subscribers"]);
                    } else {
                        items = [];
                    }
                }
                const count = Array.isArray(items) ? items.length : 0;
                return `${key}: ${count || "(no data)"}`;
            };
            const orderedKeys = ["provider-services","provider-contracts","service-types","active_providers","active_services","subscribers"];
            const summary = orderedKeys.filter(k => k in results).map(k => summarize(k, results[k])).join("\n");
            const finishedMsg = `Finished cache refresh at ${new Date().toISOString()}\n${summary || "(no results)"}`;
            if (statusEl) statusEl.textContent = `Last refresh: ${new Date().toLocaleString()}`;
            updateModalBody(finishedMsg);
            // refresh header and listeners after cache refresh
            await refreshHeader();
            await loadListeners();
            // update metrics
            updateMetrics(results);
        } catch (err) {
            if (statusEl) statusEl.textContent = `Cache refresh failed: ${err}`;
            updateModalBody(`Failed to refresh cache:\n${err}`);
        } finally {
            if (btn) btn.disabled = false;
            setSyncingLocal(false);
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        refreshHeader();
        // Refresh every 10 seconds to mirror provider UI behavior
        setInterval(refreshHeader, 10000);
        loadListeners();
        refreshServiceTypes(false);
        // try to populate metrics from initial cache-refresh data if present
        updateMetrics();
        // poll cache status to reflect background sync
        pollSyncStatus();
        setInterval(pollSyncStatus, 5000);
        // kick off a cache refresh on load
        refreshCache();
    });

    function showResultModal(title, body, asHtml = false) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) {
            if (asHtml) {
                modalBody.innerHTML = body || "";
            } else {
                modalBody.textContent = body || "";
            }
        }
        if (modal) modal.classList.remove("hidden");
    }

    function updateModalBody(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.textContent = body || "";
    }

    let syncingLocal = false;
    let syncingRemote = false;
    function updateSyncUI() {
        const pill = document.getElementById("syncPill");
        const btn = document.getElementById("cacheRefreshBtn");
        const isSyncing = syncingLocal || syncingRemote;
        if (pill) pill.classList[isSyncing ? "remove" : "add"]("hidden");
        if (btn) btn.disabled = isSyncing;
    }
    function setSyncingLocal(active) {
        syncingLocal = !!active;
        updateSyncUI();
    }
    function setSyncingRemote(active) {
        syncingRemote = !!active;
        updateSyncUI();
    }
    async function pollSyncStatus() {
        try {
            const statusRes = await fetch(apiUrl("/api/cache-status"), { cache: "no-store" });
            let wasSyncing = syncingRemote;
            if (statusRes.ok) {
                const data = await statusRes.json();
                const inProg = data && (data.in_progress === true || data.in_progress === "true");
                setSyncingRemote(!!inProg);
                // If a sync just finished, refresh service types to update dropdowns without a full reload
                if (wasSyncing && !inProg) {
                    refreshServiceTypes(true);
                }
            }
            const countsRes = await fetch(apiUrl("/api/cache-counts"), { cache: "no-store" });
            if (countsRes.ok) {
                const counts = await countsRes.json();
                // Update only the active providers, active services, and contracts counts to avoid jumping the UI
                updateMetrics(null, {
                    providers: counts.active_providers,
                    services: counts.active_services,
                    contracts: counts.contracts,
                    subscribers: counts.subscribers,
                    nodeTypes: counts.supported_chains,
                });
            }
        } catch (e) {
            // keep previous remote state on error
        }
    }

    function serviceIsActiveStatus(statusVal) {
        if (statusVal === undefined || statusVal === null) return true;
        if (typeof statusVal === "boolean") return !!statusVal;
        const s = String(statusVal).trim().toLowerCase();
        if (!s) return true;
        return ["1", "active", "online", "true", "on", "up", "running"].includes(s);
    }

    function countActiveServicesFromProviderServices(payload) {
        if (!payload || typeof payload !== "object") return null;
        const d = payload.data || payload;
        let providers = [];
        if (Array.isArray(d.providers)) providers = d.providers;
        else if (Array.isArray(d.provider)) providers = d.provider;
        let count = 0;
        for (const p of providers) {
            if (!p || typeof p !== "object") continue;
            const svcs = Array.isArray(p.services) ? p.services : Array.isArray(p.service) ? p.service : [];
            for (const s of svcs) {
                if (!s || typeof s !== "object") continue;
                const status = s.status !== undefined ? s.status : p.status;
                if (serviceIsActiveStatus(status)) count += 1;
            }
        }
        return count;
    }

    function updateMetrics(results, overrides) {
        const mProv = document.getElementById("metricProviders");
        const mSvc = document.getElementById("metricServices");
        const mCon = document.getElementById("metricContracts");
        const mSub = document.getElementById("metricSubscribers");
        const mNode = document.getElementById("metricNodeTypes");
        const getCount = (payload, keys) => {
            if (!payload || typeof payload !== "object") return null;
            const d = payload.data || payload;
            for (const k of keys) {
                const v = d[k];
                if (Array.isArray(v)) return v.length;
            }
            return null;
        };
        let activeSvcCount = null;
        if (results) {
            if ("active_services" in results) {
                const d = results["active_services"].data || results["active_services"];
                if (d && Array.isArray(d.active_services)) activeSvcCount = d.active_services.length;
            }
            if (activeSvcCount === null && "provider-services" in results) {
                const c = countActiveServicesFromProviderServices(results["provider-services"]);
                if (c !== null) activeSvcCount = c;
            }
            if (mProv && "provider-services" in results) {
                const c = getCount(results["provider-services"], ["providers", "provider"]);
                if (c !== null) mProv.textContent = c;
            }
            if (mProv && "active_providers" in results) {
                const d = results["active_providers"].data || results["active_providers"];
                if (d && Array.isArray(d.providers)) {
                    mProv.textContent = d.providers.length;
                }
            }
            if (mCon && "provider-contracts" in results) {
                const c = getCount(results["provider-contracts"], ["contracts", "contract"]);
                if (c !== null) mCon.textContent = c;
            }
            if (mSub && "subscribers" in results) {
                const d = results["subscribers"].data || results["subscribers"];
                if (d && Array.isArray(d.subscribers)) mSub.textContent = d.subscribers.length;
            }
            if (mSvc && "service-types" in results) {
                const c = getCount(results["service-types"], ["services", "service", "result", "data"]);
                if (mNode && c !== null) mNode.textContent = c;
            }
            if (mProv && "providers" in results) {
                const d = results["providers"];
                if (d && d.data && Array.isArray(d.data.providers)) {
                    mProv.textContent = d.data.providers.length;
                }
            }
        }
        if (mSvc && activeSvcCount !== null) {
            mSvc.textContent = activeSvcCount;
        }
        if (overrides) {
            if (mProv && overrides.providers !== undefined) mProv.textContent = overrides.providers;
            if (mSvc && overrides.services !== undefined) mSvc.textContent = overrides.services;
            if (mCon && overrides.contracts !== undefined) mCon.textContent = overrides.contracts;
            if (mSub && overrides.subscribers !== undefined) mSub.textContent = overrides.subscribers;
            if (mNode && overrides.nodeTypes !== undefined) mNode.textContent = overrides.nodeTypes;
        }
        if (mNode) mNode.textContent = mNode.textContent || "–";
    }
    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.classList.add("hidden");
    }

    // ─────────────────────────────
    // Listener registry UI helpers
    // ─────────────────────────────
    let listenersEditingId = null;
    let listenersCache = [];
    let serviceTypesCache = [];
    let lastServiceTypesFetch = 0;

    function serviceOptionsHtml(selectedId) {
        const opts = serviceTypesCache.map((s) => {
            const sid = s && (s.service_id ?? s.serviceID ?? s.id);
            if (sid === undefined || sid === null) return "";
            const label = formatServiceLabel(sid);
            const count = s && s.count !== undefined ? ` (${s.count} Active)` : "";
            const sel = String(selectedId || "") === String(sid) ? "selected" : "";
            return `<option value="${escapeHtml(String(sid))}" ${sel}>${escapeHtml(label + count)}</option>`;
        }).filter(Boolean).join("");
        return `<option value="">Select a service</option>${opts}`;
    }

    function updateSelectOptionsFromCache(selectEl) {
        if (!selectEl) return;
        const current = selectEl.value;
        selectEl.innerHTML = serviceOptionsHtml(current);
        if (current) selectEl.value = current;
    }

    async function refreshServiceTypes(rerenderTable = false, selectIdToUpdate = null, force = false) {
        const now = Date.now();
        const freshWindowMs = 5000;
        if (!force && now - lastServiceTypesFetch < freshWindowMs) {
            if (selectIdToUpdate) updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
            if (rerenderTable && !listenersEditingId) renderListenersTable();
            return;
        }
        try {
            const res = await fetch(apiUrl("/api/active-service-types"), { cache: "no-store" });
            if (!res.ok) return;
            const svcData = await res.json().catch(() => ({}));
            const list = svcData && svcData.active_service_types;
            if (Array.isArray(list)) {
                serviceTypesCache = list;
                lastServiceTypesFetch = Date.now();
                populateServiceSelect();
                if (selectIdToUpdate) {
                    updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
                }
                if (rerenderTable && !listenersEditingId) {
                    renderListenersTable();
                }
            }
        } catch (e) {
            // ignore fetch errors; will retry on next trigger
        }
    }

    async function loadListeners() {
        try {
            const res = await fetch(apiUrl("/api/listeners"), { cache: "no-store" });
            const data = await res.json();
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersCache = Array.isArray(data.listeners) ? data.listeners : [];
            const nextPort = data.next_port || "n/a";
            const npEl = document.getElementById("nextPortValue");
            if (npEl) npEl.textContent = nextPort;
            const rangeEl = document.getElementById("listenerRange");
            if (rangeEl && Array.isArray(data.port_range) && data.port_range.length === 2) {
                rangeEl.textContent = `Ports ${data.port_range[0]}-${data.port_range[1]}`;
            }
            renderListenersTable();
            if (!serviceTypesCache.length) {
                refreshServiceTypes(true);
            }
        } catch (err) {
            renderListenersTable(`Failed to load listeners: ${err}`);
        }
    }

    function renderListenersTable(errorText) {
        const container = document.getElementById("listenersTable");
        if (!container) return;
        if (errorText) {
            container.innerHTML = `<div class="muted">${escapeHtml(errorText)}</div>`;
            return;
        }
        if (!listenersCache.length) {
            container.innerHTML = `<div class="muted">No listeners yet. Add one to auto-assign the next open port.</div>`;
            return;
        }
        const rows = listenersCache.map((l) => {
            const isEditing = listenersEditingId === String(l.id);
            const targetSafe = escapeHtml(l.target || "");
            const portSafe = escapeHtml(l.port ?? "");
            const statusSafe = escapeHtml(l.status || "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id);
            const svcSelect = buildServiceSelect(l.service_id, `editService-${l.id}`);
            const statusSelect = buildStatusSelect(l.status, `editStatus-${l.id}`);
            const topServices = Array.isArray(l.top_services) ? l.top_services : [];
            const whitelist = l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)";
            const topServicesDisplay = topServices.length
                ? topServices.map((bp, idx) => {
                    const pk = bp && bp.provider_pubkey ? formatPubkeyShort(bp.provider_pubkey) : "(unknown)";
                    const mon = bp && bp.provider_moniker;
                    const name = mon && mon !== "(Inactive)" ? mon : `${pk} (Inactive)`;
                    const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                        ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                        : "";
                    const right = [rate].filter(Boolean).join(" | ");
                    const order = `${idx + 1}`;
                    return `${order} | ${name}${right ? ` | ${right}` : ""}`;
                }).join("<br>")
                : "—";
            if (isEditing) {
                return `
                <tbody class="listener-block">
                <tr class="listener-main">
                    <td class="col-status">${statusSelect}</td>
                    <td>
                        ${svcSelect}
                    </td>
                    <td class="mono">${portSafe || "–"}</td>
                    <td class="listener-actions-cell col-actions">
                        <div class="actions align-right">
                            <button class="primary" onclick="saveListener('${l.id}')">Save</button>
                            <button onclick="cancelEditListener()">Cancel</button>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small" style="padding-bottom:4px;">Whitelist IPs:</div>
                        <input id="editWhitelist-${l.id}" class="input" value="${l.whitelist_ips ? escapeHtml(l.whitelist_ips) : ""}" placeholder="0.0.0.0" />
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small">Top services (sorted by lowest PAYG):</div>
                        <div class="muted">${topServicesDisplay}</div>
                    </td>
                </tr>
                <tr class="listener-spacer"><td colspan="4"></td></tr>
                </tbody>`;
            }
            const statusDot = `<span class="status-dot ${String(l.status).toLowerCase() === "active" ? "dot-ok" : "dot-err"}"></span>`;
            return `
            <tbody class="listener-block">
            <tr class="listener-main">
                <td class="col-status">${statusDot}</td>
                <td>${escapeHtml(svcLabel || "—")}</td>
                <td class="mono">${portSafe || "–"}</td>
                <td class="listener-actions-cell col-actions">
                    <button class="primary" onclick="testListener('${l.id}')">Test</button>
                    <button class="primary" onclick="refreshTopServices('${l.id}')">Refresh</button>
                    <button class="primary" onclick="editListener('${l.id}')">Edit</button>
                    <button class="primary danger-btn" onclick="deleteListener('${l.id}')">Delete</button>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Whitelist IPs:</div>
                    <div class="muted">${whitelist}</div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Top services:</div>
                    <div class="muted">${topServicesDisplay}</div>
                </td>
            </tr>
            <tr class="listener-spacer"><td colspan="4"></td></tr>
            </tbody>`;
        }).join("");
        container.innerHTML = `<div class="table-wrap">
            <table class="table">
                <thead>
                    <tr><th class="col-status">Status</th><th>Service Type</th><th>Port</th><th class="col-actions">Actions</th></tr>
                </thead>
                <tbody>${rows}</tbody>
            </table>
        </div>`;
    }

    function resetListenerForm() {
        const svc = document.getElementById("listenerService");
        const status = document.getElementById("listenerStatus");
        const wl = document.getElementById("listenerWhitelist");
        if (svc) svc.value = "";
        if (status) status.value = "active";
        if (wl) wl.value = "";
    }

    async function submitListenerForm(evt) {
        evt.preventDefault();
        const svcId = document.getElementById("listenerService")?.value || "";
        if (!svcId) {
            alert("Please select a service type before adding a listener.");
            return;
        }
        const status = document.getElementById("listenerStatus")?.value || "active";
        const whitelist = document.getElementById("listenerWhitelist")?.value || "";
        const body = { status, whitelist_ips: whitelist };
        if (svcId) body.service_id = svcId;
        try {
            const res = await fetch(apiUrl("/api/listeners"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            resetListenerForm();
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Add Listener", `Failed to add listener: ${err}`);
        }
    }

    function editListener(id) {
        listenersEditingId = String(id);
        renderListenersTable();
    }

    function cancelEditListener() {
        listenersEditingId = null;
        renderListenersTable();
    }

    async function saveListener(id) {
        const svcId = document.getElementById(`editService-${id}`)?.value || "";
        const status = document.getElementById(`editStatus-${id}`)?.value || "";
        const whitelist = document.getElementById(`editWhitelist-${id}`)?.value || "";
        const body = { status, whitelist_ips: whitelist };
        if (svcId) body.service_id = svcId;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Update Listener", `Failed to update listener: ${err}`);
        }
    }

    async function deleteListener(id) {
        if (!confirm("Delete this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "DELETE",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Delete Listener", `Failed to delete listener: ${err}`);
        }
    }

    async function testListener(id) {
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), {
                method: "GET",
                cache: "no-store",
            });
            const data = await res.json().catch(() => ({}));
            const cmd = data && data.command ? data.command : "";
            if (!res.ok || (data && data.error && data.ok === false)) {
                const err = (data && (data.detail || data.error)) || res.statusText || res.status;
                const resp = data && data.response;
                let respPretty = resp || "(no data)";
                try {
                    if (typeof resp === "string") {
                        respPretty = JSON.stringify(JSON.parse(resp), null, 2);
                    } else if (resp && typeof resp === "object") {
                        respPretty = JSON.stringify(resp, null, 2);
                    }
                } catch (e) {
                    respPretty = resp || "(no data)";
                }
                const body = `
<div>Command:</div>
<pre class="mono">${escapeHtml(cmd)}</pre>
<div>Error:</div>
<pre class="mono">${escapeHtml(String(err))}</pre>
<div>Response Body:</div>
<pre class="mono">${respPretty}</pre>`;
                showResultModal("Test Listener", body, true);
                return;
            }
            const resp = data && data.response;
            let respPretty = resp || "(no data)";
            try {
                if (typeof resp === "string") {
                    respPretty = JSON.stringify(JSON.parse(resp), null, 2);
                } else if (resp && typeof resp === "object") {
                    respPretty = JSON.stringify(resp, null, 2);
                }
            } catch (e) {
                respPretty = resp || "(no data)";
            }
            const body = `
<div>Command:</div>
<pre class="mono">${escapeHtml(cmd)}</pre>
<div>Response:</div>
<pre class="mono">${respPretty}</pre>`;
            showResultModal("Test Listener", body, true);
        } catch (err) {
            showResultModal("Test Listener", `Failed to test listener: ${escapeHtml(String(err))}`);
        }
    }

    async function refreshTopServices(id) {
        if (!confirm("Refresh top services and check for new ones for this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/refresh-top-services`), {
                method: "POST",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            await loadListeners();
        } catch (err) {
            showResultModal("Refresh Top Services", `Failed to refresh: ${err}`);
        }
    }

    function formatServiceLabel(serviceId) {
        if (!serviceId) return "";
        const sid = String(serviceId);
        const match = serviceTypesCache.find((s) => String(s.service_id) === sid);
        if (!match || !match.service_type) return sid;
        const st = match.service_type;
        const desc = st.description || "";
        const name = st.name || "";
        if (desc) return desc;
        return name || sid;
    }

    function buildServiceSelect(selectedId, elementId) {
        const opts = serviceOptionsHtml(selectedId);
        const selId = elementId || "";
        return `<select id="${selId}" class="select service-select" data-select-id="${selId}">${opts}</select>`;
    }

    function populateServiceSelect() {
        const select = document.getElementById("listenerService");
        if (!select) return;
        updateSelectOptionsFromCache(select);
        if (select.options.length) select.selectedIndex = 0;
    }

    function buildStatusSelect(selectedVal, elementId) {
        const opts = [
            { value: "active", label: "Active" },
            { value: "inactive", label: "Inactive" },
        ];
        const inner = opts.map(o => {
            const sel = String(selectedVal || "active").toLowerCase() === o.value ? "selected" : "";
            return `<option value="${o.value}" ${sel}>${o.label}</option>`;
        }).join("");
        return `<select id="${elementId || ""}" class="select">${inner}</select>`;
    }

    function refreshServiceTypesForSelect(selectId) {
        refreshServiceTypes(false, selectId);
    }

    document.addEventListener("focusin", (e) => {
        const sel = e.target.closest(".service-select");
        if (sel && sel.id) {
            refreshServiceTypesForSelect(sel.id);
        }
    });
</script>

</body>
</html>
