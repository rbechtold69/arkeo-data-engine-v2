<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Data Marketplace | Subscriber Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>
<div class="page">

<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Data Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Subscriber Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
            <div class="header-right header-right-with-actions">
                <div class="header-icons">
                    <button id="walletToggleBtn" class="header-icon-btn" onclick="toggleHotWalletsFromButton()" title="Open Hot Wallets" aria-label="Open Hot Wallets">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M20 15C20.5523 15 21 14.5523 21 14C21 13.4477 20.5523 13 20 13C19.4477 13 19 13.4477 19 14C19 14.5523 19.4477 15 20 15Z" fill="currentColor"/>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M16.775 0.985398C18.4919 0.460783 20.2821 1.55148 20.6033 3.3178L20.9362 5.14896C22.1346 5.54225 23 6.67006 23 8V10.7639C23.6137 11.3132 24 12.1115 24 13V15C24 15.8885 23.6137 16.6868 23 17.2361V20C23 21.6569 21.6569 23 20 23H4C2.34315 23 1 21.6569 1 20V8C1 6.51309 2.08174 5.27884 3.50118 5.04128L16.775 0.985398ZM21 16C21.5523 16 22 15.5523 22 15V13C22 12.4477 21.5523 12 21 12H18C17.4477 12 17 12.4477 17 13V15C17 15.5523 17.4477 16 18 16H21ZM21 18V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V8C3 7.44772 3.44772 7 4 7H20C20.55 7 20.9962 7.44396 21 7.99303L21 10H18C16.3431 10 15 11.3431 15 13V15C15 16.6569 16.3431 18 18 18H21ZM18.6954 3.60705L18.9412 5H10L17.4232 2.82301C17.9965 2.65104 18.5914 3.01769 18.6954 3.60705Z" fill="currentColor"/>
                        </svg>
                    </button>
                    <a class="header-icon-btn" href="admin.html" title="Open Admin Area" aria-label="Open Admin Area">
                        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12.0002 8C9.79111 8 8.00024 9.79086 8.00024 12C8.00024 14.2091 9.79111 16 12.0002 16C14.2094 16 16.0002 14.2091 16.0002 12C16.0002 9.79086 14.2094 8 12.0002 8ZM10.0002 12C10.0002 10.8954 10.8957 10 12.0002 10C13.1048 10 14.0002 10.8954 14.0002 12C14.0002 13.1046 13.1048 14 12.0002 14C10.8957 14 10.0002 13.1046 10.0002 12Z"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M11.2867 0.5C9.88583 0.5 8.6461 1.46745 8.37171 2.85605L8.29264 3.25622C8.10489 4.20638 7.06195 4.83059 6.04511 4.48813L5.64825 4.35447C4.32246 3.90796 2.83873 4.42968 2.11836 5.63933L1.40492 6.83735C0.67773 8.05846 0.954349 9.60487 2.03927 10.5142L2.35714 10.7806C3.12939 11.4279 3.12939 12.5721 2.35714 13.2194L2.03927 13.4858C0.954349 14.3951 0.67773 15.9415 1.40492 17.1626L2.11833 18.3606C2.83872 19.5703 4.3225 20.092 5.64831 19.6455L6.04506 19.5118C7.06191 19.1693 8.1049 19.7935 8.29264 20.7437L8.37172 21.1439C8.6461 22.5325 9.88584 23.5 11.2867 23.5H12.7136C14.1146 23.5 15.3543 22.5325 15.6287 21.1438L15.7077 20.7438C15.8954 19.7936 16.9384 19.1693 17.9553 19.5118L18.3521 19.6455C19.6779 20.092 21.1617 19.5703 21.8821 18.3606L22.5955 17.1627C23.3227 15.9416 23.046 14.3951 21.9611 13.4858L21.6432 13.2194C20.8709 12.5722 20.8709 11.4278 21.6432 10.7806L21.9611 10.5142C23.046 9.60489 23.3227 8.05845 22.5955 6.83732L21.8821 5.63932C21.1617 4.42968 19.678 3.90795 18.3522 4.35444L17.9552 4.48814C16.9384 4.83059 15.8954 4.20634 15.7077 3.25617L15.6287 2.85616C15.3543 1.46751 14.1146 0.5 12.7136 0.5H11.2867ZM10.3338 3.24375C10.4149 2.83334 10.7983 2.5 11.2867 2.5H12.7136C13.2021 2.5 13.5855 2.83336 13.6666 3.24378L13.7456 3.64379C14.1791 5.83811 16.4909 7.09167 18.5935 6.38353L18.9905 6.24984C19.4495 6.09527 19.9394 6.28595 20.1637 6.66264L20.8771 7.86064C21.0946 8.22587 21.0208 8.69271 20.6764 8.98135L20.3586 9.24773C18.6325 10.6943 18.6325 13.3057 20.3586 14.7523L20.6764 15.0186C21.0208 15.3073 21.0946 15.7741 20.8771 16.1394L20.1637 17.3373C19.9394 17.714 19.4495 17.9047 18.9905 17.7501L18.5936 17.6164C16.4909 16.9082 14.1791 18.1618 13.7456 20.3562L13.6666 20.7562C13.5855 21.1666 13.2021 21.5 12.7136 21.5H11.2867C10.7983 21.5 10.4149 21.1667 10.3338 20.7562L10.2547 20.356C9.82113 18.1617 7.50931 16.9082 5.40665 17.6165L5.0099 17.7501C4.55092 17.9047 4.06104 17.714 3.83671 17.3373L3.1233 16.1393C2.9058 15.7741 2.97959 15.3073 3.32398 15.0186L3.64185 14.7522C5.36782 13.3056 5.36781 10.6944 3.64185 9.24779L3.32398 8.98137C2.97959 8.69273 2.9058 8.2259 3.1233 7.86067L3.83674 6.66266C4.06106 6.28596 4.55093 6.09528 5.0099 6.24986L5.40676 6.38352C7.50938 7.09166 9.82112 5.83819 10.2547 3.64392L10.3338 3.24375Z"></path>
                        </svg>
                    </a>
                </div>
            </div>
    </div>
</div>

<div class="card hotwallet-card" style="background: linear-gradient(135deg, #0181a6 0%, #3be0ff 100%); color:#0b1220;">
    <div class="collapsible hotwallet-header" onclick="toggleHotWalletsFromButton()" role="button" aria-expanded="false">
        <div class="collapsible-left">
            <h2 class="mt-0" style="margin:0; color:#fff; font-size:18px; display:inline-flex; align-items:center; gap:8px;">
                <svg viewBox="0 0 24 24" width="18" height="18" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M20 15C20.5523 15 21 14.5523 21 14C21 13.4477 20.5523 13 20 13C19.4477 13 19 13.4477 19 14C19 14.5523 19.4477 15 20 15Z" fill="currentColor"></path>
                    <path fill-rule="evenodd" clip-rule="evenodd" d="M16.775 0.985398C18.4919 0.460783 20.2821 1.55148 20.6033 3.3178L20.9362 5.14896C22.1346 5.54225 23 6.67006 23 8V10.7639C23.6137 11.3132 24 12.1115 24 13V15C24 15.8885 23.6137 16.6868 23 17.2361V20C23 21.6569 21.6569 23 20 23H4C2.34315 23 1 21.6569 1 20V8C1 6.51309 2.08174 5.27884 3.50118 5.04128L16.775 0.985398ZM21 16C21.5523 16 22 15.5523 22 15V13C22 12.4477 21.5523 12 21 12H18C17.4477 12 17 12.4477 17 13V15C17 15.5523 17.4477 16 18 16H21ZM21 18V20C21 20.5523 20.5523 21 20 21H4C3.44772 21 3 20.5523 3 20V8C3 7.44772 3.44772 7 4 7H20C20.55 7 20.9962 7.44396 21 7.99303L21 10H18C16.3431 10 15 11.3431 15 13V15C15 16.6569 16.3431 18 18 18H21ZM18.6954 3.60705L18.9412 5H10L17.4232 2.82301C17.9965 2.65104 18.5914 3.01769 18.6954 3.60705Z" fill="currentColor"></path>
                </svg>
                Hot Wallets
            </h2>
        </div>
        <div class="collapsible-right">
            <div class="hotwallet-summary" id="hotWalletSummary">
                <svg viewBox="0 0 40 40" width="16" height="16" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                    <path d="M20 0C8.95469 0 0 8.95469 0 20C0 31.0453 8.95469 40 20 40C31.0453 40 40 31.0453 40 20C40 8.95469 31.0453 0 20 0ZM29.527 27.4046H25.4452C24.4316 27.4046 23.4976 26.868 22.9849 25.9976L20.461 21.3076C20.461 21.3076 20.4452 21.2838 20.4372 21.2679L22.2496 20.2186V17.6192L20 16.3196L17.7504 17.6192V20.2186L19.5628 21.2679C19.5628 21.2679 19.5469 21.2917 19.539 21.3076L17.0151 25.9976C16.5024 26.872 15.5644 27.4046 14.5548 27.4046H10.473C9.56677 27.4046 9.00238 26.4189 9.46343 25.6399L18.9905 9.43959C19.4436 8.66852 20.5564 8.66852 21.0095 9.43959L30.5366 25.6359C30.9976 26.4149 30.4332 27.4006 29.527 27.4006V27.4046Z" fill="#ffffff"></path>
                </svg>
                <span id="walletArkeoBalanceSummary">—</span>
            </div>
            <span id="syncPill" class="status-badge status-warn hidden">Syncing...</span>
        </div>
    </div>
    <div id="hotWalletContent" class="collapsible-content" style="display:none;">
        <div class="wallet-grid">
            <div class="wallet-card">
                <img src="images/ethereum/info/logo.png" alt="Ethereum" class="wallet-icon">
                <div class="wallet-block-badge">Block: <span id="walletEthBlockBadge">—</span></div>
                <div class="wallet-title">Ethereum</div>
                <div class="wallet-meta"><span id="walletEthBalance">—</span>
                    <span class="info-icon" title="Sending USDC requires a small amount of ETH for gas." onclick="showEthGasInfo()" aria-label="Gas info">
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                            <path d="M12 7.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z" fill="currentColor"/>
                            <path d="M11.25 10.5h1.5v6h-1.5z" fill="currentColor"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-meta"><span id="walletEthUsdcBalance">—</span> (wrapped)</div>
                <div class="wallet-meta wallet-copy">
                    <span>Address: <span id="walletEthAddress">—</span></span>
                    <span onclick="copyEthAddress()" title="Copy address" aria-label="Copy Ethereum address">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5.00005C7.01165 5.00082 6.49359 5.01338 6.09202 5.21799C5.71569 5.40973 5.40973 5.71569 5.21799 6.09202C5 6.51984 5 7.07989 5 8.2V17.8C5 18.9201 5 19.4802 5.21799 19.908C5.40973 20.2843 5.71569 20.5903 6.09202 20.782C6.51984 21 7.07989 21 8.2 21H15.8C16.9201 21 17.4802 21 17.908 20.782C18.2843 20.5903 18.5903 20.2843 18.782 19.908C19 19.4802 19 18.9201 19 17.8V8.2C19 7.07989 19 6.51984 18.782 6.09202C18.5903 5.71569 18.2843 5.40973 17.908 5.21799C17.5064 5.01338 16.9884 5.00082 16 5.00005M8 5.00005V7H16V5.00005M8 5.00005V4.70711C8 4.25435 8.17986 3.82014 8.5 3.5C8.82014 3.17986 9.25435 3 9.70711 3H14.2929C14.7456 3 15.1799 3.17986 15.5 3.5C15.8201 3.82014 16 4.25435 16 4.70711V5.00005M12 11V17M12 11L14 13M12 11L10 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-actions-inline">
                    <button class="wallet-action-btn" onclick="openSendUsdcModal(event)" title="Send USDC to another chain/address" aria-label="Send USDC">Send USDC</button>
                    <button class="wallet-action-btn ghost" onclick="openRescueGasModal(event)" title="Rescue stuck Axelar transfer" aria-label="Rescue Axelar transfer">Rescue</button>
                    <button class="wallet-action-btn ghost" onclick="openGmpStatusModal(event)" title="Check Axelar GMP status" aria-label="Check GMP status">Check GMP</button>
                </div>
            </div>
            <div class="wallet-card">
                <img src="images/osmosis/info/logo.png" alt="Osmosis" class="wallet-icon">
                <div class="wallet-block-badge">Block: <span id="walletOsmoBlockBadge">—</span></div>
                <div class="wallet-title">Osmosis</div>
                <div class="wallet-meta">
                    <span id="walletOsmoBalance">—</span>
                    <img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                    <span class="info-icon" title="Sending tokens on Osmosis requires a small amount of OSMO for gas." onclick="showOsmoGasInfo()" aria-label="Gas info">
                        <svg viewBox="0 0 24 24" width="14" height="14" fill="none" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
                            <circle cx="12" cy="12" r="10" stroke="currentColor" stroke-width="2"/>
                            <path d="M12 7.5a.75.75 0 1 0 0 1.5.75.75 0 0 0 0-1.5Z" fill="currentColor"/>
                            <path d="M11.25 10.5h1.5v6h-1.5z" fill="currentColor"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-meta">
                    <span id="walletOsmoUsdcBalance">—</span>
                    <img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                </div>
                <div class="wallet-meta">
                    <span id="walletOsmoArkeoBalance">—</span>
                    <img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                </div>
                <div class="wallet-meta wallet-copy">
                    <span>Address: <span id="walletOsmoAddress">—</span></span>
                    <span onclick="copyOsmoAddress()" title="Copy address" aria-label="Copy Osmosis address">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5.00005C7.01165 5.00082 6.49359 5.01338 6.09202 5.21799C5.71569 5.40973 5.40973 5.71569 5.21799 6.09202C5 6.51984 5 7.07989 5 8.2V17.8C5 18.9201 5 19.4802 5.21799 19.908C5.40973 20.2843 5.71569 20.5903 6.09202 20.782C6.51984 21 7.07989 21 8.2 21H15.8C16.9201 21 17.4802 21 17.908 20.782C18.2843 20.5903 18.5903 20.2843 18.782 19.908C19 19.4802 19 18.9201 19 17.8V8.2C19 7.07989 19 6.51984 18.782 6.09202C18.5903 5.71569 18.2843 5.40973 17.908 5.21799C17.5064 5.01338 16.9884 5.00082 16 5.00005M8 5.00005V7H16V5.00005M8 5.00005V4.70711C8 4.25435 8.17986 3.82014 8.5 3.5C8.82014 3.17986 9.25435 3 9.70711 3H14.2929C14.7456 3 15.1799 3.17986 15.5 3.5C15.8201 3.82014 16 4.25435 16 4.70711V5.00005M12 11V17M12 11L14 13M12 11L10 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-actions-inline" style="gap:8px;">
                    <button class="wallet-action-btn ghost" id="convertUsdcBtn" onclick="openConvertUsdcModal(event)" title="Convert USDC (IBC) to ARKEO (wrapped) on Osmosis" aria-label="Convert USDC to ARKEO">
                        USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> to ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                    </button>
                    <button class="wallet-action-btn ghost" id="convertArkeoBtn" onclick="openConvertArkeoModal(event)" title="Convert ARKEO (wrapped) to USDC (IBC) on Osmosis" aria-label="Convert ARKEO to USDC">
                        ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> to USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                    </button>
                    <button class="wallet-action-btn ghost" id="convertArkeoNativeBtn" onclick="openConvertArkeoNativeModal(event)" title="Send ARKEO (IBC) to Arkeo chain" aria-label="Send ARKEO to Arkeo chain">
                        ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> to ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon" aria-hidden="true">
                    </button>
                </div>
                </div>
                <div class="wallet-card">
                <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="wallet-icon" id="walletArkeoIcon">
                <div class="wallet-block-badge">Block: <span id="walletArkeoBlockBadge">—</span></div>
                <div class="wallet-title">Arkeo</div>
                <div class="wallet-meta">
                    <span id="walletArkeoBalance">—</span>
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon" aria-hidden="true">
                </div>
                <div class="wallet-meta wallet-copy">
                    <span>Address: <span id="walletArkeoAddress">—</span></span>
                    <span onclick="copyArkeoAddress()" title="Copy address" aria-label="Copy address">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5.00005C7.01165 5.00082 6.49359 5.01338 6.09202 5.21799C5.71569 5.40973 5.40973 5.71569 5.21799 6.09202C5 6.51984 5 7.07989 5 8.2V17.8C5 18.9201 5 19.4802 5.21799 19.908C5.40973 20.2843 5.71569 20.5903 6.09202 20.782C6.51984 21 7.07989 21 8.2 21H15.8C16.9201 21 17.4802 21 17.908 20.782C18.2843 20.5903 18.5903 20.2843 18.782 19.908C19 19.4802 19 18.9201 19 17.8V8.2C19 7.07989 19 6.51984 18.782 6.09202C18.5903 5.71569 18.2843 5.40973 17.908 5.21799C17.5064 5.01338 16.9884 5.00082 16 5.00005M8 5.00005V7H16V5.00005M8 5.00005V4.70711C8 4.25435 8.17986 3.82014 8.5 3.5C8.82014 3.17986 9.25435 3 9.70711 3H14.2929C14.7456 3 15.1799 3.17986 15.5 3.5C15.8201 3.82014 16 4.25435 16 4.70711V5.00005M12 11V17M12 11L14 13M12 11L10 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-submeta wallet-copy">
                    <span>Pubkey: <span id="walletArkeoPubkey">—</span></span>
                    <span onclick="copyArkeoPubkey()" title="Copy pubkey" aria-label="Copy pubkey">
                        <svg viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                            <path d="M8 5.00005C7.01165 5.00082 6.49359 5.01338 6.09202 5.21799C5.71569 5.40973 5.40973 5.71569 5.21799 6.09202C5 6.51984 5 7.07989 5 8.2V17.8C5 18.9201 5 19.4802 5.21799 19.908C5.40973 20.2843 5.71569 20.5903 6.09202 20.782C6.51984 21 7.07989 21 8.2 21H15.8C16.9201 21 17.4802 21 17.908 20.782C18.2843 20.5903 18.5903 20.2843 18.782 19.908C19 19.4802 19 18.9201 19 17.8V8.2C19 7.07989 19 6.51984 18.782 6.09202C18.5903 5.71569 18.2843 5.40973 17.908 5.21799C17.5064 5.01338 16.9884 5.00082 16 5.00005M8 5.00005V7H16V5.00005M8 5.00005V4.70711C8 4.25435 8.17986 3.82014 8.5 3.5C8.82014 3.17986 9.25435 3 9.70711 3H14.2929C14.7456 3 15.1799 3.17986 15.5 3.5C15.8201 3.82014 16 4.25435 16 4.70711V5.00005M12 11V17M12 11L14 13M12 11L10 13" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </span>
                </div>
                <div class="wallet-actions-inline" style="margin-top:8px; display:flex; justify-content:flex-start; gap:8px;">
                    <button class="wallet-action-btn ghost" onclick="openConvertArkeoToOsmosisModal(event)" title="Send ARKEO from Arkeo chain to Osmosis" aria-label="Send ARKEO to Osmosis">
                        ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon" aria-hidden="true"> to ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true">
                    </button>
                </div>
            </div>
        </div>
        <div class="wallet-actions-inline" style="margin-top:12px; display:flex; justify-content:flex-end; gap:8px;">
            <button class="wallet-action-btn" onclick="viewHotwalletLogs(event)" title="View hot wallet status/logs" aria-label="View hot wallet status">Status</button>
        </div>
    </div>
</div>

<div class="card">
    <h2>Arkeo Data Marketplace</h2>
    <div class="metrics-grid header-metrics">
        <div class="metric-card">
            <div class="metric-label">Active Providers</div>
            <div class="metric-value" id="metricProviders">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Active Services</div>
            <div class="metric-value" id="metricServices">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Contracts</div>
            <div class="metric-value" id="metricContracts">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Subscribers</div>
            <div class="metric-value" id="metricSubscribers">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Supported Chains</div>
            <div class="metric-value" id="metricNodeTypes">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-value"><button class="primary block-btn" id="cacheRefreshBtn" onclick="refreshCache()">Refresh</button></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="row-between row-align-end">
        <div>
            <h2>Arkeo Subscriber Listeners</h2>
        </div>
        <div class="text-right">
            <div class="muted" id="listenerRange">Ports 62001-62100</div>
            <div class="muted small" style="margin-top:4px;">
                Start port:
                <select id="portStartSelect" class="select" style="width:auto; padding:2px 6px; min-width:90px;" onchange="handlePortStartChange()">
                    <option>62001</option>
                </select>
            </div>
            <div class="muted small">Next available port: <span id="nextPortValue">–</span></div>
        </div>
    </div>
    <form id="listenerForm" class="listener-form" onsubmit="submitListenerForm(event)">
        <div class="listener-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 12px;">
            <label style="width:100%;">
                <div class="muted">Service Type</div>
                <div class="muted small">Choose a provider service to bind to a listener.</div>
                <div class="combo-select">
                    <div id="svcComboDisplay" class="combo-display" onclick="toggleServiceMenu(event)">
                        <span id="svcComboSelected">Select a service</span>
                        <span class="combo-caret">▾</span>
                    </div>
                    <div id="svcComboMenu" class="combo-menu hidden">
                        <input type="text" id="svcComboSearch" class="full combo-search" placeholder="Search services..." oninput="filterServiceOptions()" autocomplete="off" autocorrect="off" spellcheck="false" />
                        <div id="svcComboOptions" class="combo-options"></div>
                    </div>
                    <select id="listenerService" class="hidden" aria-hidden="true" tabindex="-1"></select>
                </div>
            </label>
            <div class="listener-actions" style="align-self:flex-end; white-space: nowrap;">
                <button type="submit" class="primary">Add Listener</button>
            </div>
        </div>
    </form>
<div id="listenersTable" class="mt-2"></div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div id="listenerLogs" class="section log-container"></div>

</div> <!-- /page -->

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <div id="modalBody" class="modal-body"></div>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<div id="sendUsdcModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Send USDC</h3>
        <form onsubmit="submitSendUsdc(event)">
            <div class="form-body">
                <div class="form-row send-amount-row">
                    <div class="field-block">
                        <label for="sendUsdcAmount">Amount (USDC)</label>
                        <input type="number" id="sendUsdcAmount" min="0" step="0.000001" placeholder="0.000000" />
                    </div>
                    <div class="field-block">
                        <div class="inline-header">Add Fees</div>
                        <div class="fee-row">
                            <label class="checkbox-inline">
                                <input type="checkbox" id="sendUsdcAddFees" />
                                <span>ETH gas</span>
                            </label>
                            <input type="number" id="sendUsdcGasAmount" min="0" step="0.001" value="0.010" aria-label="Axelar gas (ETH)" />
                        </div>
                    </div>
                </div>
                <div class="form-row send-log-row">
                    <label for="sendUsdcLog">Status</label>
                    <textarea id="sendUsdcLog" class="send-log" rows="10" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeSendUsdcModal()">Close</button>
                <button type="submit" class="primary" id="sendUsdcSubmitBtn">Send</button>
            </div>
        </form>
    </div>
</div>

<div id="rescueGasModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Rescue Axelar Transfer</h3>
        <form onsubmit="submitRescueGas(event)">
            <div class="form-body">
                <div class="form-row">
                    <label for="rescueTxHash">sendToken Tx Hash</label>
                    <input type="text" id="rescueTxHash" placeholder="0x..." />
                </div>
                <div class="form-row">
                    <label for="rescueGasAmount">Gas (ETH)</label>
                    <input type="number" id="rescueGasAmount" min="0" step="0.001" value="0.010" />
                </div>
                <div class="form-row">
                    <label for="rescueGasLog">Status</label>
                    <textarea id="rescueGasLog" class="send-log" rows="8" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeRescueGasModal()">Close</button>
                <button type="submit" class="primary" id="rescueGasSubmitBtn">Top Up</button>
            </div>
        </form>
    </div>
</div>

<div id="convertUsdcModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Convert USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-xl" aria-hidden="true"> to ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-xl" aria-hidden="true"></h3>
        <div class="muted small" style="margin-bottom:8px;">Swap happens on Osmosis (Pool 2977). Watch the status log below.</div>
        <form onsubmit="submitConvertUsdc(event)">
            <div class="form-body">
                <div class="form-row convert-row">
                    <div class="field-block">
                        <div class="field-inline">
                            <label for="convertUsdcAmount">USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> Amount</label>
                            <button type="button" class="mini-btn" onclick="setConvertUsdcMax()">Max</button>
                        </div>
                        <input type="number" id="convertUsdcAmount" min="0" step="0.000001" placeholder="Available: 0.000000" oninput="debouncedConvertQuote()" />
                        <div class="estimate-note" id="convertUsdcPriceNote">—</div>
                    </div>
                    <div class="field-block">
                        <label for="convertUsdcEst">ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> Amount</label>
                        <div class="estimate-box" id="convertUsdcEst">—</div>
                    </div>
                </div>
                <div class="form-row" id="convertUsdcLogRow">
                    <label for="convertUsdcLog">Log</label>
                    <textarea id="convertUsdcLog" class="send-log" rows="10" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeConvertUsdcModal()">Close</button>
                <button type="submit" class="primary" id="convertUsdcSubmitBtn">Convert</button>
            </div>
        </form>
    </div>
</div>

<div id="convertArkeoModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Convert ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-xl" aria-hidden="true"> to USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-xl" aria-hidden="true"></h3>
        <div class="muted small" style="margin-bottom:8px;">Swap happens on Osmosis (Pool 2977). Watch the status log below.</div>
        <form onsubmit="submitConvertArkeo(event)">
            <div class="form-body">
                <div class="form-row convert-row">
                        <div class="field-block">
                            <div class="field-inline">
                                <label for="convertArkeoAmount">ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> Amount</label>
                                <button type="button" class="mini-btn" onclick="setConvertArkeoMax()">Max</button>
                            </div>
                            <input type="number" id="convertArkeoAmount" min="0" step="0.00000001" placeholder="Available: 0.00000000" oninput="checkConvertArkeoAmount()" />
                            <div class="estimate-note" id="convertArkeoPriceNote">No live quote; swap uses pool 2977.</div>
                        </div>
                    <div class="field-block">
                        <label for="convertArkeoEst">USDC<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"> Amount</label>
                        <div class="estimate-box" id="convertArkeoEst">—</div>
                    </div>
                </div>
                <div class="form-row" id="convertArkeoLogRow">
                    <label for="convertArkeoLog">Log</label>
                    <textarea id="convertArkeoLog" class="send-log" rows="10" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeConvertArkeoModal()">Close</button>
                <button type="submit" class="primary" id="convertArkeoSubmitBtn">Convert</button>
            </div>
        </form>
    </div>
</div>

<div id="convertArkeoNativeModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Send ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-lg" aria-hidden="true"> to ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon-lg" aria-hidden="true"></h3>
        <div class="muted small" style="margin-bottom:8px;">IBC transfer: Osmosis Chain wrapped ARKEO to Arkeo Chain. Watch the status log below.</div>
        <form onsubmit="submitConvertArkeoNative(event)">
                <div class="form-body">
                    <div class="form-row convert-row">
                        <div class="field-block">
                        <div class="field-inline">
                            <label for="convertArkeoNativeAmount">ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"></label>
                            <button type="button" class="mini-btn" onclick="setConvertArkeoNativeMax()">Max</button>
                        </div>
                        <input type="number" id="convertArkeoNativeAmount" min="0" step="0.00000001" placeholder="Available: 0.00000000" oninput="checkConvertArkeoNativeAmount()" />
                        <div class="estimate-note" id="convertArkeoNativeNote">IBC transfer to Arkeo chain.</div>
                    </div>
                    <div class="field-block">
                        <label for="convertArkeoNativeEst">ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon" aria-hidden="true"></label>
                        <div class="estimate-box" id="convertArkeoNativeEst">—</div>
                    </div>
                </div>
                <div class="form-row" id="convertArkeoNativeLogRow">
                    <label for="convertArkeoNativeLog">Log</label>
                    <textarea id="convertArkeoNativeLog" class="send-log" rows="10" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeConvertArkeoNativeModal()">Close</button>
                <button type="submit" class="primary" id="convertArkeoNativeSubmitBtn">Send</button>
            </div>
        </form>
    </div>
</div>

<div id="convertArkeoToOsmosisModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Send ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon-lg" aria-hidden="true"> to ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon-lg" aria-hidden="true"></h3>
        <div class="muted small" style="margin-bottom:8px;">IBC transfer: Arkeo Chain to Osmosis Chain wrapped ARKEO. Watch the status log below.</div>
        <form onsubmit="submitConvertArkeoToOsmosis(event)">
            <div class="form-body">
                <div class="form-row convert-row">
                    <div class="field-block">
                        <div class="field-inline">
                            <label for="convertArkeoToOsmosisAmount">ARKEO<img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="chain-icon" aria-hidden="true"></label>
                            <button type="button" class="mini-btn" onclick="setConvertArkeoToOsmosisMax()">Max</button>
                        </div>
                        <input type="number" id="convertArkeoToOsmosisAmount" min="0" step="0.000001" placeholder="Available: 0.000000" oninput="checkConvertArkeoToOsmosisAmount()" />
                        <div class="estimate-note" id="convertArkeoToOsmosisNote" style="color: var(--primary); font-size:12px;">IBC transfer to Osmosis.</div>
                    </div>
                    <div class="field-block">
                        <label for="convertArkeoToOsmosisEst">ARKEO<img src="images/osmosis/info/logo.png" alt="Osmosis" class="chain-icon" aria-hidden="true"></label>
                        <div class="estimate-box" id="convertArkeoToOsmosisEst"></div>
                    </div>
                </div>
                <div class="form-row" id="convertArkeoToOsmosisLogRow" style="display:none;">
                    <label for="convertArkeoToOsmosisLog">Log</label>
                    <textarea id="convertArkeoToOsmosisLog" class="send-log" rows="10" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeConvertArkeoToOsmosisModal()">Close</button>
                <button type="submit" class="primary" id="convertArkeoToOsmosisSubmitBtn">Send</button>
            </div>
        </form>
    </div>
</div>

<div id="gmpStatusModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3>Check GMP Status</h3>
        <form onsubmit="submitGmpStatus(event)">
            <div class="form-body">
                <div class="form-row">
                    <label for="gmpStatusTxHash">sendToken Tx Hash</label>
                    <input type="text" id="gmpStatusTxHash" placeholder="0x..." />
                </div>
                <div class="form-row">
                    <label>Squid (optional) Chain IDs</label>
                    <div class="send-amount-row">
                        <div class="field-block">
                            <label for="gmpStatusFromChain">From Chain ID</label>
                            <input type="text" id="gmpStatusFromChain" placeholder="1 (Ethereum mainnet)" />
                        </div>
                        <div class="field-block">
                            <label for="gmpStatusToChain">To Chain ID</label>
                            <input type="text" id="gmpStatusToChain" placeholder="(Squid ID for Osmosis)" />
                        </div>
                    </div>
                </div>
                <div class="form-row">
                    <label for="gmpStatusLog">Status</label>
                    <textarea id="gmpStatusLog" class="send-log" rows="8" readonly></textarea>
                </div>
            </div>
            <div class="actions modal-actions">
                <button type="button" class="btn-ghost" onclick="closeGmpStatusModal()">Close</button>
                <button type="submit" class="primary" id="gmpStatusSubmitBtn">Check</button>
            </div>
        </form>
    </div>
</div>

<div id="adminPasswordGate" class="overlay overlay-strong hidden">
    <div class="overlay-card password-card">
        <div class="password-title">
            <span>Arkeo Data Marketplace</span>
            <span class="sep">|</span>
            <span class="sub highlight">Subscriber Manager</span>
        </div>
        <form onsubmit="submitAdminPasswordGate(); return false;">
            <div class="password-body password-panel">
                <h3 class="mt-6 mb-0">Password Required</h3>
                <p class="muted">Enter the admin password to continue.</p>
                <input type="text" name="admin-username-filler" autocomplete="username" value="admin" class="hidden" aria-hidden="true" tabindex="-1" />
                <input type="password" id="adminPasswordGateInput" autocomplete="current-password" placeholder="Admin password" />
            </div>
            <div class="actions center password-actions">
                <button class="primary" type="submit">Unlock</button>
            </div>
            <div id="adminPasswordGateStatus" class="muted mt-6"></div>
        </form>
    </div>
</div>

<script>
    let currentPubkey = "";
    let currentAddress = "";

    function formatPubkeyShort(pubkey) {
        if (!pubkey || pubkey.length < 12) return pubkey || "";
        // Show first 10 and last 8 for a bit more context
        return `${pubkey.slice(0, 9)}...${pubkey.slice(-8)}`;
    }

    function setConvertArkeoNativeButtonEnabled(enabled) {
        const btn = document.getElementById("convertArkeoNativeSubmitBtn");
        if (btn) {
            btn.disabled = !enabled;
            if (!enabled) btn.classList.add("disabled");
            else btn.classList.remove("disabled");
        }
    }

    function setConvertArkeoToOsmosisButtonEnabled(enabled) {
        const btn = document.getElementById("convertArkeoToOsmosisSubmitBtn");
        if (btn) {
            btn.disabled = !enabled;
            if (!enabled) btn.classList.add("disabled");
            else btn.classList.remove("disabled");
        }
    }

    function appendConvertArkeoNativeLog(line) {
        if (line) {
            try {
                fetch(apiUrl("/api/hotwallet/log-note"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ msg: line }),
                });
            } catch (e) { /* noop */ }
        }
        refreshHotwalletLogBox("convertArkeoNativeLog");
    }

    function appendConvertArkeoToOsmosisLog(line) {
        if (line) {
            try {
                fetch(apiUrl("/api/hotwallet/log-note"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ msg: line }),
                });
            } catch (e) { /* noop */ }
        }
        refreshHotwalletLogBox("convertArkeoToOsmosisLog");
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    async function copyArkeoAddress() {
        const val = currentAddress || document.getElementById("walletArkeoAddress")?.textContent || "";
        showCopyModal("Copy Arkeo Address", val);
    }

    function showEthGasInfo() {
        const msg = "To send or move USDC from this wallet, you need a small amount of ETH to pay gas.";
        showResultModal("Gas Reminder", msg);
    }

    function showOsmoGasInfo() {
        const msg = "To send or move tokens (including USDC) on Osmosis, you need a small amount of OSMO to pay gas.";
        showResultModal("Gas Reminder", msg);
    }

    function parseNumber(text) {
        if (!text) return NaN;
        const num = parseFloat(String(text).replace(/[^\d.\-]/g, ""));
        return num;
    }

    function setOsmoGasGates(osmoBalanceText) {
        const osmoVal = parseNumber(osmoBalanceText);
        const hasGas = Number.isFinite(osmoVal) && osmoVal > 0;
        const reason = "Requires OSMO for gas.";
        const toggle = (id, allowed) => {
            const el = document.getElementById(id);
            if (!el) return;
            if (!el.dataset.baseTitle) el.dataset.baseTitle = el.title || "";
            if (allowed) {
                el.disabled = false;
                el.title = el.dataset.baseTitle;
            } else {
                el.disabled = true;
                el.title = `${el.dataset.baseTitle || ""} (${reason})`.trim();
            }
        };
        // Gate Osmosis conversions that need OSMO gas
        toggle("convertUsdcBtn", hasGas);
        toggle("convertArkeoBtn", hasGas);
        toggle("convertArkeoNativeBtn", hasGas);
    }

    let sendUsdcPollHandle = null;
    let sendUsdcStartUsdc = null;
    let sendUsdcAmount = null;
    let convertUsdcPrice = null;
    let convertQuoteTimer = null;
    let convertWaitTimer = null;
    let convertArkeoWaitTimer = null;
    let convertArkeoQuoteTimer = null;
    let convertAutoClose = null;
    let convertLogPoll = null;
    let convertArkeoLogPoll = null;
    let convertArkeoNativeWaitTimer = null;
    let convertArkeoNativeLogPoll = null;
    let convertArkeoToOsmosisWaitTimer = null;
    let convertArkeoToOsmosisLogPoll = null;
    let rescuePollHandle = null;

    function clearSendUsdcPoll() {
        if (sendUsdcPollHandle) {
            clearInterval(sendUsdcPollHandle);
            sendUsdcPollHandle = null;
        }
    }

    function appendSendUsdcLog(line) {
        const box = document.getElementById("sendUsdcLog");
        if (!box) return;
        const ts = new Date().toISOString().replace("T", " ").replace("Z", "");
        box.value = `${box.value}${ts}  ${line}\n`;
        box.scrollTop = box.scrollHeight;
    }

    async function openSendUsdcModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        clearSendUsdcPoll();
        sendUsdcStartUsdc = null;
        sendUsdcAmount = null;
        const modal = document.getElementById("sendUsdcModal");
        const amtInput = document.getElementById("sendUsdcAmount");
        const gasInput = document.getElementById("sendUsdcGasAmount");
        const addFees = document.getElementById("sendUsdcAddFees");
        const logBox = document.getElementById("sendUsdcLog");
        if (logBox) logBox.value = "";
        if (addFees) addFees.checked = false;
            if (gasInput) {
                const defGas = parseNumber(gasInput.value) || 0.003;
                gasInput.value = defGas.toFixed(3);
            }
        if (modal) modal.classList.remove("hidden");
        const balText = document.getElementById("walletEthUsdcBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (amtInput) {
            amtInput.value = "";
            amtInput.placeholder = isNaN(avail) ? "0.000000" : `Available: ${avail.toFixed(6)}`;
            amtInput.focus();
        }
        appendSendUsdcLog("Ready to send USDC from ETH to Osmosis via Axelar.");
    }

    function closeSendUsdcModal() {
        clearSendUsdcPoll();
        const modal = document.getElementById("sendUsdcModal");
        if (modal) modal.classList.add("hidden");
    }

    function clearRescuePoll() {
        if (rescuePollHandle) {
            clearInterval(rescuePollHandle);
            rescuePollHandle = null;
        }
    }

    function appendRescueLog(line) {
        const box = document.getElementById("rescueGasLog");
        if (!box) return;
        const ts = new Date().toISOString().replace("T", " ").replace("Z", "");
        box.value = `${box.value}${ts}  ${line}\n`;
        box.scrollTop = box.scrollHeight;
    }

    function appendGmpLog(line) {
        const box = document.getElementById("gmpStatusLog");
        if (!box) return;
        const ts = new Date().toISOString().replace("T", " ").replace("Z", "");
        box.value = `${box.value}${ts}  ${line}\n`;
        box.scrollTop = box.scrollHeight;
    }

    async function refreshHotwalletLogBox(targetId = "convertUsdcLog") {
        const box = document.getElementById(targetId);
        if (!box) return;
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/logs?limit=200"), { cache: "no-store" });
            const data = await resp.json();
            const entries = Array.isArray(data?.logs) ? data.logs : Array.isArray(data) ? data : [];
            const lines = entries
                .map((e) => {
                    const ts = e?.ts || "";
                    const msg = e?.msg || e?.message || e?.action || "";
                    const stage = e?.stage ? ` [${e.stage}]` : "";
                    const swap = e?.swap_tx ? ` swap=${e.swap_tx}` : "";
                    const ibc = e?.ibc_tx ? ` ibc=${e.ibc_tx}` : "";
                    return `${ts}${stage ? " " + stage : ""}  ${msg}${swap || ""}${ibc || ""}`;
                })
                .join("\n");
            box.value = lines || "No log entries yet.";
            // keep scrolled to the latest entry
            box.scrollTop = box.scrollHeight;
        } catch (err) {
            box.value = `Failed to load logs: ${err}`;
        }
    }

    function startHotwalletLogPoll(targetId = "convertUsdcLog", intervalMs = 5000) {
        stopHotwalletLogPoll();
        refreshHotwalletLogBox(targetId);
        convertLogPoll = setInterval(() => refreshHotwalletLogBox(targetId), intervalMs);
    }

    function stopHotwalletLogPoll() {
        if (convertLogPoll) {
            clearInterval(convertLogPoll);
            convertLogPoll = null;
        }
    }

    function appendConvertLog(line) {
        // For convert modal, prefer showing server-side hotwallet log; trigger a refresh.
        // Local message is not persisted, but we still refresh so UI stays in sync with the log file.
        if (line) {
            // best-effort: write the note to backend log so history matches the UI
            try {
                fetch(apiUrl("/api/hotwallet/log-note"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ msg: line }),
                });
            } catch (e) {
                // ignore
            }
        }
        refreshHotwalletLogBox("convertUsdcLog");
    }

    function setConvertButtonEnabled(enabled) {
        const btn = document.getElementById("convertUsdcSubmitBtn");
        if (btn) {
            btn.disabled = !enabled;
            if (!enabled) btn.classList.add("disabled");
            else btn.classList.remove("disabled");
        }
    }

    function debouncedConvertQuote() {
        if (convertQuoteTimer) clearTimeout(convertQuoteTimer);
        setConvertButtonEnabled(false);
        convertQuoteTimer = setTimeout(fetchConvertQuote, 350);
    }

    function debouncedConvertArkeoQuote() {
        if (convertArkeoQuoteTimer) clearTimeout(convertArkeoQuoteTimer);
        setConvertArkeoButtonEnabled(false);
        convertArkeoQuoteTimer = setTimeout(fetchConvertArkeoQuote, 350);
    }

    function setConvertArkeoButtonEnabled(enabled) {
        const btn = document.getElementById("convertArkeoSubmitBtn");
        if (btn) {
            btn.disabled = !enabled;
            if (!enabled) btn.classList.add("disabled");
            else btn.classList.remove("disabled");
        }
    }

    function appendConvertArkeoLog(line) {
        if (line) {
            try {
                fetch(apiUrl("/api/hotwallet/log-note"), {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ msg: line }),
                });
            } catch (e) { /* noop */ }
        }
        refreshHotwalletLogBox("convertArkeoLog");
    }

    function openConvertArkeoModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const modal = document.getElementById("convertArkeoModal");
        const amtInput = document.getElementById("convertArkeoAmount");
        const logBox = document.getElementById("convertArkeoLog");
        const logRow = document.getElementById("convertArkeoLogRow");
        if (logBox) logBox.value = "";
        if (logRow) logRow.style.display = "none";
        startHotwalletLogPoll("convertArkeoLog", 5000);
        if (convertArkeoQuoteTimer) {
            clearTimeout(convertArkeoQuoteTimer);
            convertArkeoQuoteTimer = null;
        }
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (amtInput) {
            amtInput.value = "";
            amtInput.placeholder = isNaN(avail) ? "Available: 0.00000000" : `Available: ${avail.toFixed(8)}`;
        }
        if (modal) modal.classList.remove("hidden");
        setConvertArkeoButtonEnabled(false);
        // kick off quote if amount present
        fetchConvertArkeoQuote();
    }

    function openConvertArkeoNativeModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const modal = document.getElementById("convertArkeoNativeModal");
        const amtInput = document.getElementById("convertArkeoNativeAmount");
        const logBox = document.getElementById("convertArkeoNativeLog");
        const logRow = document.getElementById("convertArkeoNativeLogRow");
        const estBox = document.getElementById("convertArkeoNativeEst");
        if (logBox) logBox.value = "";
        if (logRow) logRow.style.display = "none";
        if (estBox) estBox.textContent = "—";
        startHotwalletLogPoll("convertArkeoNativeLog", 5000);
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (amtInput) {
            amtInput.value = "";
            amtInput.placeholder = isNaN(avail) ? "Available: 0.00000000" : `Available: ${avail.toFixed(8)}`;
        }
        if (modal) modal.classList.remove("hidden");
        setConvertArkeoNativeButtonEnabled(false);
    }

    function closeConvertArkeoModal() {
        const modal = document.getElementById("convertArkeoModal");
        if (modal) modal.classList.add("hidden");
        setConvertArkeoButtonEnabled(true);
        stopHotwalletLogPoll();
        if (convertArkeoWaitTimer) {
            clearInterval(convertArkeoWaitTimer);
            convertArkeoWaitTimer = null;
        }
    }

    function closeConvertArkeoNativeModal() {
        const modal = document.getElementById("convertArkeoNativeModal");
        if (modal) modal.classList.add("hidden");
        setConvertArkeoNativeButtonEnabled(true);
        stopHotwalletLogPoll();
        if (convertArkeoNativeWaitTimer) {
            clearInterval(convertArkeoNativeWaitTimer);
            convertArkeoNativeWaitTimer = null;
        }
    }

    function openConvertArkeoToOsmosisModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const modal = document.getElementById("convertArkeoToOsmosisModal");
        const amtInput = document.getElementById("convertArkeoToOsmosisAmount");
        const logBox = document.getElementById("convertArkeoToOsmosisLog");
        const logRow = document.getElementById("convertArkeoToOsmosisLogRow");
        const estBox = document.getElementById("convertArkeoToOsmosisEst");
        if (logBox) logBox.value = "";
        if (logRow) logRow.style.display = "none";
        if (estBox) estBox.textContent = "—";
        startHotwalletLogPoll("convertArkeoToOsmosisLog", 5000);
        const balText = document.getElementById("walletArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (amtInput) {
            amtInput.value = "";
            amtInput.placeholder = isNaN(avail) ? "Available: 0.000000" : `Available: ${avail.toFixed(6)}`;
        }
        if (modal) modal.classList.remove("hidden");
        setConvertArkeoToOsmosisButtonEnabled(false);
    }

    function closeConvertArkeoToOsmosisModal() {
        const modal = document.getElementById("convertArkeoToOsmosisModal");
        if (modal) modal.classList.add("hidden");
        setConvertArkeoToOsmosisButtonEnabled(true);
        stopHotwalletLogPoll("convertArkeoToOsmosisLog");
        if (convertArkeoToOsmosisWaitTimer) {
            clearInterval(convertArkeoToOsmosisWaitTimer);
            convertArkeoToOsmosisWaitTimer = null;
        }
    }

    async function fetchConvertQuote() {
        const estEl = document.getElementById("convertUsdcEst");
        const note = document.getElementById("convertUsdcPriceNote");
        const amtInput = document.getElementById("convertUsdcAmount");
        const amt = parseNumber(amtInput?.value);
        if (!amt || isNaN(amt) || amt <= 0) {
            if (estEl) estEl.textContent = "—";
            if (note) note.textContent = "Enter an amount to quote.";
            setConvertButtonEnabled(false);
            return;
        }
        if (note) note.textContent = "Fetching quote...";
        try {
            const resp = await fetch(apiUrl("/api/osmosis-quote-usdc-to-arkeo"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(6) }),
            });
            const data = await resp.json();
            if (!resp.ok || data.error) {
                if (estEl) estEl.textContent = "—";
                if (note) note.textContent = data?.error ? `Quote failed: ${data.error}` : "Quote failed";
                setConvertButtonEnabled(false);
                return;
            }
            convertUsdcPrice = data;
            const out = data.amount_out || 0;
            const minOut = data.min_amount_out || 0;
            if (estEl) estEl.textContent = `≈ ${Number(out).toFixed(6)} ARKEO`;
            if (note && data.slippage_bps !== undefined) {
                note.textContent = `* Min received from pool (${(data.slippage_bps / 100).toFixed(2)}% slippage): ${Number(minOut).toFixed(6)} ARKEO`;
            } else if (note) {
                note.textContent = "Quote ready";
            }
            setConvertButtonEnabled(true);
        } catch (err) {
            if (estEl) estEl.textContent = "—";
            if (note) note.textContent = `Quote failed: ${err}`;
            setConvertButtonEnabled(false);
        }
    }

    async function fetchConvertArkeoQuote() {
        const estEl = document.getElementById("convertArkeoEst");
        const note = document.getElementById("convertArkeoPriceNote");
        const amtInput = document.getElementById("convertArkeoAmount");
        const amt = parseNumber(amtInput?.value);
        if (!amt || isNaN(amt) || amt <= 0) {
            if (estEl) estEl.textContent = "—";
            if (note) note.textContent = "Enter an amount to quote.";
            setConvertArkeoButtonEnabled(false);
            return;
        }
        if (note) note.textContent = "Fetching quote...";
        try {
            const resp = await fetch(apiUrl("/api/osmosis-quote-arkeo-to-usdc"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(8) }),
            });
            const text = await resp.text();
            let data = {};
            try { data = JSON.parse(text); } catch (e) { data = { error: text || "Quote failed" }; }
            if (!resp.ok || data.error) {
                if (estEl) estEl.textContent = "—";
                if (note) note.textContent = data?.error ? `Quote failed: ${data.error}` : `Quote failed: ${text}`;
                setConvertArkeoButtonEnabled(false);
                return;
            }
            convertArkeoPrice = data;
            const out = data.amount_out || 0;
            const minOut = data.min_amount_out || 0;
            if (estEl) estEl.textContent = `≈ ${Number(out).toFixed(6)} USDC`;
            if (note && data.slippage_bps !== undefined) {
                note.textContent = `* Min received from pool (${(data.slippage_bps / 100).toFixed(2)}% slippage): ${Number(minOut).toFixed(6)} USDC`;
            } else if (note) {
                note.textContent = "Quote ready";
            }
            setConvertArkeoButtonEnabled(true);
        } catch (err) {
            if (estEl) estEl.textContent = "—";
            if (note) note.textContent = `Quote failed: ${err}`;
            setConvertArkeoButtonEnabled(false);
        }
    }

    function openRescueGasModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        clearRescuePoll();
        const modal = document.getElementById("rescueGasModal");
        const txInput = document.getElementById("rescueTxHash");
        const gasInput = document.getElementById("rescueGasAmount");
        const logBox = document.getElementById("rescueGasLog");
        if (logBox) logBox.value = "";
        if (txInput) txInput.value = "";
        if (gasInput) gasInput.value = "0.003";
        if (modal) modal.classList.remove("hidden");
        appendRescueLog("Enter the sendToken tx hash to top up Axelar gas.");
    }

    function closeRescueGasModal() {
        clearRescuePoll();
        const modal = document.getElementById("rescueGasModal");
        if (modal) modal.classList.add("hidden");
    }

    function openGmpStatusModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const modal = document.getElementById("gmpStatusModal");
        const txInput = document.getElementById("gmpStatusTxHash");
        const fromInput = document.getElementById("gmpStatusFromChain");
        const toInput = document.getElementById("gmpStatusToChain");
        const logBox = document.getElementById("gmpStatusLog");
        if (txInput) txInput.value = "";
        if (fromInput) fromInput.value = "1";
        if (toInput) toInput.value = "875";
        if (logBox) logBox.value = "";
        if (modal) modal.classList.remove("hidden");
        appendGmpLog("Enter the sendToken tx hash to check Axelar GMP status.");
    }

    function closeGmpStatusModal() {
        const modal = document.getElementById("gmpStatusModal");
        if (modal) modal.classList.add("hidden");
    }

    async function submitGmpStatus(evt) {
        evt.preventDefault();
        const txInput = document.getElementById("gmpStatusTxHash");
        const fromInput = document.getElementById("gmpStatusFromChain");
        const toInput = document.getElementById("gmpStatusToChain");
        const btn = document.getElementById("gmpStatusSubmitBtn");
        const txHash = (txInput?.value || "").trim();
        if (!/^0x[a-fA-F0-9]{64}$/.test(txHash)) {
            appendGmpLog("Enter a valid tx hash (0x...).");
            return;
        }
        if (btn) btn.disabled = true;
        appendGmpLog(`Checking GMP status for ${txHash}...`);
        try {
            const params = new URLSearchParams({ tx_hash: txHash });
            const fromVal = (fromInput?.value || "").trim();
            const toVal = (toInput?.value || "").trim();
            if (fromVal) params.set("from_chain_id", fromVal);
            if (toVal) params.set("to_chain_id", toVal);
            const resp = await fetch(apiUrl(`/api/hotwallet/gmp-status?${params.toString()}`), { cache: "no-store" });
            const data = await resp.json();
            if (!resp.ok) {
                appendGmpLog(`Status check failed: ${data.error || resp.status}`);
            } else {
                appendGmpLog(JSON.stringify(data, null, 2));
            }
        } catch (err) {
            appendGmpLog(`Error: ${err}`);
        } finally {
            if (btn) btn.disabled = false;
        }
    }

    async function submitRescueGas(evt) {
        evt.preventDefault();
        clearRescuePoll();
        const txInput = document.getElementById("rescueTxHash");
        const gasInput = document.getElementById("rescueGasAmount");
        const btn = document.getElementById("rescueGasSubmitBtn");
        const txHash = (txInput?.value || "").trim();
        const gasAmt = parseNumber(gasInput?.value);
        const errs = [];
        if (!/^0x[a-fA-F0-9]{64}$/.test(txHash)) errs.push("Enter a valid tx hash (0x...).");
        if (!gasAmt || isNaN(gasAmt) || gasAmt <= 0) errs.push("Enter gas amount in ETH > 0.");
        if (errs.length) {
            appendRescueLog(errs.join(" "));
            return;
        }
        if (btn) btn.disabled = true;
        appendRescueLog(`Topping up gas for ${txHash} with ${gasAmt.toFixed(3)} ETH...`);
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/topup-gas"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ tx_hash: txHash, gas_amount_eth: gasAmt }),
            });
            const data = await resp.json();
            if (!resp.ok) {
                const extra = data?.detail ? ` (${data.detail})` : "";
                appendRescueLog(`Rescue failed: ${data.error || resp.status}${extra}`);
                if (btn) btn.disabled = false;
                return;
            }
            appendRescueLog(`Top-up submitted. Tx: ${data.tx || "(pending)"}`);
            if (data.out) appendRescueLog(String(data.out).trim());
        } catch (err) {
            appendRescueLog(`Error: ${err}`);
        } finally {
            if (btn) btn.disabled = false;
        }
    }

    function openConvertUsdcModal(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const modal = document.getElementById("convertUsdcModal");
        const amtInput = document.getElementById("convertUsdcAmount");
        const logBox = document.getElementById("convertUsdcLog");
        const logRow = document.getElementById("convertUsdcLogRow");
        if (logBox) logBox.value = "";
        if (logRow) logRow.style.display = "none";
        startHotwalletLogPoll("convertUsdcLog", 5000);
        if (convertAutoClose) {
            clearTimeout(convertAutoClose);
            convertAutoClose = null;
        }
        const balText = document.getElementById("walletOsmoUsdcBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (amtInput) {
            amtInput.value = "";
            amtInput.placeholder = isNaN(avail) ? "Available: 0.000000" : `Available: ${avail.toFixed(6)}`;
        }
        if (modal) modal.classList.remove("hidden");
        setConvertButtonEnabled(false);
        fetchConvertQuote();
    }

    function closeConvertUsdcModal() {
        const modal = document.getElementById("convertUsdcModal");
        if (modal) modal.classList.add("hidden");
        setConvertButtonEnabled(true);
        stopHotwalletLogPoll();
        if (convertWaitTimer) {
            clearInterval(convertWaitTimer);
            convertWaitTimer = null;
        }
        if (convertAutoClose) {
            clearTimeout(convertAutoClose);
            convertAutoClose = null;
        }
    }

    async function submitConvertUsdc(evt) {
        evt.preventDefault();
        const logRow = document.getElementById("convertUsdcLogRow");
        if (logRow) logRow.style.display = "block";
        appendConvertLog("Convert Osmosis USDC to ARKEO (kept on Osmosis; no IBC).");
        const amtInput = document.getElementById("convertUsdcAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletOsmoUsdcBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const errs = [];
        if (!amt || isNaN(amt) || amt <= 0) errs.push("Enter a valid amount > 0.");
        if (!isNaN(avail) && avail >= 0 && amt > avail) errs.push(`Amount exceeds available USDC (${avail.toFixed(6)}).`);
        if (!convertUsdcPrice || !convertUsdcPrice.amount_out) errs.push("Quote not ready yet; please wait.");
        if (errs.length) {
            appendConvertLog(errs.join(" "));
            return;
        }
        setConvertButtonEnabled(false);
        // prevent double submit while in-flight
        const btn = document.getElementById("convertUsdcSubmitBtn");
        if (btn) btn.disabled = true;
        appendConvertLog(`Submitting convert of ${amt.toFixed(6)} USDC...`);
        if (convertWaitTimer) {
            clearInterval(convertWaitTimer);
            convertWaitTimer = null;
        }
        convertWaitTimer = setInterval(() => {
            appendConvertLog("Waiting for swap... still working.");
        }, 10000);
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/convert-usdc-to-arkeo"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(6) }),
            });
            const data = await resp.json();
            if (convertWaitTimer) {
                clearInterval(convertWaitTimer);
                convertWaitTimer = null;
            }
            if (!resp.ok) {
                appendConvertLog(`Convert failed: ${data.error || resp.status} ${data.detail || ""}`.trim());
                if (data.swap_tx) appendConvertLog(`Swap tx: ${data.swap_tx}`);
                if (data.raw_log) appendConvertLog(`Swap raw log: ${data.raw_log}`);
                if (data.swap_cmd) appendConvertLog(`Swap cmd: ${JSON.stringify(data.swap_cmd)}`);
                setConvertButtonEnabled(true);
                return;
            }
            if (data.swap_tx) appendConvertLog(`Swap tx: ${data.swap_tx}`);
            appendConvertLog(`Status: ${data.status || "submitted"}`);
            if (data.usdc_denom) appendConvertLog(`USDC denom: ${data.usdc_denom}`);
            if (data.arkeo_denom) appendConvertLog(`ARKEO denom: ${data.arkeo_denom}`);
            if (data.arkeo_delta !== undefined) {
                appendConvertLog(`ARKEO delta: ${Number(data.arkeo_delta/1e8).toFixed(8)} ARKEO (kept on Osmosis)`);
            }
            appendConvertLog("Swap complete on Osmosis; ARKEO remains in your Osmosis hot wallet.");
            // auto-close shortly after success
            if (!convertAutoClose) {
                convertAutoClose = setTimeout(() => {
                    closeConvertUsdcModal();
                }, 2000);
            }
            refreshHeader();
        } catch (err) {
            appendConvertLog(`Error: ${err}`);
        } finally {
            // keep disabled until modal is reopened
        }
    }

    function checkConvertArkeoAmount() {
        const amtInput = document.getElementById("convertArkeoAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const enable = amt && !isNaN(amt) && amt > 0 && (isNaN(avail) || amt <= avail);
        setConvertArkeoButtonEnabled(enable);
        debouncedConvertArkeoQuote();
    }

    function checkConvertArkeoNativeAmount() {
        const amtInput = document.getElementById("convertArkeoNativeAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const enable = amt && !isNaN(amt) && amt > 0 && (isNaN(avail) || amt <= avail);
        setConvertArkeoNativeButtonEnabled(enable);
        const estBox = document.getElementById("convertArkeoNativeEst");
        if (estBox) {
            estBox.textContent = enable ? `${amt.toFixed(8)} ARKEO` : "—";
        }
    }

    function checkConvertArkeoToOsmosisAmount() {
        const amtInput = document.getElementById("convertArkeoToOsmosisAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const enable = amt && !isNaN(amt) && amt > 0 && (isNaN(avail) || amt <= avail);
        setConvertArkeoToOsmosisButtonEnabled(enable);
        const estBox = document.getElementById("convertArkeoToOsmosisEst");
        if (estBox) {
            estBox.textContent = enable ? `${amt.toFixed(6)} ARKEO` : "—";
        }
    }

    function setConvertUsdcMax() {
        const balText = document.getElementById("walletOsmoUsdcBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const amtInput = document.getElementById("convertUsdcAmount");
        if (!isNaN(avail) && amtInput) {
            amtInput.value = avail.toFixed(6);
            debouncedConvertQuote();
        }
    }

    function setConvertArkeoMax() {
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const amtInput = document.getElementById("convertArkeoAmount");
        if (!isNaN(avail) && amtInput) {
            amtInput.value = avail.toFixed(8);
            checkConvertArkeoAmount();
        }
    }

    function setConvertArkeoNativeMax() {
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const amtInput = document.getElementById("convertArkeoNativeAmount");
        if (!isNaN(avail) && amtInput) {
            amtInput.value = avail.toFixed(8);
            checkConvertArkeoNativeAmount();
        }
    }

    function setConvertArkeoToOsmosisMax() {
        const balText = document.getElementById("walletArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const amtInput = document.getElementById("convertArkeoToOsmosisAmount");
        if (!isNaN(avail) && amtInput) {
            amtInput.value = avail.toFixed(6);
            checkConvertArkeoToOsmosisAmount();
        }
    }

    async function submitConvertArkeo(evt) {
        evt.preventDefault();
        appendConvertArkeoLog("Convert Osmosis ARKEO to USDC.");
        const amtInput = document.getElementById("convertArkeoAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const logRow = document.getElementById("convertArkeoLogRow");
        if (logRow) logRow.style.display = "block";
        const errs = [];
        if (!amt || isNaN(amt) || amt <= 0) errs.push("Enter a valid amount > 0.");
        if (!isNaN(avail) && avail >= 0 && amt > avail) errs.push(`Amount exceeds available ARKEO (${avail.toFixed(8)}).`);
        if (errs.length) {
            appendConvertArkeoLog(errs.join(" "));
            return;
        }
        setConvertArkeoButtonEnabled(false);
        const btn = document.getElementById("convertArkeoSubmitBtn");
        if (btn) btn.disabled = true;
        appendConvertArkeoLog(`Submitting convert of ${amt.toFixed(8)} ARKEO...`);
        if (convertArkeoWaitTimer) {
            clearInterval(convertArkeoWaitTimer);
            convertArkeoWaitTimer = null;
        }
        convertArkeoWaitTimer = setInterval(() => {
            appendConvertArkeoLog("Waiting for swap... still working.");
        }, 10000);
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/convert-arkeo-to-usdc"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(8) }),
            });
            const data = await resp.json();
            if (convertArkeoWaitTimer) {
                clearInterval(convertArkeoWaitTimer);
                convertArkeoWaitTimer = null;
            }
            if (!resp.ok) {
                appendConvertArkeoLog(`Convert failed: ${data.error || resp.status}`);
                if (data.swap_tx) appendConvertArkeoLog(`Swap tx: ${data.swap_tx}`);
                if (data.raw_log) appendConvertArkeoLog(`Swap raw log: ${data.raw_log}`);
                if (data.swap_cmd) appendConvertArkeoLog(`Swap cmd: ${JSON.stringify(data.swap_cmd)}`);
                setConvertArkeoButtonEnabled(true);
                if (btn) btn.disabled = false;
                return;
            }
            if (data.swap_tx) appendConvertArkeoLog(`Swap tx: ${data.swap_tx}`);
            if (data.usdc_delta !== undefined) {
                appendConvertArkeoLog(`USDC delta: ${(Number(data.usdc_delta) / 1e6).toFixed(6)} (after: ${(Number(data.usdc_after) / 1e6).toFixed(6)})`);
            }
            appendConvertArkeoLog("Swap submitted on Osmosis.");
            // auto-close after short delay
            setTimeout(() => closeConvertArkeoModal(), 2500);
            refreshHeader();
        } catch (err) {
            appendConvertArkeoLog(`Error: ${err}`);
            setConvertArkeoButtonEnabled(true);
            if (btn) btn.disabled = false;
        } finally {
            // keep disabled until modal reopen
        }
    }

    async function submitConvertArkeoToOsmosis(evt) {
        evt.preventDefault();
        const logRow = document.getElementById("convertArkeoToOsmosisLogRow");
        if (logRow) logRow.style.display = "block";
        appendConvertArkeoToOsmosisLog("IBC transfer ARKEO (native) to Osmosis (wrapped).");
        const amtInput = document.getElementById("convertArkeoToOsmosisAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const errs = [];
        if (!amt || isNaN(amt) || amt <= 0) errs.push("Enter a valid amount > 0.");
        if (!isNaN(avail) && avail >= 0 && amt > avail) errs.push(`Amount exceeds available ARKEO (${avail.toFixed(6)}).`);
        if (errs.length) {
            appendConvertArkeoToOsmosisLog(errs.join(" "));
            return;
        }
        setConvertArkeoToOsmosisButtonEnabled(false);
        appendConvertArkeoToOsmosisLog(`Submitting IBC transfer of ${amt.toFixed(6)} ARKEO...`);
        if (convertArkeoToOsmosisWaitTimer) {
            clearInterval(convertArkeoToOsmosisWaitTimer);
            convertArkeoToOsmosisWaitTimer = null;
        }
        convertArkeoToOsmosisWaitTimer = setInterval(() => {
            appendConvertArkeoToOsmosisLog("Waiting for IBC... still working.");
        }, 10000);
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/arkeo-to-osmosis"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(6) }),
            });
            const data = await resp.json();
            if (convertArkeoToOsmosisWaitTimer) {
                clearInterval(convertArkeoToOsmosisWaitTimer);
                convertArkeoToOsmosisWaitTimer = null;
            }
            if (!resp.ok) {
                appendConvertArkeoToOsmosisLog(`Convert failed: ${data.error || resp.status}`);
                if (data.ibc_tx) appendConvertArkeoToOsmosisLog(`IBC tx: ${data.ibc_tx}`);
                if (data.raw_log) appendConvertArkeoToOsmosisLog(`IBC raw log: ${data.raw_log}`);
                if (data.detail && !data.raw_log) appendConvertArkeoToOsmosisLog(`IBC detail: ${data.detail}`);
                if (data.ibc_cmd) appendConvertArkeoToOsmosisLog(`IBC cmd: ${JSON.stringify(data.ibc_cmd)}`);
                setConvertArkeoToOsmosisButtonEnabled(true);
                return;
            }
            if (data.ibc_tx) appendConvertArkeoToOsmosisLog(`IBC tx: ${data.ibc_tx}`);
            if (data.arkeo_denom) appendConvertArkeoToOsmosisLog(`Osmosis ARKEO denom: ${data.arkeo_denom}`);
            if (data.packet_sequence) {
                appendConvertArkeoToOsmosisLog(
                    `Packet seq ${data.packet_sequence} (src ${data.osmo_src_channel || "-"} -> dst ${data.arkeo_dst_channel || "-"})`
                );
            }
            if (data.tx_code !== undefined && data.tx_code !== null) {
                appendConvertArkeoToOsmosisLog(`Arkeo tx code: ${data.tx_code}`);
            }
            if (data.arrival_confirmed) {
                appendConvertArkeoToOsmosisLog("IBC complete: ARKEO arrived on Osmosis.");
                setTimeout(() => closeConvertArkeoToOsmosisModal(), 2500);
            } else {
                appendConvertArkeoToOsmosisLog("Transfer submitted. Still pending arrival on Osmosis; check status/logs for updates.");
                setTimeout(() => closeConvertArkeoToOsmosisModal(), 3000);
            }
            refreshHeader();
        } catch (err) {
            if (convertArkeoToOsmosisWaitTimer) {
                clearInterval(convertArkeoToOsmosisWaitTimer);
                convertArkeoToOsmosisWaitTimer = null;
            }
            appendConvertArkeoToOsmosisLog(`Error: ${err}`);
            setConvertArkeoToOsmosisButtonEnabled(true);
        }
    }

    async function submitConvertArkeoNative(evt) {
        evt.preventDefault();
        const logRow = document.getElementById("convertArkeoNativeLogRow");
        if (logRow) logRow.style.display = "block";
        appendConvertArkeoNativeLog("IBC transfer ARKEO (Osmosis) to native ARKEO.");
        const amtInput = document.getElementById("convertArkeoNativeAmount");
        const amt = parseNumber(amtInput?.value);
        const balText = document.getElementById("walletOsmoArkeoBalance")?.textContent || "";
        const avail = parseNumber(balText);
        const errs = [];
        if (!amt || isNaN(amt) || amt <= 0) errs.push("Enter a valid amount > 0.");
        if (!isNaN(avail) && avail >= 0 && amt > avail) errs.push(`Amount exceeds available ARKEO (${avail.toFixed(8)}).`);
        if (errs.length) {
            appendConvertArkeoNativeLog(errs.join(" "));
            return;
        }
        setConvertArkeoNativeButtonEnabled(false);
        const btn = document.getElementById("convertArkeoNativeSubmitBtn");
        if (btn) btn.disabled = true;
        appendConvertArkeoNativeLog(`Submitting IBC transfer of ${amt.toFixed(8)} ARKEO...`);
        if (convertArkeoNativeWaitTimer) {
            clearInterval(convertArkeoNativeWaitTimer);
            convertArkeoNativeWaitTimer = null;
        }
        convertArkeoNativeWaitTimer = setInterval(() => {
            appendConvertArkeoNativeLog("Waiting for IBC... still working.");
        }, 10000);
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/arkeo-to-native"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ amount: amt.toFixed(8) }),
            });
            let data = null;
            let bodyText = "";
            try {
                bodyText = await resp.text();
                if (bodyText) data = JSON.parse(bodyText);
            } catch (e) {
                data = null;
            }
            if (convertArkeoNativeWaitTimer) {
                clearInterval(convertArkeoNativeWaitTimer);
                convertArkeoNativeWaitTimer = null;
            }
            if (!resp.ok) {
                const errMsg = (data && (data.error || data.detail)) || bodyText || resp.statusText || resp.status;
                appendConvertArkeoNativeLog(`Convert failed: ${errMsg}`);
                if (data && data.ibc_tx) appendConvertArkeoNativeLog(`IBC tx: ${data.ibc_tx}`);
                if (data && data.osmo_tx) appendConvertArkeoNativeLog(`Osmosis tx: ${data.osmo_tx}`);
                if (data && data.raw_log) appendConvertArkeoNativeLog(`IBC raw log: ${data.raw_log}`);
                if (data && data.detail && !data.raw_log) appendConvertArkeoNativeLog(`IBC detail: ${data.detail}`);
                if (data && data.ibc_cmd) appendConvertArkeoNativeLog(`IBC cmd: ${JSON.stringify(data.ibc_cmd)}`);
                setConvertArkeoNativeButtonEnabled(true);
                if (btn) btn.disabled = false;
                return;
            }
            if (!data) {
                appendConvertArkeoNativeLog("Convert failed: empty response from server.");
                setConvertArkeoNativeButtonEnabled(true);
                if (btn) btn.disabled = false;
                return;
            }
            if (data.ibc_tx) appendConvertArkeoNativeLog(`IBC tx: ${data.ibc_tx}`);
            if (data.osmo_tx) appendConvertArkeoNativeLog(`Osmosis tx: ${data.osmo_tx}`);
            if (data.osmo_tx_code !== undefined) appendConvertArkeoNativeLog(`Osmosis tx code: ${data.osmo_tx_code}`);
            if (data.osmo_tx_raw_log) appendConvertArkeoNativeLog(`Osmosis raw log: ${data.osmo_tx_raw_log}`);
            if (data.packet_sequence) {
                appendConvertArkeoNativeLog(
                    `IBC packet seq=${data.packet_sequence} src=${data.osmo_src_channel || "-"} dst=${data.arkeo_dst_channel || "-"}`
                );
            } else if (data.packet_info_found === false) {
                appendConvertArkeoNativeLog("Packet info unavailable (will need to trace by tx events).");
            }
            if (data.arrival_confirmed) {
                appendConvertArkeoNativeLog("IBC complete: ARKEO arrived on native chain.");
                setTimeout(() => closeConvertArkeoNativeModal(), 2500);
            } else {
                appendConvertArkeoNativeLog("Transfer submitted. Check Status for arrival updates.");
                setTimeout(() => closeConvertArkeoNativeModal(), 3000);
            }
            refreshHeader();
        } catch (err) {
            appendConvertArkeoNativeLog(`Error: ${err}`);
            setConvertArkeoNativeButtonEnabled(true);
            if (btn) btn.disabled = false;
        } finally {
            // keep disabled until modal reopen
        }
    }
    async function pollOsmosisForArrival(targetIncrease) {
        const maxPolls = 60; // ~10-15 minutes if we adjust interval
        let polls = 0;
        appendSendUsdcLog("Watching Osmosis balance for arrival...");
        sendUsdcPollHandle = setInterval(async () => {
            polls += 1;
            try {
                const resp = await fetch(apiUrl("/api/osmosis-balance"), { cache: "no-store" });
                const data = await resp.json();
                const usdcStr = data?.usdc || data?.balance || data;
                const current = parseNumber(usdcStr);
                if (sendUsdcStartUsdc !== null && !isNaN(current)) {
                    const delta = current - sendUsdcStartUsdc;
                    appendSendUsdcLog(`Osmosis USDC: ${current.toFixed(6)} (Δ ${delta.toFixed(6)})`);
                    if (delta >= targetIncrease - 1e-6) {
                        appendSendUsdcLog("USDC detected on Osmosis. Transfer complete.");
                        clearSendUsdcPoll();
                        refreshHeader();
                        return;
                    }
                }
            } catch (err) {
                appendSendUsdcLog(`Osmosis poll error: ${err}`);
            }
            if (polls >= maxPolls) {
                appendSendUsdcLog("Stopped watching (timeout).");
                clearSendUsdcPoll();
            }
        }, 15000); // 15s cadence
    }

    async function submitSendUsdc(evt) {
        evt.preventDefault();
        clearSendUsdcPoll();
        const amtInput = document.getElementById("sendUsdcAmount");
        const gasInput = document.getElementById("sendUsdcGasAmount");
        const addFees = document.getElementById("sendUsdcAddFees");
        const btn = document.getElementById("sendUsdcSubmitBtn");
        const amt = parseNumber(amtInput?.value);
        const gasAmt = addFees?.checked ? parseNumber(gasInput?.value) : 0;
        const errs = [];
        const balText = document.getElementById("walletEthUsdcBalance")?.textContent || "";
        const avail = parseNumber(balText);
        if (!amt || isNaN(amt) || amt <= 0) errs.push("Enter a valid amount > 0.");
        if (!isNaN(avail) && avail >= 0 && amt > avail) errs.push(`Amount exceeds available USDC (${avail.toFixed(6)}).`);
        if (addFees?.checked) {
            if (!gasAmt || isNaN(gasAmt) || gasAmt <= 0) errs.push("Enter gas amount in ETH when adding fees.");
        }
        if (errs.length) {
            appendSendUsdcLog(errs.join(" "));
            return;
        }
        sendUsdcAmount = amt;
        if (btn) btn.disabled = true;
        appendSendUsdcLog(`Starting send of ${amt.toFixed(6)} USDC...`);
        // snapshot Osmosis balance before send
        try {
            const balResp = await fetch(apiUrl("/api/osmosis-balance"), { cache: "no-store" });
            const balData = await balResp.json();
            const usdcStr = balData?.usdc || balData?.balance || balData;
            const baseUsdc = parseNumber(usdcStr);
            if (!isNaN(baseUsdc)) {
                sendUsdcStartUsdc = baseUsdc;
                appendSendUsdcLog(`Starting Osmosis USDC balance: ${baseUsdc.toFixed(6)}`);
            }
        } catch (err) {
            appendSendUsdcLog(`Could not read Osmosis balance pre-send: ${err}`);
        }
        try {
            const body = { amount: amt.toFixed(6) };
            if (addFees?.checked && gasAmt > 0) {
                body.gas_amount_eth = Number(gasAmt.toFixed(6));
                appendSendUsdcLog(`Including Axelar gas payment: ${gasAmt.toFixed(6)} ETH`);
            }
            const resp = await fetch(apiUrl("/api/hotwallet/send-usdc"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await resp.json();
            if (!resp.ok) {
                appendSendUsdcLog(`Send failed: ${data.error || resp.status}`);
                if (btn) btn.disabled = false;
                return;
            }
            if (data.approve_tx) appendSendUsdcLog(`Approve tx: ${data.approve_tx}`);
            if (data.send_tx) appendSendUsdcLog(`sendToken tx: ${data.send_tx}`);
            appendSendUsdcLog("Submitted. Waiting for bridge completion...");
            refreshHeader();
            const targetIncrease = sendUsdcAmount || 0;
            if (targetIncrease > 0) {
                pollOsmosisForArrival(targetIncrease);
            }
        } catch (err) {
            appendSendUsdcLog(`Error: ${err}`);
            if (btn) btn.disabled = false;
        }
    }

    async function viewHotwalletLogs(evt) {
        if (evt && evt.stopPropagation) evt.stopPropagation();
        const btn = evt?.currentTarget;
        if (btn) btn.disabled = true;
        try {
            const resp = await fetch(apiUrl("/api/hotwallet/logs?limit=50"), { cache: "no-store" });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const entries = Array.isArray(data?.logs) ? data.logs : Array.isArray(data) ? data : [];
            if (!entries.length) {
                showResultModal("Hot Wallet Logs", "No log entries yet.");
                return;
            }
            const text = entries
                .map((e) => {
                    const ts = e?.ts || "";
                    const msg = e?.msg || e?.message || e?.action || "";
                    const stage = e?.stage ? ` [${e.stage}]` : "";
                    const swap = e?.swap_tx ? ` swap=${e.swap_tx}` : "";
                    const ibc = e?.ibc_tx ? ` ibc=${e.ibc_tx}` : "";
                    return `${ts}${stage ? " " + stage : ""}  ${msg}${swap || ""}${ibc || ""}`;
                })
                .join("\n");
            const body = `<div style="max-height:60vh;overflow:auto;"><pre style="margin:0;white-space:pre-wrap;">${escapeHtml(text)}</pre></div>`;
            showResultModal("Hot Wallet Status", body, true);
            scrollResultModalBottom();
        } catch (err) {
            showResultModal("Hot Wallet Logs", `Failed to load logs: ${err}`);
        } finally {
            if (btn) btn.disabled = false;
        }
    }

    async function copyEthAddress() {
        const val = document.getElementById("walletEthAddress")?.textContent || "";
        showCopyModal("Copy Ethereum Address", val);
    }

    async function copyOsmoAddress() {
        const val = document.getElementById("walletOsmoAddress")?.textContent || "";
        showCopyModal("Copy Osmosis Address", val);
    }

    async function copyArkeoPubkey() {
        const val = currentPubkey || document.getElementById("walletArkeoPubkey")?.textContent || "";
        showCopyModal("Copy Arkeo Pubkey", val);
    }

    function showCopyModal(title, value) {
        if (!value || value === "—" || value === "(unavailable)") {
            showResultModal(title, "Value unavailable");
            return;
        }
        showResultModal(title, value);
        try {
            navigator.clipboard.writeText(value);
        } catch (e) {
            /* noop */
        }
    }

    function setHotWalletState(open) {
        hotWalletsOpen = !!open;
        const content = document.getElementById("hotWalletContent");
        const caret = document.getElementById("hotWalletCaret");
        const btn = document.getElementById("walletToggleBtn");
        if (content) {
            content.style.display = hotWalletsOpen ? "block" : "none";
        }
        if (caret) {
            caret.textContent = hotWalletsOpen ? "▾" : "▸";
        }
        if (btn) {
            btn.classList.toggle("active", hotWalletsOpen);
            btn.setAttribute("aria-pressed", hotWalletsOpen ? "true" : "false");
        }
        const header = document.querySelector(".hotwallet-header");
        if (header) {
            header.setAttribute("aria-expanded", hotWalletsOpen ? "true" : "false");
        }
        const summary = document.getElementById("hotWalletSummary");
        if (summary) {
            summary.style.display = hotWalletsOpen ? "none" : "inline-flex";
        }
    }

    function toggleHotWallets() {
        setHotWalletState(!hotWalletsOpen);
    }

    function openHotWallets() {
        setHotWalletState(true);
    }

    function toggleHotWalletsFromButton() {
        setHotWalletState(!hotWalletsOpen);
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "0.00000000 ARKEO";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = (c.denom || c.Denom || "").toLowerCase();
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ARKEO`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(resp) {
        if (!resp || resp.error || !resp.height) return "(unavailable)";
        return resp.height.toString();
    }

    const API_PORT_DEFAULT = 9998;
    const apiPort = new URLSearchParams(window.location.search).get("api_port") || window.API_PORT || API_PORT_DEFAULT;
    const API_BASE = `${window.location.protocol}//${window.location.hostname}${apiPort ? ":" + apiPort : ""}`;
    const apiUrl = (path) => `${API_BASE}${path}`;
    let adminPasswordEnabled = false;
    let adminSessionAuthed = false;
    let portRangeGlobal = [62001, 62100];
    let portFloorGlobal = 62001;
    let serviceMenuOpen = false;
    let hotWalletsOpen = false;
    const walletEls = {
        eth: { bal: "walletEthBalance", addr: "walletEthAddress" },
        osmo: { bal: "walletOsmoBalance", addr: "walletOsmoAddress" },
        arkeo: { bal: "walletArkeoBalance", addr: "walletArkeoAddress" },
    };

    function serviceNameById(serviceId) {
        const sid = String(serviceId || "");
        if (!sid) return "";
        const hit = (serviceTypesCache || []).find((st) => String(st.service_id) === sid);
        if (!hit) return "";
        const st = hit.service_type || {};
        return st.name || st.service || hit.service_name || "";
    }

    function defaultHealthForService(serviceId) {
        const name = (serviceNameById(serviceId) || "").toLowerCase();
        const res = { method: "POST", header: "application/json", payload: "" };
        const set = (method, payload) => {
            res.method = method;
            res.payload = payload;
        };
        if (name.includes("rest")) {
            res.method = "GET";
            res.header = "application/json";
            res.payload = "/cosmos/base/tendermint/v1beta1/node_info";
        } else if (name.includes("cosmos") || name.includes("arkeo") || name.includes("gaia") || name.includes("osmosis")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"status","params":[]}');
        } else if (name.includes("btc") || name.includes("bitcoin")) {
            set("POST", '{"jsonrpc":"1.0","id":"curltext","method":"getblockcount","params":[]}');
        } else if (name.includes("polkadot") || name.startsWith("dot")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"chain_getBlockHash","params":[]}');
        } else if (name.includes("sol")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"getSlot","params":[]}');
        } else if (name.includes("sui")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"sui_getLatestCheckpointSequenceNumber","params":[]}');
        } else if (name.includes("near")) {
            set("POST", '{"jsonrpc":"2.0","id":"dontcare","method":"status","params":[]}');
        } else {
            // default EVM-ish
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}');
        }
        return res;
    }

    function requirePasswordGate() {
        sessionStorage.removeItem("adminAuthed");
        adminSessionAuthed = false;
        const gate = document.getElementById("adminPasswordGate");
        if (gate) gate.classList.remove("hidden");
    }

    const realFetch = window.fetch.bind(window);
    window.fetch = (url, options = {}) =>
        realFetch(url, { credentials: "include", ...options }).then((resp) => {
            if (resp && resp.status === 401) {
                requirePasswordGate();
            }
            return resp;
        });

    async function fetchAdminPasswordStatus(showGate = true) {
        try {
            const res = await fetch(apiUrl("/api/session"), { cache: "no-store" });
            const data = await res.json();
            adminPasswordEnabled = !!(data && data.enabled);
            adminSessionAuthed = !!(data && data.authed);
        } catch (e) {
            adminPasswordEnabled = false;
            adminSessionAuthed = false;
        }
        if (adminPasswordEnabled && !adminSessionAuthed) {
            sessionStorage.removeItem("adminAuthed");
        }
        const gate = document.getElementById("adminPasswordGate");
        const gateAuthed = sessionStorage.getItem("adminAuthed") === "1" || adminSessionAuthed;
        if (gate) {
            if (showGate && adminPasswordEnabled && !gateAuthed) {
                gate.classList.remove("hidden");
            } else {
                gate.classList.add("hidden");
            }
        }
    }

    async function submitAdminPasswordGate() {
        const input = document.getElementById("adminPasswordGateInput");
        const statusEl = document.getElementById("adminPasswordGateStatus");
        const pwd = (input && input.value) || "";
        if (statusEl) statusEl.textContent = "Verifying...";
        try {
            const res = await fetch(apiUrl("/api/login"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ password: pwd }),
            });
            const data = await res.json();
            if (data && data.ok) {
                sessionStorage.setItem("adminAuthed", "1");
                adminSessionAuthed = true;
                const gate = document.getElementById("adminPasswordGate");
                if (gate) gate.classList.add("hidden");
                if (statusEl) statusEl.textContent = "";
                window.location.reload();
            } else {
                if (statusEl) statusEl.textContent = "Incorrect password.";
            }
        } catch (e) {
            if (statusEl) statusEl.textContent = `Failed to verify: ${e}`;
        }
    }

    function escapeHtml(str) {
        if (str === undefined || str === null) return "";
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    function isTestOk(res, data) {
        if (!res || !res.ok) return false;
        if (!data || typeof data !== "object") return false;
        if (data.error) return false;
        const upCode = data.last_upstream_code;
        if (upCode !== undefined && upCode !== null) {
            const codeNum = Number(upCode);
            if (Number.isFinite(codeNum) && codeNum >= 400) return false;
        }
        if (data.response && typeof data.response === "object" && data.response.error) return false;
        return true;
    }

    async function refreshHeader() {
        try {
            const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
            const parseSafe = async (settled) => {
                if (!settled || settled.status !== "fulfilled") return { error: "request failed" };
                try {
                    if (!settled.value.ok) return { error: `${settled.value.status}` };
                    return await settled.value.json();
                } catch (err) {
                    return { error: String(err) };
                }
            };
            const [infoRes, balRes, heightRes, ethHeightRes, osmoHeightRes, walletsRes, ethBalRes, osmoBalRes, ethUsdcRes] = await Promise.allSettled([
                fetchNoStore(apiUrl("/api/subscriber-info")),
                fetchNoStore(apiUrl("/api/balance")),
                fetchNoStore(apiUrl("/api/block-height")),
                fetchNoStore(apiUrl("/api/eth-block-height")),
                fetchNoStore(apiUrl("/api/osmosis-block-height")),
                fetchNoStore(apiUrl("/api/wallets")),
                fetchNoStore(apiUrl("/api/eth-balance")),
                fetchNoStore(apiUrl("/api/osmosis-balance")),
                fetchNoStore(apiUrl("/api/eth-usdc-balance")),
            ]);
            const info = await parseSafe(infoRes);
            const bal = await parseSafe(balRes);
            const height = await parseSafe(heightRes);
            const ethHeight = await parseSafe(ethHeightRes);
            const osmoHeight = await parseSafe(osmoHeightRes);
            const wallets = await parseSafe(walletsRes);
            const ethBal = await parseSafe(ethBalRes);
            const ethUsdcBal = await parseSafe(ethUsdcRes);
            const osmoBal = await parseSafe(osmoBalRes);

            const moniker = (info && info.subscriber_name) ||
                (info && info.provider_metadata && (info.provider_metadata.MONIKER || info.provider_metadata.PROVIDER_NAME)) || "";
            const desc = "";
            const bechPub = info && info.pubkey && info.pubkey.bech32;
            currentPubkey = bechPub || "";
            currentAddress = (info && info.address) || "";

            const headerMonikerEl = document.getElementById("headerMoniker");
            const headerDescEl = document.getElementById("headerDescription");
            if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
            if (headerDescEl) headerDescEl.textContent = desc || "";
            const arkeoPubEl = document.getElementById("walletArkeoPubkey");
            if (arkeoPubEl) arkeoPubEl.textContent = currentPubkey || "—";

            const blockVal = (!height || height.error) ? "(unavailable)" : formatBlockHeight(height);
            const arkeoBalanceText = (!bal || bal.error) ? "—" : formatBalance(bal);
            const arkeoAddrText = currentAddress || "(unavailable)";
            const arkeoSummaryEl = document.getElementById("walletArkeoBalanceSummary");
            if (arkeoSummaryEl) arkeoSummaryEl.textContent = arkeoBalanceText || "—";
            const ethBlockVal = (!ethHeight || ethHeight.error) ? "(unavailable)" : (ethHeight.height || ethHeight.hex || "(unavailable)");
            const osmoBlockVal = (!osmoHeight || osmoHeight.error) ? "(unavailable)" : (osmoHeight.height || "(unavailable)");
            const ethBalanceText = (!ethBal || ethBal.error) ? "—" : (ethBal.balance || "—");
            const ethUsdcBalanceText = (!ethUsdcBal || ethUsdcBal.error) ? "—" : (ethUsdcBal.balance || "—");
            let osmoBalanceText = "—";
            let osmoUsdcBalanceText = "—";
            let osmoArkeoBalanceText = "—";
            if (osmoBal && !osmoBal.error) {
                osmoBalanceText = osmoBal.osmo || osmoBal.full || osmoBal.balance || "0.000000 OSMO";
                osmoUsdcBalanceText = osmoBal.usdc || "0.000000 USDC";
                osmoArkeoBalanceText = osmoBal.arkeo || "0.000000 ARKEO";
            }
            setOsmoGasGates(osmoBalanceText);

            // Update hot wallets (best-effort)
            const setWallet = (key, balText, addrText) => {
                const els = walletEls[key];
                if (!els) return;
                const balEl = document.getElementById(els.bal);
                const addrEl = document.getElementById(els.addr);
                if (balEl) balEl.textContent = balText || "—";
                if (addrEl) addrEl.textContent = addrText || "—";
            };
            setWallet("arkeo", arkeoBalanceText, arkeoAddrText);
            setWallet("eth", ethBalanceText, wallets?.eth_address || "(external)");
            setWallet("osmo", osmoBalanceText, wallets?.osmosis_address || "(external)");
            const ethUsdcEl = document.getElementById("walletEthUsdcBalance");
            if (ethUsdcEl) ethUsdcEl.textContent = ethUsdcBalanceText || "—";
            const osmoUsdcEl = document.getElementById("walletOsmoUsdcBalance");
            if (osmoUsdcEl) osmoUsdcEl.textContent = osmoUsdcBalanceText || "—";
            const osmoArkeoEl = document.getElementById("walletOsmoArkeoBalance");
            if (osmoArkeoEl) osmoArkeoEl.textContent = osmoArkeoBalanceText || "—";
            const osmoArkeoNum = parseNumber(osmoArkeoBalanceText);
            const arkeoBalNum = parseNumber(arkeoBalanceText);
            const arkeoToUsdcBtn = document.querySelector("button[aria-label='Convert ARKEO to USDC']");
            if (arkeoToUsdcBtn) {
                arkeoToUsdcBtn.disabled = isNaN(osmoArkeoNum) || osmoArkeoNum <= 0;
            }
            const arkeoToNativeBtn = document.querySelector("button[aria-label='Send ARKEO to Arkeo chain']");
            if (arkeoToNativeBtn) {
                arkeoToNativeBtn.disabled = isNaN(osmoArkeoNum) || osmoArkeoNum <= 0;
            }
            const arkeoToOsmoBtn = document.querySelector("button[aria-label='Send ARKEO to Osmosis']");
            if (arkeoToOsmoBtn) {
                arkeoToOsmoBtn.disabled = isNaN(arkeoBalNum) || arkeoBalNum <= 0;
            }
            const osmoUsdcNum = parseNumber(osmoUsdcBalanceText);
            const usdcToArkeoBtn = document.querySelector("button[aria-label='Convert USDC to ARKEO']");
            if (usdcToArkeoBtn) {
                usdcToArkeoBtn.disabled = isNaN(osmoUsdcNum) || osmoUsdcNum <= 0;
            }
            const ethBlock = document.getElementById("walletEthBlockBadge");
            if (ethBlock) ethBlock.textContent = ethBlockVal || "—";
            const osmoBlock = document.getElementById("walletOsmoBlockBadge");
            if (osmoBlock) osmoBlock.textContent = osmoBlockVal || "—";
            const arkeoBlockBadge = document.getElementById("walletArkeoBlockBadge");
            if (arkeoBlockBadge) arkeoBlockBadge.textContent = blockVal || "—";
        } catch (err) {
            console.error("refreshHeader failed", err);
        }

    }

    async function copyPubkeyFromHeader() {
        const val = currentPubkey || "(unavailable)";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Pubkey", "Pubkey unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Pubkey";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            showResultModal(msgTitle, `Failed to copy pubkey (clipboard may be blocked). You can copy it manually:\n${val}`);
        }
    }

    async function copyAddressFromHeader() {
        const val = currentAddress || document.getElementById("headerAddressValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Address", "Subscriber address unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Address";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Address copied (fallback):\n${val}`);
            } else {
                showResultModal(msgTitle, `Failed to copy address (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`);
            }
        }
    }

    async function refreshCache(showModal = true) {
        const statusEl = document.getElementById("cacheStatus");
        const btn = document.getElementById("cacheRefreshBtn");
        const startTs = new Date();
        const keys = [
            "Providers",
            "Contracts",
            "Services",
            "Metadata",
            "Active Providers",
            "Active Services",
            "Subscribers",
        ];
        const progressState = () => keys.map((k) => `${k}: syncing...`).join("\n");
        const startMsg = `Starting cache refresh at ${startTs.toISOString()}...\n${progressState()}\n\nPlease wait...`;
        let progressTimer = null;
        const spinner = ["|", "/", "-", "\\"];
        let spinIdx = 0;
        let refreshDone = false;
        const tickProgress = () => {
            if (refreshDone) return;
            const elapsedSec = Math.round((Date.now() - startTs.getTime()) / 1000);
            const spin = spinner[spinIdx];
            spinIdx = (spinIdx + 1) % spinner.length;
            updateModalBody(`${startMsg}\nProgress: ${spin}  Elapsed: ${elapsedSec}s`);
        };
        if (statusEl) statusEl.textContent = "Refreshing cache...";
        if (btn) btn.disabled = true;
        // keep syncing state across full refresh flow to avoid flicker
        setSyncingLocal(true);
        if (showModal) {
            showResultModal("Cache Refresh", startMsg);
            progressTimer = setInterval(tickProgress, 750);
        }
        try {
            const res = await fetch(apiUrl("/api/cache-refresh"), { method: "POST" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                const detail = (data && (data.detail || data.error)) || `${res.status}`;
                throw new Error(detail);
            }
            const results = (data && data.results) || {};
            const summarize = (key, payload) => {
                const tryParse = (val) => {
                    if (typeof val === "string") {
                        try { return JSON.parse(val); } catch (e) { return null; }
                    }
                    return val;
                };
                const pickList = (obj, candidates) => {
                    for (const c of candidates) {
                        const v = c && typeof c === "string" ? obj[c] : obj?.[c];
                        const parsed = tryParse(v);
                        if (Array.isArray(parsed)) return parsed;
                    }
                    return [];
                };
                if (!payload || typeof payload !== "object") return `${key}: (no data)`;
                let d = payload.data ?? payload;
                d = tryParse(d) ?? {};
                let items = [];
                if (Array.isArray(d)) {
                    items = d;
                } else if (typeof d === "object") {
                    if (key === "provider-services" || key === "providers" || key === "active_providers") {
                        items = pickList(d, ["providers", "provider", "result"]);
                    } else if (key === "provider-contracts" || key === "contracts") {
                        items = pickList(d, ["contracts", "contract", "result"]);
                    } else if (key === "active_services") {
                        items = pickList(d, ["active_services"]);
                    } else if (key === "metadata") {
                        const metaObj = d.metadata || d;
                        items = metaObj && typeof metaObj === "object" ? Object.keys(metaObj) : [];
                    } else if (key === "service-types" || key === "services") {
                        // handle nested under data as well
                        items = pickList(d, ["services", "service", "result"]);
                        if (!items.length && d.data) {
                            items = pickList(d.data, ["services", "service", "result"]);
                        }
                    } else if (key === "subscribers") {
                        items = pickList(d, ["subscribers"]);
                    } else {
                        items = [];
                    }
                }
                const count = Array.isArray(items) ? items.length : 0;
                if (key === "metadata") {
                    return `${key}: ${count || 0}`;
                }
                return `${key}: ${count || "(no data)"}`;
            };
            const orderedKeys = ["provider-services","provider-contracts","service-types","metadata","active_providers","active_services","subscribers"];
            const summary = orderedKeys.map(k => summarize(k, results[k])).join("\n");
            const finishedMsg = `Finished cache refresh at ${new Date().toISOString()}\n${summary || "(no results)"}\n\nSync is complete, it is ok to close this modal window now.`;
            if (statusEl) statusEl.textContent = `Last refresh: ${new Date().toLocaleString()}`;
            refreshDone = true;
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (showModal) {
                updateModalBody(finishedMsg);
            }
            // refresh header and listeners after cache refresh
            await refreshHeader();
            await loadListeners();
            // refresh active service types so the listener dropdown reflects active_service_types.json
            await refreshServiceTypes(true, null, true);
            // update metrics
            updateMetrics(results);
        } catch (err) {
            if (statusEl) statusEl.textContent = `Cache refresh failed: ${err}`;
            refreshDone = true;
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (showModal) {
                updateModalBody(`Failed to refresh cache:\n${err}`);
            }
        } finally {
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (btn) btn.disabled = false;
            setSyncingLocal(false);
        }
    }

    async function ensureSubscriberSettingsExists() {
        try {
            const res = await fetch(apiUrl("/api/subscriber-settings/exists"), { cache: "no-store" });
            const data = await res.json();
            if (data && data.exists === false) {
                window.location.href = "admin.html?needsSettings=1";
                return false;
            }
        } catch (e) {
            // ignore errors, proceed
        }
        return true;
    }

    document.addEventListener("DOMContentLoaded", async () => {
        await fetchAdminPasswordStatus(true);
        const ok = await ensureSubscriberSettingsExists();
        if (!ok) return;
        // start with hot wallets collapsed
        setHotWalletState(false);
        refreshHeader();
        // Refresh every 15 seconds to mirror provider UI behavior
        setInterval(refreshHeader, 15000);
        loadListeners();
        // Keep listener table/logs fresh for dashboard view; skip while editing to avoid clobbering form state
        setInterval(() => { if (!listenersEditingId) loadListeners(); }, 5000);
        refreshServiceTypes(false);
        // try to populate metrics from initial cache-refresh data if present
        updateMetrics();
        // poll cache status to reflect background sync
        pollSyncStatus();
        setInterval(pollSyncStatus, 5000);
        // kick off a cache refresh on load
        refreshCache(false);
    });

    function showResultModal(title, body, asHtml = false) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) {
            if (asHtml) {
                modalBody.innerHTML = body || "";
            } else {
                modalBody.textContent = body || "";
            }
        }
        if (modal) modal.classList.remove("hidden");
    }

    function scrollResultModalBottom() {
        const doScroll = () => {
            const modalBody = document.getElementById("modalBody");
            const scrollTarget =
                (modalBody && modalBody.querySelector("div[style*='overflow']")) ||
                (modalBody && modalBody.querySelector("pre")) ||
                modalBody;
            if (scrollTarget) {
                scrollTarget.scrollTop = scrollTarget.scrollHeight;
            }
        };
        setTimeout(doScroll, 50);
        setTimeout(doScroll, 150);
        setTimeout(doScroll, 300);
    }

    function updateModalBody(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.textContent = body || "";
    }

    function updateModalBodyHtml(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.innerHTML = body || "";
    }

    let syncingLocal = false;
    let syncingRemote = false;
    function updateSyncUI() {
        const pill = document.getElementById("syncPill");
        const btn = document.getElementById("cacheRefreshBtn");
        const isSyncing = syncingLocal || syncingRemote;
        if (pill) pill.classList[isSyncing ? "remove" : "add"]("hidden");
        if (btn) btn.disabled = isSyncing;
    }
    function setSyncingLocal(active) {
        syncingLocal = !!active;
        updateSyncUI();
    }
    function setSyncingRemote(active) {
        syncingRemote = !!active;
        updateSyncUI();
    }
    async function pollSyncStatus() {
        try {
            const statusRes = await fetch(apiUrl("/api/cache-status"), { cache: "no-store" });
            let wasSyncing = syncingRemote;
            if (statusRes.ok) {
                const data = await statusRes.json();
                const inProg = data && (data.in_progress === true || data.in_progress === "true");
                setSyncingRemote(!!inProg);
                // If a sync just finished, refresh service types to update dropdowns without a full reload
                if (wasSyncing && !inProg) {
                    refreshServiceTypes(true);
                }
            }
            const countsRes = await fetch(apiUrl("/api/cache-counts"), { cache: "no-store" });
            if (countsRes.ok) {
                const counts = await countsRes.json();
                // Update only the active providers, active services, and contracts counts to avoid jumping the UI
                updateMetrics(null, {
                    providers: counts.active_providers,
                    services: counts.active_services,
                    contracts: counts.contracts,
                    subscribers: counts.subscribers,
                    nodeTypes: counts.supported_chains,
                });
            }
        } catch (e) {
            // keep previous remote state on error
        }
    }

    function serviceIsActiveStatus(statusVal) {
        if (statusVal === undefined || statusVal === null) return true;
        if (typeof statusVal === "boolean") return !!statusVal;
        const s = String(statusVal).trim().toLowerCase();
        if (!s) return true;
        return ["1", "active", "online", "true", "on", "up", "running"].includes(s);
    }

    function countActiveServicesFromProviderServices(payload) {
        if (!payload || typeof payload !== "object") return null;
        const d = payload.data || payload;
        let providers = [];
        if (Array.isArray(d.providers)) providers = d.providers;
        else if (Array.isArray(d.provider)) providers = d.provider;
        let count = 0;
        for (const p of providers) {
            if (!p || typeof p !== "object") continue;
            const svcs = Array.isArray(p.services) ? p.services : Array.isArray(p.service) ? p.service : [];
            for (const s of svcs) {
                if (!s || typeof s !== "object") continue;
                const status = s.status !== undefined ? s.status : p.status;
                if (serviceIsActiveStatus(status)) count += 1;
            }
        }
        return count;
    }

    function updateMetrics(results, overrides) {
        const mProv = document.getElementById("metricProviders");
        const mSvc = document.getElementById("metricServices");
        const mCon = document.getElementById("metricContracts");
        const mSub = document.getElementById("metricSubscribers");
        const mNode = document.getElementById("metricNodeTypes");
        const getCount = (payload, keys) => {
            if (!payload || typeof payload !== "object") return null;
            const d = payload.data || payload;
            for (const k of keys) {
                const v = d[k];
                if (Array.isArray(v)) return v.length;
            }
            return null;
        };
        let activeSvcCount = null;
        if (results) {
            if ("active_services" in results) {
                const d = results["active_services"].data || results["active_services"];
                if (d && Array.isArray(d.active_services)) activeSvcCount = d.active_services.length;
            }
            if (activeSvcCount === null && "provider-services" in results) {
                const c = countActiveServicesFromProviderServices(results["provider-services"]);
                if (c !== null) activeSvcCount = c;
            }
            if (mProv && "provider-services" in results) {
                const c = getCount(results["provider-services"], ["providers", "provider"]);
                if (c !== null) mProv.textContent = c;
            }
            if (mProv && "active_providers" in results) {
                const d = results["active_providers"].data || results["active_providers"];
                if (d && Array.isArray(d.providers)) {
                    mProv.textContent = d.providers.length;
                }
            }
            if (mCon && "provider-contracts" in results) {
                const c = getCount(results["provider-contracts"], ["contracts", "contract"]);
                if (c !== null) mCon.textContent = c;
            }
            if (mSub && "subscribers" in results) {
                const d = results["subscribers"].data || results["subscribers"];
                if (d && Array.isArray(d.subscribers)) mSub.textContent = d.subscribers.length;
            }
            if (mSvc && "service-types" in results) {
                const c = getCount(results["service-types"], ["services", "service", "result", "data"]);
                if (mNode && c !== null) mNode.textContent = c;
            }
            if (mProv && "providers" in results) {
                const d = results["providers"];
                if (d && d.data && Array.isArray(d.data.providers)) {
                    mProv.textContent = d.data.providers.length;
                }
            }
        }
        if (mSvc && activeSvcCount !== null) {
            mSvc.textContent = activeSvcCount;
        }
        if (overrides) {
            if (mProv && overrides.providers !== undefined) mProv.textContent = overrides.providers;
            if (mSvc && overrides.services !== undefined) mSvc.textContent = overrides.services;
            if (mCon && overrides.contracts !== undefined) mCon.textContent = overrides.contracts;
            if (mSub && overrides.subscribers !== undefined) mSub.textContent = overrides.subscribers;
            if (mNode && overrides.nodeTypes !== undefined) mNode.textContent = overrides.nodeTypes;
        }
        if (mNode) mNode.textContent = mNode.textContent || "–";
    }
    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.classList.add("hidden");
        // Refresh listeners/service options when any modal closes to ensure latest data
        loadListeners();
        refreshServiceTypes(true);
    }

    function copyListenerEndpoint(endpoint) {
        const title = "Copy Listener Endpoint";
        const val = endpoint || "";
        if (!val || val === "–") {
            showResultModal(title, "Endpoint unavailable");
            return;
        }
        const msg = val;
        const fallbackMsg = `Failed to copy endpoint (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`;
        const doFallback = () => {
            try {
                const ta = document.createElement("textarea");
                ta.value = msg;
                document.body.appendChild(ta);
                ta.select();
                const ok = document.execCommand("copy");
                document.body.removeChild(ta);
                if (ok) {
                    showResultModal(title, `Endpoint copied:\n${val}`);
                    return;
                }
            } catch (e) {
                /* ignore */
            }
            showResultModal(title, fallbackMsg);
        };
        try {
            if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(msg).then(() => {
                    showResultModal(title, `Endpoint copied:\n${val}`);
                }).catch(() => doFallback());
            } else {
                doFallback();
            }
        } catch (e) {
            doFallback();
        }
    }

    // ─────────────────────────────
    // Listener registry UI helpers
    // ─────────────────────────────
    let listenersEditingId = null;
    let listenersCache = [];
    let serviceTypesCache = [];
    let providersByServiceCache = {};
    let providersFetchInFlight = {};
    let lastServiceTypesFetch = 0;

    function serviceOptionsHtml(selectedId) {
        const opts = serviceTypesCache.map((s) => {
            const sid = s && (s.service_id ?? s.serviceID ?? s.id);
            if (sid === undefined || sid === null) return "";
            const label = formatServiceLabel(sid);
            const count = s && s.count !== undefined ? ` (${s.count} Active)` : "";
            const sel = String(selectedId || "") === String(sid) ? "selected" : "";
            return `<option value="${escapeHtml(String(sid))}" ${sel}>${escapeHtml(label + count)}</option>`;
        }).filter(Boolean).join("");
        return `<option value="">Select a service</option>${opts}`;
    }

    function updateSelectOptionsFromCache(selectEl) {
        if (!selectEl) return;
        const current = selectEl.value;
        selectEl.innerHTML = serviceOptionsHtml(current);
        if (current) selectEl.value = current;
    }

    async function refreshServiceTypes(rerenderTable = false, selectIdToUpdate = null, force = false) {
        const now = Date.now();
        const freshWindowMs = 5000;
        if (!force && now - lastServiceTypesFetch < freshWindowMs) {
            if (selectIdToUpdate) updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
            if (rerenderTable && !listenersEditingId) renderListenersTable();
            return;
        }
        try {
            const res = await fetch(apiUrl("/api/active-service-types"), { cache: "no-store" });
            if (!res.ok) return;
            const svcData = await res.json().catch(() => ({}));
            const list = svcData && svcData.active_service_types;
            if (Array.isArray(list)) {
                serviceTypesCache = list;
                lastServiceTypesFetch = Date.now();
                populateServiceSelect();
                if (selectIdToUpdate) {
                    updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
                }
                if (rerenderTable && !listenersEditingId) {
                    renderListenersTable();
                }
            }
        } catch (e) {
            // ignore fetch errors; will retry on next trigger
        }
    }

    async function loadListeners() {
        try {
            const res = await fetch(apiUrl("/api/listeners"), { cache: "no-store" });
            const data = await res.json();
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersCache = Array.isArray(data.listeners) ? data.listeners : [];
            const nextPort = data.next_port || "n/a";
            const npEl = document.getElementById("nextPortValue");
            if (npEl) npEl.textContent = nextPort;
            if (Array.isArray(data.port_range) && data.port_range.length === 2) {
                portRangeGlobal = data.port_range;
            }
            if (data.port_floor) {
                portFloorGlobal = data.port_floor;
            } else if (Array.isArray(portRangeGlobal) && portRangeGlobal.length === 2) {
                portFloorGlobal = portRangeGlobal[0];
            }
            const rangeEl = document.getElementById("listenerRange");
            if (rangeEl && Array.isArray(data.port_range) && data.port_range.length === 2) {
                rangeEl.textContent = `Ports ${data.port_range[0]}-${data.port_range[1]}`;
            }
            populatePortStartSelect();
            renderListenersTable();
            renderListenerLogs();
            if (!serviceTypesCache.length) {
                refreshServiceTypes(true);
            }
        } catch (err) {
            renderListenersTable(`Failed to load listeners: ${err}`);
        }
    }

    function populatePortStartSelect() {
        const sel = document.getElementById("portStartSelect");
        if (!sel) return;
        const [min, max] = Array.isArray(portRangeGlobal) && portRangeGlobal.length === 2 ? portRangeGlobal : [62001, 62100];
        const floor = portFloorGlobal || min;
        let opts = "";
        for (let p = min; p <= max; p++) {
            opts += `<option value="${p}" ${p === floor ? "selected" : ""}>${p}</option>`;
        }
        sel.innerHTML = opts;
        sel.value = String(floor);
    }

    async function handlePortStartChange() {
        const sel = document.getElementById("portStartSelect");
        if (!sel) return;
        const val = parseInt(sel.value, 10);
        if (Number.isNaN(val)) return;
        sel.disabled = true;
        try {
            const res = await fetch(apiUrl("/api/listener-port-start"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ start_port: val }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.statusText || res.status);
            }
            if (data.port_floor) {
                portFloorGlobal = data.port_floor;
            }
            if (Array.isArray(data.port_range) && data.port_range.length === 2) {
                portRangeGlobal = data.port_range;
            }
            await loadListeners();
        } catch (e) {
            alert(`Failed to set start port: ${e}`);
            populatePortStartSelect();
        } finally {
            sel.disabled = false;
        }
    }

    let openListenerId = null;

    function renderListenersTable(errorText) {
        const container = document.getElementById("listenersTable");
        if (!container) return;
        if (errorText) {
            container.innerHTML = `<div class="muted">${escapeHtml(errorText)}</div>`;
            return;
        }
        if (!listenersCache.length) {
            container.innerHTML = `<div class="muted">No listeners yet. Add one to auto-assign the next open port.</div>`;
            return;
        }
        const rows = listenersCache.map((l) => {
            const isEditing = listenersEditingId === String(l.id);
            const isOpen = isEditing || openListenerId === String(l.id);
            const targetSafe = escapeHtml(l.target || "");
            const portSafe = escapeHtml(l.port ?? "");
            const statusSafe = escapeHtml(l.status || "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id);
            const svcSelect = `<div class="muted">
                <div>${escapeHtml(svcLabel || "—")}</div>
                <div class="muted small">Service type cannot be changed after creation.</div>
                <input type="hidden" id="editService-${l.id}" value="${escapeHtml(l.service_id || "")}">
            </div>`;
            const statusSelect = buildStatusSelect(l.status, `editStatus-${l.id}`);
            const topServices = dedupTopServices(Array.isArray(l.top_services) ? l.top_services : []);
            const whitelist = l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)";
            const hostForListener = window.location.hostname || "localhost";
            const protoForListener = (window.location.protocol || "").startsWith("https") ? "https" : "http";
            const endpointUrl = portSafe ? `${protoForListener}://${hostForListener}:${portSafe}` : "–";
            let topServicesDisplay;
            if (isEditing) {
                const rows = topServices.length ? topServices.map((bp, idx) => {
                        const mon = bp && bp.provider_moniker;
                        const fallbackName = mon || l.provider_moniker || (bp && bp.provider_pubkey) || "(unknown)";
                        const inactive = (!mon && !l.provider_moniker) || fallbackName === "(Inactive)";
                        const name = fallbackName;
                        const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                            ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                            : "";
                        const actions = isEditing
                            ? `<div class="top-service-actions" style="display:flex;gap:6px;flex-wrap:nowrap;">
                                    <button class="copy-btn" ${idx === 0 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, -1)">↑</button>
                                    <button class="copy-btn" ${idx === topServices.length - 1 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, 1)">↓</button>
                                    <button class="copy-btn danger-btn" onclick="removeTopService('${l.id}', ${idx})">✕</button>
                               </div>`
                            : "";
                        const statusVal = bp && bp.status ? String(bp.status) : "";
                        const statusDot = statusVal.toLowerCase() === "up"
                            ? '<span class="status-dot dot-ok"></span>'
                            : statusVal.toLowerCase() === "down"
                                ? '<span class="status-dot dot-err"></span>'
                                : "—";
                        let rtDisplay = "—";
                        if (bp && bp.rt_avg_ms !== undefined && bp.rt_avg_ms !== null) {
                            const avgMs = Number(bp.rt_avg_ms);
                            if (!Number.isNaN(avgMs)) {
                                rtDisplay = `${Math.round(avgMs)} ms`;
                            }
                        }
                        return `<tr>
                            <td class="ts-col-num"><span class="muted small" style="color:#fff; font-weight:700;">${idx + 1}</span></td>
                            <td class="ts-col-name"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(name)}${inactive ? " (Inactive)" : ""}</span></td>
                            <td class="ts-col-rate"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rate)}</span></td>
                            <td class="ts-col-status">${statusDot}</td>
                            <td class="ts-col-rt"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rtDisplay)}</span></td>
                            ${isEditing ? `<td class="ts-col-actions">${actions}</td>` : ""}
                        </tr>`;
                    }).join("") : `<tr><td colspan="6" class="muted small">No providers yet.</td></tr>`;
                const head = `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th><th></th></tr>`;
                const svcForTop = l.service_id || l.service;
                const selectId = `addTopSvc-${l.id}`;
                const cached = svcForTop ? providersByServiceCache[String(svcForTop)] : undefined;
                const excludePks = topServices.map((ts) => ts?.provider_pubkey || ts?.pubkey || "");
                if (svcForTop && cached === undefined) {
                    ensureProvidersForService(svcForTop, l.id);
                }
                const hasCache = cached !== undefined;
                const addControls = svcForTop
                    ? (() => {
                        const hasList = cached && Array.isArray(cached) && cached.length;
                        if (!hasCache) {
                            return `<div class="muted small">Loading providers for this service...</div>`;
                        }
                        if (!hasList) {
                            return `<div class="muted small">No active providers found for this service.</div>`;
                        }
                        // even if all filtered out, still show disabled select/button so user sees the state
                        const selectHtml = providerSelectHtml(svcForTop, selectId, excludePks);
                        return `<div class="top-service-add-row" style="display:flex;align-items:center;gap:10px;padding:8px;margin-top:8px;">
                                    ${selectHtml}
                                    <button class="primary" style="white-space:nowrap;" onclick="addTopService('${l.id}', '${selectId}')">Add provider</button>
                                </div>`;
                    })()
                    : `<div class="muted small">Select a service to add providers.</div>`;
                topServicesDisplay = `<div class="top-services-table-wrap">
                            <table class="top-services-table">
                                <thead>${head}</thead>
                                <tbody>${rows}</tbody>
                            </table>
                            ${addControls}
                        </div>`;
            } else {
                topServicesDisplay = topServices.length
                    ? (() => {
                        const rows = topServices.map((bp, idx) => {
                            const mon = bp && bp.provider_moniker;
                            const fallbackName = mon || l.provider_moniker || (bp && bp.provider_pubkey) || "(unknown)";
                            const inactive = (!mon && !l.provider_moniker) || fallbackName === "(Inactive)";
                            const name = fallbackName;
                            const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                                ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                                : "";
                            const actions = "";
                            const statusVal = bp && bp.status ? String(bp.status) : "";
                            const statusDot = statusVal.toLowerCase() === "up"
                                ? '<span class="status-dot dot-ok"></span>'
                                : statusVal.toLowerCase() === "down"
                                    ? '<span class="status-dot dot-err"></span>'
                                    : "—";
                            let rtDisplay = "—";
                            if (bp && bp.rt_avg_ms !== undefined && bp.rt_avg_ms !== null) {
                                const avgMs = Number(bp.rt_avg_ms);
                                if (!Number.isNaN(avgMs)) {
                                    rtDisplay = `${Math.round(avgMs)} ms`;
                                }
                            }
                            return `<tr>
                                <td class="ts-col-num"><span class="muted small" style="color:#fff; font-weight:700;">${idx + 1}</span></td>
                                <td class="ts-col-name"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(name)}${inactive ? " (Inactive)" : ""}</span></td>
                                <td class="ts-col-rate"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rate)}</span></td>
                                <td class="ts-col-status">${statusDot}</td>
                                <td class="ts-col-rt"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rtDisplay)}</span></td>
                            </tr>`;
                        }).join("");
                        const head = `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th></tr>`;
                        return `<table class="top-services-table">
                            <thead>${head}</thead>
                            <tbody>${rows}</tbody>
                        </table>`;
                    })()
                    : "—";
            }
            if (isEditing) {
                return `
                <tbody class="listener-block" id="listener-${l.id}">
                <tr class="listener-main">
                    <td class="col-status">${statusSelect}</td>
                    <td>
                        ${svcSelect}
                    </td>
                    <td class="mono">${portSafe || "–"}</td>
                    <td class="listener-actions-cell col-actions">
                        <div class="actions align-right" style="display:flex;gap:8px;flex-wrap:nowrap;justify-content:flex-end;">
                            <button onclick="cancelEditListener()">Cancel</button>
                            <button class="primary" onclick="saveListener('${l.id}')">Save</button>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                    <div class="muted small" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:start;">
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Endpoint:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${escapeHtml(endpointUrl)}</strong></span> ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}</div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Whitelist IPs:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)"}</strong></span></div>
                        </div>
                    </div>
                        <div class="muted small" style="margin-top:8px;">Polling Options</div>
                        <div class="muted small" style="display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap;">
                            <label class="inline" style="gap:4px;">
                                <select id="editHealthMethod-${l.id}" class="select" style="width:auto;">
                                    <option value="POST" ${String(l.health_method || "POST").toUpperCase() === "POST" ? "selected" : ""}>POST</option>
                                    <option value="GET" ${String(l.health_method || "POST").toUpperCase() === "GET" ? "selected" : ""}>GET</option>
                                </select>
                            </label>
                            <label class="inline" style="gap:4px;">
                                <select id="editHealthHeader-${l.id}" class="select" style="width:auto;">
                                    <option value="">(no header)</option>
                                    <option value="application/json" ${String(l.health_header || "application/json").toLowerCase() === "application/json" ? "selected" : ""}>Content-Type: application/json</option>
                                    <option value="application/x-www-form-urlencoded" ${String(l.health_header || "").toLowerCase() === "application/x-www-form-urlencoded" ? "selected" : ""}>Content-Type: application/x-www-form-urlencoded</option>
                                    <option value="text/plain" ${String(l.health_header || "").toLowerCase() === "text/plain" ? "selected" : ""}>Content-Type: text/plain</option>
                                    <option value="application/octet-stream" ${String(l.health_header || "").toLowerCase() === "application/octet-stream" ? "selected" : ""}>Content-Type: application/octet-stream</option>
                                </select>
                            </label>
                            <div style="flex:1; min-width:200px;">
                                <textarea id="editHealthPayload-${l.id}" rows="2" class="full-input" placeholder="Payload for POST or URL/path for GET">${escapeHtml(l.health_payload || "")}</textarea>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small">Top services:</div>
                        <div class="muted">${topServicesDisplay}</div>
                    </td>
                </tr>
                <tr class="listener-spacer"><td colspan="4"></td></tr>
                </tbody>`;
            }
            const statusDot = `<span class="status-dot ${String(l.status).toLowerCase() === "active" ? "dot-ok" : "dot-err"}"></span>`;
            const caret = isOpen ? "▾" : "▸";
            return `
            <tbody class="listener-block ${isOpen ? "open" : "closed"}" id="listener-${l.id}">
            <tr class="listener-main" onclick="toggleListenerOpen('${l.id}')">
                <td class="col-status" style="vertical-align: middle;"><span class="muted small" style="font-size:20px; display:inline-block; width:20px; color: #ffffff; line-height:1;">${caret}</span> ${statusDot}</td>
                <td>${escapeHtml(svcLabel || "—")}</td>
                <td class="mono">${portSafe || "–"}</td>
                <td class="listener-actions-cell col-actions">
                    <button class="btn-ghost" onclick="event.stopPropagation(); pollListener('${l.id}')">Poll</button>
                    <button class="btn-ghost" onclick="event.stopPropagation(); testListener('${l.id}')">Test</button>
                    <button class="btn-ghost" onclick="event.stopPropagation(); statusListener('${l.id}')">Status</button>
                    <button class="primary" onclick="event.stopPropagation(); editListener('${l.id}')">Edit</button>
                    <button class="primary danger-btn" onclick="event.stopPropagation(); deleteListener('${l.id}')">Delete</button>
                </td>
            </tr>
            ${isOpen ? `
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:start;">
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Endpoint:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${escapeHtml(endpointUrl)}</strong></span> ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}</div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Whitelist IPs:</div>
                            <div class="muted small"><span class="mono" style="color:#fff;"><strong>${whitelist}</strong></span></div>
                        </div>
                    </div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small" style="padding-bottom:4px;">Polling Options:</div>
                    <div class="muted small"><span style="color:#fff;"><strong>
                        Method: ${escapeHtml((l.health_method || "POST").toString().toUpperCase())}
                        | Content-Type: ${escapeHtml(l.health_header || "(none)")}
                        | Payload/URL: ${escapeHtml(l.health_payload || "(default)")}
                    </strong></span></div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Top services:</div>
                    <div class="muted">${topServicesDisplay}</div>
                </td>
            </tr>
            <tr class="listener-spacer"><td colspan="4"></td></tr>` : ""}
            ${!isOpen ? `<tr class="listener-spacer"><td colspan="4"></td></tr>` : ""}
            </tbody>`;
        }).join("");
        container.innerHTML = `<div class="table-wrap">
            <table class="table listeners-table">
                <thead>
                    <tr><th class="col-status">Status</th><th>Service Type</th><th>Port</th><th class="col-actions">Actions</th></tr>
                </thead>
                <tbody>${rows}</tbody>
            </table>
        </div>`;
    }

    function resetListenerForm() {
        const svc = document.getElementById("listenerService");
        if (svc) svc.value = "";
    }

    async function submitListenerForm(evt) {
        evt.preventDefault();
        const svcId = document.getElementById("listenerService")?.value || "";
        if (!svcId) {
            alert("Please select a service type before adding a listener.");
            return;
        }
        const svcName = (serviceNameById(svcId) || "").toLowerCase();
        const body = {
            status: "active",
            whitelist_ips: "",
            health_method: "POST",
            health_payload: "",
            health_header: "application/json",
        };
        if (svcName.includes("cosmos") || svcName.includes("arkeo") || svcName.includes("gaia") || svcName.includes("osmosis")) {
            body.health_method = "POST";
            body.health_header = "application/json";
            body.health_payload = '{"jsonrpc":"2.0","id":1,"method":"status","params":[]}';
        }
        if (svcId) body.service_id = svcId;
        try {
            const res = await fetch(apiUrl("/api/listeners"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            const newId = data && data.listener && data.listener.id ? String(data.listener.id) : null;
            resetListenerForm();
            listenersEditingId = null;
            if (newId) {
                openListenerId = newId; // ensure the new listener drawer opens
            }
            await loadListeners();
            if (newId) {
                const elId = `listener-${newId}`;
                // wait for DOM render
                setTimeout(() => {
                    const el = document.getElementById(elId);
                    if (el && typeof el.scrollIntoView === "function") {
                        el.scrollIntoView({ behavior: "smooth", block: "start" });
                    }
                }, 50);
            }
        } catch (err) {
            showResultModal("Add Listener", `Failed to add listener: ${err}`);
        }
    }

    function editListener(id) {
        listenersEditingId = String(id);
        const l = listenersCache.find((x) => String(x.id) === String(id));
        const svc = l ? (l.service_id || l.service) : null;
        if (svc) ensureProvidersForService(svc, id);
        renderListenersTable();
    }

    function cancelEditListener() {
        listenersEditingId = null;
        renderListenersTable();
    }

    function toggleListenerOpen(id) {
        if (listenersEditingId && listenersEditingId === String(id)) return; // keep edit open
        if (openListenerId === String(id)) {
            openListenerId = null;
        } else {
            openListenerId = String(id);
        }
        renderListenersTable();
    }

    async function saveListener(id) {
        const svcIdInput = document.getElementById(`editService-${id}`);
        const svcId = (svcIdInput && svcIdInput.value) || "";
        const status = document.getElementById(`editStatus-${id}`)?.value || "";
        const whitelist = document.getElementById(`editWhitelist-${id}`)?.value || "";
        const current = listenersCache.find((l) => String(l.id) === String(id));
        const body = {
            status,
            whitelist_ips: whitelist,
            health_method: document.getElementById(`editHealthMethod-${id}`)?.value || "",
            health_payload: document.getElementById(`editHealthPayload-${id}`)?.value || "",
            health_header: document.getElementById(`editHealthHeader-${id}`)?.value || "",
        };
        if (svcId) {
            body.service_id = svcId;
        } else if (current && current.service_id) {
            body.service_id = current.service_id;
        }
        if (current && Array.isArray(current.top_services)) {
            body.top_services = current.top_services;
        }
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Update Listener", `Failed to update listener: ${err}`);
        }
    }

    function moveTopService(listenerId, idx, delta) {
        const l = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!l || !Array.isArray(l.top_services)) return;
        const newIdx = idx + delta;
        if (newIdx < 0 || newIdx >= l.top_services.length) return;
        const arr = [...l.top_services];
        const [item] = arr.splice(idx, 1);
        arr.splice(newIdx, 0, item);
        l.top_services = arr;
        renderListenersTable();
    }

    async function addTopService(listenerId, selectId) {
        const listener = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!listener) return;
        const svcId = listener.service_id || listener.service;
        if (!svcId) {
            alert("Select a service type before adding providers.");
            return;
        }
        const sid = String(svcId);
        if (!providersByServiceCache[sid]) {
            await ensureProvidersForService(sid, listenerId);
        }
        const selectEl = document.getElementById(selectId);
        const selectedPk = (selectEl && selectEl.value) || "";
        if (!selectedPk) {
            alert("Choose a provider to add.");
            return;
        }
        const existing = Array.isArray(listener.top_services) ? listener.top_services : [];
        const already = existing.some(
            (ts) => String(ts?.provider_pubkey || ts?.pubkey || "") === String(selectedPk)
        );
        if (already) {
            alert("That provider is already in this list.");
            return;
        }
        const choices = providersByServiceCache[sid] || [];
        const match = choices.find((p) => String(p?.provider_pubkey || p?.pubkey || "") === String(selectedPk));
        if (!match) {
            alert("Provider not found for this service.");
            return;
        }
        const entry = {
            provider_pubkey: selectedPk,
            service_id: sid,
        };
        const moniker = match.provider_moniker || match?.provider?.moniker;
        if (moniker) entry.provider_moniker = moniker;
        if (match.sentinel_url) entry.sentinel_url = match.sentinel_url;
        if (match.metadata_uri) entry.metadata_uri = match.metadata_uri;
        if (match.pay_as_you_go_rate) entry.pay_as_you_go_rate = match.pay_as_you_go_rate;
        if (match.queries_per_minute !== undefined) entry.queries_per_minute = match.queries_per_minute;
        if (match.min_contract_duration !== undefined) entry.min_contract_duration = match.min_contract_duration;
        if (match.max_contract_duration !== undefined) entry.max_contract_duration = match.max_contract_duration;
        if (match.settlement_duration !== undefined) entry.settlement_duration = match.settlement_duration;
        const top = Array.isArray(listener.top_services) ? [...listener.top_services] : [];
        top.push(entry);
        listener.top_services = dedupTopServices(top);
        renderListenersTable();
    }

    function removeTopService(listenerId, idx) {
        const l = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!l || !Array.isArray(l.top_services)) return;
        const arr = [...l.top_services];
        if (idx < 0 || idx >= arr.length) return;
        arr.splice(idx, 1);
        l.top_services = arr;
        renderListenersTable();
    }

    async function deleteListener(id) {
        if (!confirm("Delete this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "DELETE",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Delete Listener", `Failed to delete listener: ${err}`);
        }
    }

    // ─────────────────────────────
    // Listener logs
    // ─────────────────────────────
    function scrollLogToBottom(pre) {
        if (!pre) return;
        pre.scrollTop = pre.scrollHeight;
    }

    async function fetchListenerLog(id, elId) {
        const pre = document.getElementById(elId);
        if (pre) pre.textContent = "Loading log...";
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/logs?lines=200`), { cache: "no-store" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (pre) pre.textContent = data && data.error ? `Error: ${data.error}` : `Error: ${res.status}`;
                scrollLogToBottom(pre);
                return;
            }
            const log = data && data.log ? data.log : "(no log)";
            if (pre) pre.textContent = log || "(no log)";
            scrollLogToBottom(pre);
        } catch (e) {
            if (pre) pre.textContent = `Error: ${e}`;
            scrollLogToBottom(pre);
        }
    }

    function renderListenerLogs() {
        const container = document.getElementById("listenerLogs");
        if (!container) return;
        if (!listenersCache.length) {
            container.innerHTML = "";
            return;
        }
        const cards = listenersCache.map((l) => {
            const portSafe = escapeHtml(l.port ?? "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id) || "";
            const logId = `log-${l.id}`;
            return `
            <div class="log-card">
                <div class="row-between" style="align-items: center;">
                    <h4>Port ${portSafe || "–"} ${svcLabel ? `| ${escapeHtml(svcLabel)}` : ""}</h4>
                    <div class="log-actions">
                        <button class="primary" onclick="fetchListenerLog('${l.id}', '${logId}')">Refresh</button>
                    </div>
            </div>
            <pre id="${logId}" class="log-pre">(loading...)</pre>
        </div>`;
        }).join("");
        container.innerHTML = cards;
        listenersCache.forEach((l) => fetchListenerLog(l.id, `log-${l.id}`));
    }

    async function runListenerTests(id, runs = 1, titlePrefix, refreshAfter = false) {
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const port = listener && listener.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        const header = `
<div>${escapeHtml(titlePrefix || "Testing")} listener (${runs} runs)...</div>
<div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
        let summaryHtml = `<div class="muted small">Please wait...</div>`;
        let logText = "";
        const logContainer = () => document.getElementById("testLogPre");
        const summaryContainer = () => document.getElementById("testSummary");
        const appendLog = (line) => {
            logText = logText ? `${logText}\n${line}` : line;
            const pre = logContainer();
            if (pre) {
                pre.textContent = logText;
                pre.scrollTop = pre.scrollHeight;
            }
        };
        // open modal shell first
        showResultModal("Test Listener", "", true);
        const renderShell = () => {
            const shell = `${header}<div id="testSummary" class="muted small">${summaryHtml}</div><pre id="testLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(shell);
        };
        renderShell();
        const results = [];
        const successes = [];
        const failures = [];
        for (let i = 1; i <= runs; i++) {
            appendLog(`Run ${i}/${runs}: sending test request...`);
            try {
                const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), {
                    method: "GET",
                    cache: "no-store",
                });
                const data = await res.json().catch(() => ({}));
                const cmd = data && data.command ? data.command : "";
                const ok = isTestOk(res, data);
                const err = ok ? null : (data && (data.detail || data.error)) || res.statusText || res.status;
                let resp = data && data.response;
                let respPretty = resp || "(no data)";
                try {
                    if (typeof resp === "string") {
                        respPretty = JSON.stringify(JSON.parse(resp), null, 2);
                    } else if (resp && typeof resp === "object") {
                        respPretty = JSON.stringify(resp, null, 2);
                    }
                } catch (e) {
                    respPretty = resp || "(no data)";
                }
                results.push({
                    idx: i,
                    cmd,
                    err,
                    respPretty,
                    sentinel: data && data.sentinel_url,
                    provider: data && data.provider_pubkey,
                    providerMon: data && data.provider_moniker,
                    serviceId: data && data.service_id,
                    serviceName: data && data.service_name,
                    sentinelTarget: data && data.sentinel_target,
                    candidateSentinel: data && data.candidate_sentinel,
                    candidateProvider: data && data.candidate_provider,
                    lastCode: data && data.last_code,
                    lastNonce: data && data.last_nonce,
                    lastNonceSource: data && data.last_nonce_source,
                    lastNonceCache: data && data.last_nonce_cache,
                    lastCandProvider: data && data.last_candidate_provider,
                    lastCandSentinel: data && data.last_candidate_sentinel,
                    arkeoNonce: data && data.arkeo_nonce,
                    arkeoContractId: data && data.arkeo_contract_id,
                    arkeoCost: data && data.arkeo_cost,
                    respHeaders: data && data.response_headers,
                    nonceCached: data && data.nonce_cached,
                    nonceCacheKey: data && data.nonce_cache_key,
                    lastUpstreamBody: data && data.last_upstream_body,
                    requestUrl: data && data.request_url,
                    requestMethod: data && data.request_method,
                    requestHeaders: data && data.request_headers,
                    requestBody: data && data.request_body,
                });
                if (err) {
                    failures.push(i);
                } else {
                    successes.push(i);
                }
            } catch (e) {
                results.push({
                    idx: i,
                    cmd: "",
                    err: String(e),
                    respPretty: "(no data)",
                });
                failures.push(i);
            }
            const metaLines = [];
            const last = results[results.length - 1] || {};
            if (last.health_method) metaLines.push(`Method: ${last.health_method}`);
            if (last.health_header) metaLines.push(`Content-Type: ${last.health_header}`);
            if (last.health_payload) metaLines.push(`Payload/URL: ${last.health_payload}`);
            if (last.health_url_example) metaLines.push(`Target: ${last.health_url_example}`);
            if (last.requestUrl) metaLines.push(`Request URL: ${last.requestUrl}`);
            if (last.requestMethod) metaLines.push(`Request Method: ${last.requestMethod}`);
            if (last.requestBody) metaLines.push(`Request Body: ${last.requestBody}`);
            const sentinelDisplay = last.candidateSentinel || last.lastCandSentinel || last.sentinel_target || last.sentinel;
            if (sentinelDisplay) {
                metaLines.push(`Sentinel: ${sentinelDisplay}`);
            }
            const providerDisplay = last.provider || last.candidateProvider || last.lastCandProvider;
            const providerMonDisplay = last.providerMon;
            if (providerDisplay) metaLines.push(`Provider: ${providerDisplay}${providerMonDisplay ? ` (${providerMonDisplay})` : ""}`);
            if (last.health_method) metaLines.push(`Method: ${last.health_method}`);
            if (last.health_header) metaLines.push(`Content-Type: ${last.health_header}`);
            if (last.health_payload) metaLines.push(`Payload/URL: ${last.health_payload}`);
            if (last.health_url_example) metaLines.push(`Target: ${last.health_url_example}`);
            if (last.serviceId || last.serviceName) {
                metaLines.push(`Service: ${last.serviceName || ""}${last.serviceId ? ` [${last.serviceId}]` : ""}`);
            }
            if (last.lastNonce !== undefined && last.lastNonce !== null) {
                metaLines.push(`Last nonce used: ${last.lastNonce}`);
            }
            if (last.lastNonceSource) {
                metaLines.push(`Nonce source: ${last.lastNonceSource}${last.lastNonceCache !== undefined && last.lastNonceCache !== null ? ` (cache now ${last.lastNonceCache})` : ""}`);
            }
            if (last.arkeoNonce) {
                metaLines.push(`Nonce (from response): ${last.arkeoNonce}`);
            }
            if (last.nonceCached !== undefined && last.nonceCached !== null) {
                metaLines.push(`Nonce cache: ${last.nonceCached}${last.nonceCacheKey ? ` [${last.nonceCacheKey}]` : ""}`);
            }
            if (last.lastCode !== undefined && last.lastCode !== null) {
                metaLines.push(`Last upstream code: ${last.lastCode}`);
            }
            if (last.lastUpstreamBody) {
                metaLines.push(`Upstream body: ${last.lastUpstreamBody}`);
            }
            if (last.last_upstream_url) {
                metaLines.push(`Upstream URL: ${last.last_upstream_url}`);
            }
            if (last.last_upstream_headers) {
                metaLines.push(`Upstream Headers: ${JSON.stringify(last.last_upstream_headers)}`);
            }
            if (last.activeContractId) {
                metaLines.push(`Active contract: ${last.activeContractId}${last.activeContractHeight ? ` @height ${last.activeContractHeight}` : ""}`);
                if (last.activeContractProvider) {
                    metaLines.push(`Contract provider: ${last.activeContractProvider}`);
                }
                if (last.activeContractService) {
                    metaLines.push(`Contract service: ${last.activeContractService}`);
                }
            }
            if (last.arkeoContractId) {
                metaLines.push(`Contract (from response): ${last.arkeoContractId}`);
            }
            if (last.arkeoCost) {
                metaLines.push(`Cost (from response): ${last.arkeoCost}`);
            }
            const metaText = metaLines.length ? metaLines.join("\n") + "\n" : "";
            const block = [
                `--- Run ${i} ---`,
                `Command: ${results[results.length - 1].cmd || ""}`,
                metaText ? metaText.trimEnd() : null,
                results[results.length - 1].err ? `Error: ${results[results.length - 1].err}` : `Response:\n${results[results.length - 1].respPretty}`
            ].filter(Boolean).join("\n");
            appendLog(block);
            summaryHtml = `<div class="muted small">Success: ${successes.length ? successes.join(", ") : "0"} | Failed: ${failures.length ? failures.join(", ") : "0"}</div>`;
        }
        // Final summary update
        const summaryEl = summaryContainer();
        if (summaryEl) summaryEl.innerHTML = `<div class="muted small">Test complete.</div>${summaryHtml}`;
        appendLog("All test runs finished.");
        if (refreshAfter) {
            await loadListeners();
        }
    }

    function dedupTopServices(list) {
        const seen = new Set();
        const out = [];
        for (const item of Array.isArray(list) ? list : []) {
            const key = `${item?.provider_pubkey || ""}::${item?.service_id || item?.service || ""}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(item);
        }
        return out;
    }

    function providerOptionLabel(p) {
        const pk = p?.provider_pubkey || p?.pubkey || "";
        const mon = p?.provider_moniker
            || p?.provider?.moniker
            || (p?.metadata && p.metadata.config && p.metadata.config.moniker)
            || (p?.metadata && p.metadata.moniker);
        if (mon) return mon;
        return pk ? formatPubkeyShort(pk) : "(unknown)";
    }

    async function ensureProvidersForService(serviceId, listenerId = null) {
        const sid = String(serviceId || "").trim();
        if (!sid) return [];
        if (providersByServiceCache[sid]) return providersByServiceCache[sid];
        if (providersFetchInFlight[sid]) return providersFetchInFlight[sid];
        providersFetchInFlight[sid] = fetch(apiUrl(`/api/services/${encodeURIComponent(sid)}/providers`), { cache: "no-store" })
            .then(res => res.json().catch(() => ({})))
            .then((data) => {
                const list = Array.isArray(data.providers) ? data.providers : [];
                providersByServiceCache[sid] = list;
                delete providersFetchInFlight[sid];
                if (listenerId && listenersEditingId === String(listenerId)) {
                    renderListenersTable();
                }
                return list;
            })
            .catch(() => {
                providersByServiceCache[sid] = [];
                delete providersFetchInFlight[sid];
                if (listenerId && listenersEditingId === String(listenerId)) {
                    renderListenersTable();
                }
                return [];
            });
        return providersFetchInFlight[sid];
    }

    function providerSelectHtml(serviceId, selectId, excludePks = []) {
        const sid = String(serviceId || "");
        const list = providersByServiceCache[sid];
        if (!sid) {
            return `<select id="${selectId}" class="select" disabled><option value="">Select a service first</option></select>`;
        }
        if (!list) {
            return `<select id="${selectId}" class="select" disabled><option value="">Loading providers...</option></select>`;
        }
        const excludeSet = new Set((excludePks || []).map((x) => String(x || "")));
        const filtered = list.filter((p) => {
            const pk = p?.provider_pubkey || p?.pubkey || "";
            if (!pk) return false;
            return !excludeSet.has(String(pk));
        });
        if (!filtered.length) {
            return `<select id="${selectId}" class="select" disabled><option value="">All providers already added</option></select>`;
        }
        const opts = filtered.map((p) => {
            const pk = p?.provider_pubkey || p?.pubkey || "";
            if (!pk) return "";
            const label = providerOptionLabel(p);
            return `<option value="${escapeHtml(pk)}">${escapeHtml(label)}</option>`;
        }).filter(Boolean).join("");
        return `<select id="${selectId}" class="select"><option value="">Select provider</option>${opts}</select>`;
    }

    async function testListener(id) {
        openListenerId = String(id);
        await runListenerTests(id, 1, "Testing", true);
    }

    async function statusListener(id) {
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const port = listener && listener.port ? listener.port : null;
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        if (!port) {
            showResultModal("Listener Status", "Port unavailable for this listener.");
            return;
        }
        openListenerId = String(id);
        // ensure drawer is open for context
        if (typeof renderListenersTable === "function") {
            renderListenersTable();
        }
        const proto = window.location.protocol || "http:";
        const host = window.location.hostname || "localhost";
        const url = `${proto}//${host}:${port}/arkeostatus`;
        const header = `<div>Status for listener</div><div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div><div class="muted small">URL: ${escapeHtml(url)}</div>`;
        showResultModal("Listener Status", "", true);
        updateModalBodyHtml(`${header}<pre id="statusPre" class="mono" style="max-height:50vh;overflow:auto;">(loading...)</pre>`);
        try {
            const res = await fetch(url, { cache: "no-store" });
            const data = await res.json().catch(() => ({}));
            const pre = document.getElementById("statusPre");
            const pretty = JSON.stringify(data, null, 2);
            if (pre) {
                pre.textContent = pretty;
            } else {
                updateModalBodyHtml(`${header}<pre class="mono" style="max-height:50vh;overflow:auto;">${escapeHtml(pretty)}</pre>`);
            }
        } catch (e) {
            const pre = document.getElementById("statusPre");
            const msg = `Failed to fetch status:\n${e}`;
            if (pre) pre.textContent = msg;
            else updateModalBodyHtml(`${header}<pre class="mono" style="max-height:50vh;overflow:auto;">${escapeHtml(msg)}</pre>`);
        }
    }

    async function pollListener(id) {
        openListenerId = String(id);
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const top = listener && Array.isArray(listener.top_services) ? dedupTopServices(listener.top_services) : [];
        const successMap = {};
        // modal shell
        const port = listener?.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        let pollLogText = "";
        const logEl = () => document.getElementById("pollLogPre");
        const summaryEl = () => document.getElementById("pollSummary");
        const renderPollShell = (summaryText = "Starting poll...") => {
            const header = `<div>Polling listener...</div><div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
            const body = `${header}<div id="pollSummary" class="muted small">${escapeHtml(summaryText)}</div><pre id="pollLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(body);
        };
        const appendPollLog = (line, newline = true) => {
            const suffix = newline ? "\n" : "";
            pollLogText = pollLogText ? `${pollLogText}${line}${suffix}` : `${line}${suffix}`;
            const pre = logEl();
            if (pre) {
                pre.textContent = pollLogText.trimEnd();
                pre.scrollTop = pre.scrollHeight;
            }
        };
        showResultModal("Poll Listener", "", true);
        renderPollShell();
        if (!top.length) {
            appendPollLog("No providers to poll; running a single test instead.");
            await testListener(id);
            return;
        }
            const primary = top[0] || {};
            const inferredSvc = listener?.service_id || listener?.service || primary.service_id || primary.service || "";
            const defaults = defaultHealthForService(inferredSvc);
            const basePayload = {
                status: "active",
                service_id: inferredSvc,
                whitelist_ips: listener?.whitelist_ips || "",
                health_method: defaults.method,
                health_payload: defaults.payload,
                health_header: defaults.header,
            };
            let workingTop = dedupTopServices(JSON.parse(JSON.stringify(top)));
            for (const ts of workingTop) {
                const providerLabel = ts?.provider_moniker || "(unknown)";
                appendPollLog(`Provider: ${providerLabel}`);
                // reorder so this provider is first
                const reordered = dedupTopServices([ts, ...workingTop.filter((t) => {
                    const keyT = `${t?.provider_pubkey || ""}::${t?.service_id || t?.service || ""}`;
                    const keyTs = `${ts?.provider_pubkey || ""}::${ts?.service_id || ts?.service || ""}`;
                    return keyT !== keyTs;
                })]);
                try {
                    await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ ...basePayload, top_services: reordered }),
                    });
                    appendPollLog("  Performing tests and polling data...");
                } catch (e) {
                    // ignore reorder errors, proceed
                    appendPollLog(`  reorder failed: ${e}`);
                }
                // run a few tests for this provider, respecting qpm if present
                const qpm = ts && ts.queries_per_minute ? Number(ts.queries_per_minute) : 0;
                const spacingMs = qpm > 0 ? Math.max(200, Math.round(60000 / qpm)) : 400;
                const runs = 3;
                let allOk = true;
                for (let i = 0; i < runs; i++) {
                    try {
                        const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), { method: "GET", cache: "no-store" });
                        const data = await res.json().catch(() => ({}));
                        const ok = isTestOk(res, data);
                        if (!ok) allOk = false;
                        const err = !ok ? (data && (data.detail || data.error)) || res.statusText || res.status : "";
                        appendPollLog(`  Test ${i + 1}/${runs}: ${ok ? "OK" : `Error ${err}`}`);
                    } catch (e) {
                        appendPollLog(`  Test ${i + 1}/${runs}: Error ${e}`);
                        allOk = false;
                    }
                    await new Promise(res => setTimeout(res, spacingMs));
                }
                if (allOk && ts && ts.provider_pubkey) {
                    successMap[String(ts.provider_pubkey)] = true;
                }
                await loadListeners();
                const refreshed = listenersCache.find((l) => String(l.id) === String(id));
                if (refreshed && Array.isArray(refreshed.top_services)) {
                    workingTop = dedupTopServices(JSON.parse(JSON.stringify(refreshed.top_services)));
                }
                appendPollLog(""); // blank line between providers
            }
        // sort by cheapest then lowest latency using the freshest cache after polling
        const latest = listenersCache.find((l) => String(l.id) === String(id));
        let latestTop = dedupTopServices(latest && Array.isArray(latest.top_services) ? latest.top_services : []);
        // Promote status to Up for providers that passed all tests
        if (latestTop.length && Object.keys(successMap).length) {
            latestTop = latestTop.map((ts) => {
                const pk = String(ts?.provider_pubkey || "");
                if (pk && successMap[pk]) {
                    return { ...ts, status: "Up" };
                }
                return ts;
            });
        }
        const sorted = [...latestTop].sort((a, b) => {
            const statusScore = (x) => {
                const s = String(x?.status || "").toLowerCase();
                if (s === "up") return 0;
                if (s === "down") return 2;
                return 1; // unknown
            };
            const price = (x) => {
                const amt = x?.pay_as_you_go_rate?.amount;
                const n = parseInt(amt, 10);
                return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
            };
            const rt = (x) => {
                const n = Number(x?.rt_avg_ms);
                return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
            };

            const sA = statusScore(a);
            const sB = statusScore(b);
            if (sA !== sB) return sA - sB; // Up first, Down last

            const pA = price(a);
            const pB = price(b);
            if (pA !== pB) return pA - pB; // lower price first

            const rtA = rt(a);
            const rtB = rt(b);
            return rtA - rtB; // faster first
        });
        try {
            await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...basePayload, top_services: sorted }),
            });
            appendPollLog("Sorted providers by price then latency and saved.\n\nPolling and sorting complete.");
        } catch (e) {
            /* ignore */
            appendPollLog(`Failed to save sorted providers: ${e}`);
        }
        await loadListeners();
        const summary = summaryEl();
        if (summary) summary.innerHTML = `Poll complete.`;
    }

    async function refreshTopServices(id) {
        if (!confirm("Refresh top services and check for new ones for this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/refresh-top-services`), {
                method: "POST",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            await loadListeners();
        } catch (err) {
            showResultModal("Refresh Top Services", `Failed to refresh: ${err}`);
        }
    }

    function formatServiceLabel(serviceId) {
        if (!serviceId) return "";
        const sid = String(serviceId);
        const match = serviceTypesCache.find((s) => String(s.service_id) === sid);
        if (!match || !match.service_type) return sid;
        const st = match.service_type;
        const desc = st.description || "";
        const name = st.name || "";
        if (desc) return desc;
        return name || sid;
    }

    function serviceOptionLabel(stItem) {
        if (!stItem) return "";
        const st = stItem.service_type || {};
        return st.description || st.name || stItem.service_name || stItem.service_id || "";
    }

    function renderServiceOptions(filterText = "") {
        const optionsEl = document.getElementById("svcComboOptions");
        const hiddenSelect = document.getElementById("listenerService");
        if (!optionsEl || !hiddenSelect) return;
        const filter = filterText.toLowerCase();
        let html = "";
        hiddenSelect.innerHTML = `<option value="">Select a service</option>`;
        (serviceTypesCache || []).forEach((item) => {
            const label = serviceOptionLabel(item);
            const sid = item.service_id;
            if (filter && !label.toLowerCase().includes(filter) && !String(sid).includes(filter)) return;
            html += `<div class="combo-option" data-id="${sid}" onclick="selectServiceOption('${sid}')">${escapeHtml(label)}</div>`;
            const opt = document.createElement("option");
            opt.value = sid;
            opt.textContent = label;
            hiddenSelect.appendChild(opt);
        });
        optionsEl.innerHTML = html || `<div class="combo-option muted">No matches</div>`;
    }

    function selectServiceOption(serviceId) {
        const hiddenSelect = document.getElementById("listenerService");
        const display = document.getElementById("svcComboSelected");
        if (hiddenSelect) {
            hiddenSelect.value = serviceId || "";
        }
        const label = formatServiceLabel(serviceId) || serviceId || "Select a service";
        if (display) display.textContent = label;
        closeServiceMenu();
    }

    function toggleServiceMenu(e) {
        e?.stopPropagation();
        const menu = document.getElementById("svcComboMenu");
        if (!menu) return;
        if (menu.classList.contains("hidden")) {
            openServiceMenu();
        } else {
            closeServiceMenu();
        }
    }

    function openServiceMenu() {
        const menu = document.getElementById("svcComboMenu");
        const search = document.getElementById("svcComboSearch");
        if (menu) menu.classList.remove("hidden");
        serviceMenuOpen = true;
        renderServiceOptions(search ? search.value : "");
        if (search) {
            search.value = "";
            search.focus();
        }
        document.addEventListener("click", handleOutsideServiceMenu, { once: true });
    }

    function closeServiceMenu() {
        const menu = document.getElementById("svcComboMenu");
        if (menu) menu.classList.add("hidden");
        serviceMenuOpen = false;
    }

    function handleOutsideServiceMenu(evt) {
        if (!serviceMenuOpen) return;
        const menu = document.getElementById("svcComboMenu");
        const display = document.getElementById("svcComboDisplay");
        if (!menu || !display) return;
        if (menu.contains(evt.target) || display.contains(evt.target)) {
            document.addEventListener("click", handleOutsideServiceMenu, { once: true });
            return;
        }
        closeServiceMenu();
    }

    function filterServiceOptions() {
        const search = document.getElementById("svcComboSearch");
        renderServiceOptions(search ? search.value : "");
    }

    function populateServiceSelect() {
        renderServiceOptions("");
        const first = serviceTypesCache && serviceTypesCache[0] ? serviceTypesCache[0].service_id : "";
        if (first) {
            selectServiceOption(first);
        }
    }

    function buildStatusSelect(selectedVal, elementId) {
        const opts = [
            { value: "active", label: "Active" },
            { value: "inactive", label: "Inactive" },
        ];
        const inner = opts.map(o => {
            const sel = String(selectedVal || "active").toLowerCase() === o.value ? "selected" : "";
            return `<option value="${o.value}" ${sel}>${o.label}</option>`;
        }).join("");
        return `<select id="${elementId || ""}" class="select">${inner}</select>`;
    }

    function refreshServiceTypesForSelect(selectId) {
        refreshServiceTypes(false, selectId);
    }

    document.addEventListener("focusin", (e) => {
        const sel = e.target.closest(".service-select");
        if (sel && sel.id) {
            refreshServiceTypesForSelect(sel.id);
        }
    });

</script>

</body>
</html>
