<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Data Marketplace | Subscriber Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>
<div class="page">

<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Data Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Subscriber Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
            <div class="header-right header-right-with-actions">
                <div class="header-actions">
                    <a class="icon-btn" href="admin.html" title="Open Admin Area" aria-label="Open Admin Area">
                        <svg viewBox="0 0 24 24" aria-hidden="true" focusable="false">
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M12.0002 8C9.79111 8 8.00024 9.79086 8.00024 12C8.00024 14.2091 9.79111 16 12.0002 16C14.2094 16 16.0002 14.2091 16.0002 12C16.0002 9.79086 14.2094 8 12.0002 8ZM10.0002 12C10.0002 10.8954 10.8957 10 12.0002 10C13.1048 10 14.0002 10.8954 14.0002 12C14.0002 13.1046 13.1048 14 12.0002 14C10.8957 14 10.0002 13.1046 10.0002 12Z"></path>
                            <path fill-rule="evenodd" clip-rule="evenodd" d="M11.2867 0.5C9.88583 0.5 8.6461 1.46745 8.37171 2.85605L8.29264 3.25622C8.10489 4.20638 7.06195 4.83059 6.04511 4.48813L5.64825 4.35447C4.32246 3.90796 2.83873 4.42968 2.11836 5.63933L1.40492 6.83735C0.67773 8.05846 0.954349 9.60487 2.03927 10.5142L2.35714 10.7806C3.12939 11.4279 3.12939 12.5721 2.35714 13.2194L2.03927 13.4858C0.954349 14.3951 0.67773 15.9415 1.40492 17.1626L2.11833 18.3606C2.83872 19.5703 4.3225 20.092 5.64831 19.6455L6.04506 19.5118C7.06191 19.1693 8.1049 19.7935 8.29264 20.7437L8.37172 21.1439C8.6461 22.5325 9.88584 23.5 11.2867 23.5H12.7136C14.1146 23.5 15.3543 22.5325 15.6287 21.1438L15.7077 20.7438C15.8954 19.7936 16.9384 19.1693 17.9553 19.5118L18.3521 19.6455C19.6779 20.092 21.1617 19.5703 21.8821 18.3606L22.5955 17.1627C23.3227 15.9416 23.046 14.3951 21.9611 13.4858L21.6432 13.2194C20.8709 12.5722 20.8709 11.4278 21.6432 10.7806L21.9611 10.5142C23.046 9.60489 23.3227 8.05845 22.5955 6.83732L21.8821 5.63932C21.1617 4.42968 19.678 3.90795 18.3522 4.35444L17.9552 4.48814C16.9384 4.83059 15.8954 4.20634 15.7077 3.25617L15.6287 2.85616C15.3543 1.46751 14.1146 0.5 12.7136 0.5H11.2867ZM10.3338 3.24375C10.4149 2.83334 10.7983 2.5 11.2867 2.5H12.7136C13.2021 2.5 13.5855 2.83336 13.6666 3.24378L13.7456 3.64379C14.1791 5.83811 16.4909 7.09167 18.5935 6.38353L18.9905 6.24984C19.4495 6.09527 19.9394 6.28595 20.1637 6.66264L20.8771 7.86064C21.0946 8.22587 21.0208 8.69271 20.6764 8.98135L20.3586 9.24773C18.6325 10.6943 18.6325 13.3057 20.3586 14.7523L20.6764 15.0186C21.0208 15.3073 21.0946 15.7741 20.8771 16.1394L20.1637 17.3373C19.9394 17.714 19.4495 17.9047 18.9905 17.7501L18.5936 17.6164C16.4909 16.9082 14.1791 18.1618 13.7456 20.3562L13.6666 20.7562C13.5855 21.1666 13.2021 21.5 12.7136 21.5H11.2867C10.7983 21.5 10.4149 21.1667 10.3338 20.7562L10.2547 20.356C9.82113 18.1617 7.50931 16.9082 5.40665 17.6165L5.0099 17.7501C4.55092 17.9047 4.06104 17.714 3.83671 17.3373L3.1233 16.1393C2.9058 15.7741 2.97959 15.3073 3.32398 15.0186L3.64185 14.7522C5.36782 13.3056 5.36781 10.6944 3.64185 9.24779L3.32398 8.98137C2.97959 8.69273 2.9058 8.2259 3.1233 7.86067L3.83674 6.66266C4.06106 6.28596 4.55093 6.09528 5.0099 6.24986L5.40676 6.38352C7.50938 7.09166 9.82112 5.83819 10.2547 3.64392L10.3338 3.24375Z"></path>
                        </svg>
                    </a>
                </div>
                <div class="header-line" id="headerPubkey">
                    <strong>Subscriber Pubkey:</strong>
                    <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerAddress">
                <strong>Subscriber Address:</strong>
                <span class="inline">
                    <span id="headerAddressValue"></span>
                    <button class="copy-btn" onclick="copyAddressFromHeader()">Copy</button>
                </span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Subscriber Balance:</strong></div>
            <div class="header-line muted" id="headerBlock"><strong>Current Block:</strong></div>
            <div class="header-line fixed-pill"><span id="syncPill" class="status-badge status-warn hidden">Syncing...</span></div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Arkeo Data Marketplace</h2>
    <div class="metrics-grid header-metrics">
        <div class="metric-card">
            <div class="metric-label">Active Providers</div>
            <div class="metric-value" id="metricProviders">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Active Services</div>
            <div class="metric-value" id="metricServices">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Contracts</div>
            <div class="metric-value" id="metricContracts">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Subscribers</div>
            <div class="metric-value" id="metricSubscribers">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Supported Chains</div>
            <div class="metric-value" id="metricNodeTypes">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-value"><button class="primary block-btn" id="cacheRefreshBtn" onclick="refreshCache()">Refresh</button></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="row-between row-align-end">
        <div>
            <h2>Arkeo Subscriber Listeners</h2>
        </div>
        <div class="text-right">
            <div class="muted" id="listenerRange">Ports 62001-62100</div>
            <div class="muted small" style="margin-top:4px;">
                Start port:
                <select id="portStartSelect" class="select" style="width:auto; padding:2px 6px; min-width:90px;" onchange="handlePortStartChange()">
                    <option>62001</option>
                </select>
            </div>
            <div class="muted small">Next available port: <span id="nextPortValue">–</span></div>
        </div>
    </div>
    <form id="listenerForm" class="listener-form" onsubmit="submitListenerForm(event)">
        <div class="listener-grid" style="grid-template-columns: 1fr auto; align-items: end; gap: 12px;">
            <label style="width:100%;">
                <div class="muted">Service Type</div>
                <div class="muted small">Choose a provider service to bind to a listener.</div>
                <div class="combo-select">
                    <div id="svcComboDisplay" class="combo-display" onclick="toggleServiceMenu(event)">
                        <span id="svcComboSelected">Select a service</span>
                        <span class="combo-caret">▾</span>
                    </div>
                    <div id="svcComboMenu" class="combo-menu hidden">
                        <input type="text" id="svcComboSearch" class="full combo-search" placeholder="Search services..." oninput="filterServiceOptions()" autocomplete="off" autocorrect="off" spellcheck="false" />
                        <div id="svcComboOptions" class="combo-options"></div>
                    </div>
                    <select id="listenerService" class="hidden" aria-hidden="true" tabindex="-1"></select>
                </div>
            </label>
            <div class="listener-actions" style="align-self:flex-end; white-space: nowrap;">
                <button type="submit" class="primary">Add Listener</button>
            </div>
        </div>
    </form>
<div id="listenersTable" class="mt-2"></div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div id="listenerLogs" class="section log-container"></div>

</div> <!-- /page -->

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <div id="modalBody" class="modal-body"></div>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<div id="adminPasswordGate" class="overlay overlay-strong hidden">
    <div class="overlay-card password-card">
        <div class="password-title">
            <span>Arkeo Data Marketplace</span>
            <span class="sep">|</span>
            <span class="sub highlight">Subscriber Manager</span>
        </div>
        <form onsubmit="submitAdminPasswordGate(); return false;">
            <div class="password-body password-panel">
                <h3 class="mt-6 mb-0">Password Required</h3>
                <p class="muted">Enter the admin password to continue.</p>
                <input type="text" name="admin-username-filler" autocomplete="username" value="admin" class="hidden" aria-hidden="true" tabindex="-1" />
                <input type="password" id="adminPasswordGateInput" autocomplete="current-password" placeholder="Admin password" />
            </div>
            <div class="actions center password-actions">
                <button class="primary" type="submit">Unlock</button>
            </div>
            <div id="adminPasswordGateStatus" class="muted mt-6"></div>
        </form>
    </div>
</div>

<script>
    let currentPubkey = "";
    let currentAddress = "";

    function formatPubkeyShort(pubkey) {
        if (!pubkey || pubkey.length < 12) return pubkey || "";
        // Show first 10 and last 8 for a bit more context
        return `${pubkey.slice(0, 9)}...${pubkey.slice(-8)}`;
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "0.00000000 uarkeo";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ${denom}`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(resp) {
        if (!resp || resp.error || !resp.height) return "(unavailable)";
        return resp.height.toString();
    }

    const API_PORT_DEFAULT = 9998;
    const apiPort = new URLSearchParams(window.location.search).get("api_port") || window.API_PORT || API_PORT_DEFAULT;
    const API_BASE = `${window.location.protocol}//${window.location.hostname}${apiPort ? ":" + apiPort : ""}`;
    const apiUrl = (path) => `${API_BASE}${path}`;
    let adminPasswordEnabled = false;
    let adminSessionAuthed = false;
    let portRangeGlobal = [62001, 62100];
    let portFloorGlobal = 62001;
    let serviceMenuOpen = false;

    function serviceNameById(serviceId) {
        const sid = String(serviceId || "");
        if (!sid) return "";
        const hit = (serviceTypesCache || []).find((st) => String(st.service_id) === sid);
        if (!hit) return "";
        const st = hit.service_type || {};
        return st.name || st.service || hit.service_name || "";
    }

    function defaultHealthForService(serviceId) {
        const name = (serviceNameById(serviceId) || "").toLowerCase();
        const res = { method: "POST", header: "application/json", payload: "" };
        const set = (method, payload) => {
            res.method = method;
            res.payload = payload;
        };
        if (name.includes("rest")) {
            res.method = "GET";
            res.header = "application/json";
            res.payload = "/cosmos/base/tendermint/v1beta1/node_info";
        } else if (name.includes("cosmos") || name.includes("arkeo") || name.includes("gaia") || name.includes("osmosis")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"status","params":[]}');
        } else if (name.includes("btc") || name.includes("bitcoin")) {
            set("POST", '{"jsonrpc":"1.0","id":"curltext","method":"getblockcount","params":[]}');
        } else if (name.includes("polkadot") || name.startsWith("dot")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"chain_getBlockHash","params":[]}');
        } else if (name.includes("sol")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"getSlot","params":[]}');
        } else if (name.includes("sui")) {
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"sui_getLatestCheckpointSequenceNumber","params":[]}');
        } else if (name.includes("near")) {
            set("POST", '{"jsonrpc":"2.0","id":"dontcare","method":"status","params":[]}');
        } else {
            // default EVM-ish
            set("POST", '{"jsonrpc":"2.0","id":1,"method":"eth_blockNumber","params":[]}');
        }
        return res;
    }

    function requirePasswordGate() {
        sessionStorage.removeItem("adminAuthed");
        adminSessionAuthed = false;
        const gate = document.getElementById("adminPasswordGate");
        if (gate) gate.classList.remove("hidden");
    }

    const realFetch = window.fetch.bind(window);
    window.fetch = (url, options = {}) =>
        realFetch(url, { credentials: "include", ...options }).then((resp) => {
            if (resp && resp.status === 401) {
                requirePasswordGate();
            }
            return resp;
        });

    async function fetchAdminPasswordStatus(showGate = true) {
        try {
            const res = await fetch(apiUrl("/api/session"), { cache: "no-store" });
            const data = await res.json();
            adminPasswordEnabled = !!(data && data.enabled);
            adminSessionAuthed = !!(data && data.authed);
        } catch (e) {
            adminPasswordEnabled = false;
            adminSessionAuthed = false;
        }
        if (adminPasswordEnabled && !adminSessionAuthed) {
            sessionStorage.removeItem("adminAuthed");
        }
        const gate = document.getElementById("adminPasswordGate");
        const gateAuthed = sessionStorage.getItem("adminAuthed") === "1" || adminSessionAuthed;
        if (gate) {
            if (showGate && adminPasswordEnabled && !gateAuthed) {
                gate.classList.remove("hidden");
            } else {
                gate.classList.add("hidden");
            }
        }
    }

    async function submitAdminPasswordGate() {
        const input = document.getElementById("adminPasswordGateInput");
        const statusEl = document.getElementById("adminPasswordGateStatus");
        const pwd = (input && input.value) || "";
        if (statusEl) statusEl.textContent = "Verifying...";
        try {
            const res = await fetch(apiUrl("/api/login"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ password: pwd }),
            });
            const data = await res.json();
            if (data && data.ok) {
                sessionStorage.setItem("adminAuthed", "1");
                adminSessionAuthed = true;
                const gate = document.getElementById("adminPasswordGate");
                if (gate) gate.classList.add("hidden");
                if (statusEl) statusEl.textContent = "";
                window.location.reload();
            } else {
                if (statusEl) statusEl.textContent = "Incorrect password.";
            }
        } catch (e) {
            if (statusEl) statusEl.textContent = `Failed to verify: ${e}`;
        }
    }

    function escapeHtml(str) {
        if (str === undefined || str === null) return "";
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    function isTestOk(res, data) {
        if (!res || !res.ok) return false;
        if (!data || typeof data !== "object") return false;
        if (data.error) return false;
        const upCode = data.last_upstream_code;
        if (upCode !== undefined && upCode !== null) {
            const codeNum = Number(upCode);
            if (Number.isFinite(codeNum) && codeNum >= 400) return false;
        }
        if (data.response && typeof data.response === "object" && data.response.error) return false;
        return true;
    }

    async function refreshHeader() {
        const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
        const parseSafe = async (settled) => {
            if (!settled || settled.status !== "fulfilled") return { error: "request failed" };
            try {
                if (!settled.value.ok) return { error: `${settled.value.status}` };
                return await settled.value.json();
            } catch (err) {
                return { error: String(err) };
            }
        };
            const [infoRes, balRes, heightRes] = await Promise.allSettled([
            fetchNoStore(apiUrl("/api/subscriber-info")),
            fetchNoStore(apiUrl("/api/balance")),
            fetchNoStore(apiUrl("/api/block-height")),
        ]);
        const info = await parseSafe(infoRes);
        const bal = await parseSafe(balRes);
        const height = await parseSafe(heightRes);

        const moniker = (info && info.subscriber_name) ||
            (info && info.provider_metadata && (info.provider_metadata.MONIKER || info.provider_metadata.PROVIDER_NAME)) || "";
        const desc = "";
        const bechPub = info && info.pubkey && info.pubkey.bech32;
        currentPubkey = bechPub || "";
        currentAddress = (info && info.address) || "";

        const headerMonikerEl = document.getElementById("headerMoniker");
        const headerDescEl = document.getElementById("headerDescription");
        const headerPubVal = document.getElementById("headerPubkeyValue");
        const headerAddrEl = document.getElementById("headerAddress");
        const headerBalEl = document.getElementById("headerBalance");
        const headerBlockEl = document.getElementById("headerBlock");

        if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
        if (headerDescEl) headerDescEl.textContent = desc || "";
        if (headerPubVal) headerPubVal.textContent = bechPub ? formatPubkeyShort(bechPub) : "(unavailable)";
        if (headerAddrEl) {
            const addrVal = currentAddress || "(unavailable)";
            const addrSpan = document.getElementById("headerAddressValue");
            if (addrSpan) addrSpan.textContent = formatAddressShort(addrVal);
        }
        if (headerBalEl) headerBalEl.innerHTML = `<strong>Subscriber Balance:</strong> ${formatBalance(bal)}`;
        if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${formatBlockHeight(height)}`;

    }

    async function copyPubkeyFromHeader() {
        const val = currentPubkey || document.getElementById("headerPubkeyValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Pubkey", "Pubkey unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Pubkey";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            // fallback for non-HTTPS contexts
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Pubkey copied (fallback):\n${val}`);
            } else {
                showResultModal(msgTitle, `Failed to copy pubkey (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`);
            }
        }
    }

    async function copyAddressFromHeader() {
        const val = currentAddress || document.getElementById("headerAddressValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Address", "Subscriber address unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Address";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Address copied (fallback):\n${val}`);
            } else {
                showResultModal(msgTitle, `Failed to copy address (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`);
            }
        }
    }

    async function refreshCache(showModal = true) {
        const statusEl = document.getElementById("cacheStatus");
        const btn = document.getElementById("cacheRefreshBtn");
        const startTs = new Date();
        const keys = [
            "Providers",
            "Contracts",
            "Services",
            "Metadata",
            "Active Providers",
            "Active Services",
            "Subscribers",
        ];
        const progressState = () => keys.map((k) => `${k}: syncing...`).join("\n");
        const startMsg = `Starting cache refresh at ${startTs.toISOString()}...\n${progressState()}\n\nPlease wait...`;
        let progressTimer = null;
        const spinner = ["|", "/", "-", "\\"];
        let spinIdx = 0;
        let refreshDone = false;
        const tickProgress = () => {
            if (refreshDone) return;
            const elapsedSec = Math.round((Date.now() - startTs.getTime()) / 1000);
            const spin = spinner[spinIdx];
            spinIdx = (spinIdx + 1) % spinner.length;
            updateModalBody(`${startMsg}\nProgress: ${spin}  Elapsed: ${elapsedSec}s`);
        };
        if (statusEl) statusEl.textContent = "Refreshing cache...";
        if (btn) btn.disabled = true;
        // keep syncing state across full refresh flow to avoid flicker
        setSyncingLocal(true);
        if (showModal) {
            showResultModal("Cache Refresh", startMsg);
            progressTimer = setInterval(tickProgress, 750);
        }
        try {
            const res = await fetch(apiUrl("/api/cache-refresh"), { method: "POST" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                const detail = (data && (data.detail || data.error)) || `${res.status}`;
                throw new Error(detail);
            }
            const results = (data && data.results) || {};
            const summarize = (key, payload) => {
                const tryParse = (val) => {
                    if (typeof val === "string") {
                        try { return JSON.parse(val); } catch (e) { return null; }
                    }
                    return val;
                };
                const pickList = (obj, candidates) => {
                    for (const c of candidates) {
                        const v = c && typeof c === "string" ? obj[c] : obj?.[c];
                        const parsed = tryParse(v);
                        if (Array.isArray(parsed)) return parsed;
                    }
                    return [];
                };
                if (!payload || typeof payload !== "object") return `${key}: (no data)`;
                let d = payload.data ?? payload;
                d = tryParse(d) ?? {};
                let items = [];
                if (Array.isArray(d)) {
                    items = d;
                } else if (typeof d === "object") {
                    if (key === "provider-services" || key === "providers" || key === "active_providers") {
                        items = pickList(d, ["providers", "provider", "result"]);
                    } else if (key === "provider-contracts" || key === "contracts") {
                        items = pickList(d, ["contracts", "contract", "result"]);
                    } else if (key === "active_services") {
                        items = pickList(d, ["active_services"]);
                    } else if (key === "metadata") {
                        const metaObj = d.metadata || d;
                        items = metaObj && typeof metaObj === "object" ? Object.keys(metaObj) : [];
                    } else if (key === "service-types" || key === "services") {
                        // handle nested under data as well
                        items = pickList(d, ["services", "service", "result"]);
                        if (!items.length && d.data) {
                            items = pickList(d.data, ["services", "service", "result"]);
                        }
                    } else if (key === "subscribers") {
                        items = pickList(d, ["subscribers"]);
                    } else {
                        items = [];
                    }
                }
                const count = Array.isArray(items) ? items.length : 0;
                if (key === "metadata") {
                    return `${key}: ${count || 0}`;
                }
                return `${key}: ${count || "(no data)"}`;
            };
            const orderedKeys = ["provider-services","provider-contracts","service-types","metadata","active_providers","active_services","subscribers"];
            const summary = orderedKeys.map(k => summarize(k, results[k])).join("\n");
            const finishedMsg = `Finished cache refresh at ${new Date().toISOString()}\n${summary || "(no results)"}\n\nSync is complete, it is ok to close this modal window now.`;
            if (statusEl) statusEl.textContent = `Last refresh: ${new Date().toLocaleString()}`;
            refreshDone = true;
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (showModal) {
                updateModalBody(finishedMsg);
            }
            // refresh header and listeners after cache refresh
            await refreshHeader();
            await loadListeners();
            // refresh active service types so the listener dropdown reflects active_service_types.json
            await refreshServiceTypes(true, null, true);
            // update metrics
            updateMetrics(results);
        } catch (err) {
            if (statusEl) statusEl.textContent = `Cache refresh failed: ${err}`;
            refreshDone = true;
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (showModal) {
                updateModalBody(`Failed to refresh cache:\n${err}`);
            }
        } finally {
            if (progressTimer) { clearInterval(progressTimer); progressTimer = null; }
            if (btn) btn.disabled = false;
            setSyncingLocal(false);
        }
    }

    async function ensureSubscriberSettingsExists() {
        try {
            const res = await fetch(apiUrl("/api/subscriber-settings/exists"), { cache: "no-store" });
            const data = await res.json();
            if (data && data.exists === false) {
                window.location.href = "admin.html?needsSettings=1";
                return false;
            }
        } catch (e) {
            // ignore errors, proceed
        }
        return true;
    }

    document.addEventListener("DOMContentLoaded", async () => {
        await fetchAdminPasswordStatus(true);
        const ok = await ensureSubscriberSettingsExists();
        if (!ok) return;
        refreshHeader();
        // Refresh every 10 seconds to mirror provider UI behavior
        setInterval(refreshHeader, 10000);
        loadListeners();
        // Keep listener table/logs fresh for dashboard view; skip while editing to avoid clobbering form state
        setInterval(() => { if (!listenersEditingId) loadListeners(); }, 5000);
        refreshServiceTypes(false);
        // try to populate metrics from initial cache-refresh data if present
        updateMetrics();
        // poll cache status to reflect background sync
        pollSyncStatus();
        setInterval(pollSyncStatus, 5000);
        // kick off a cache refresh on load
        refreshCache(false);
    });

    function showResultModal(title, body, asHtml = false) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) {
            if (asHtml) {
                modalBody.innerHTML = body || "";
            } else {
                modalBody.textContent = body || "";
            }
        }
        if (modal) modal.classList.remove("hidden");
    }

    function updateModalBody(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.textContent = body || "";
    }

    function updateModalBodyHtml(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.innerHTML = body || "";
    }

    let syncingLocal = false;
    let syncingRemote = false;
    function updateSyncUI() {
        const pill = document.getElementById("syncPill");
        const btn = document.getElementById("cacheRefreshBtn");
        const isSyncing = syncingLocal || syncingRemote;
        if (pill) pill.classList[isSyncing ? "remove" : "add"]("hidden");
        if (btn) btn.disabled = isSyncing;
    }
    function setSyncingLocal(active) {
        syncingLocal = !!active;
        updateSyncUI();
    }
    function setSyncingRemote(active) {
        syncingRemote = !!active;
        updateSyncUI();
    }
    async function pollSyncStatus() {
        try {
            const statusRes = await fetch(apiUrl("/api/cache-status"), { cache: "no-store" });
            let wasSyncing = syncingRemote;
            if (statusRes.ok) {
                const data = await statusRes.json();
                const inProg = data && (data.in_progress === true || data.in_progress === "true");
                setSyncingRemote(!!inProg);
                // If a sync just finished, refresh service types to update dropdowns without a full reload
                if (wasSyncing && !inProg) {
                    refreshServiceTypes(true);
                }
            }
            const countsRes = await fetch(apiUrl("/api/cache-counts"), { cache: "no-store" });
            if (countsRes.ok) {
                const counts = await countsRes.json();
                // Update only the active providers, active services, and contracts counts to avoid jumping the UI
                updateMetrics(null, {
                    providers: counts.active_providers,
                    services: counts.active_services,
                    contracts: counts.contracts,
                    subscribers: counts.subscribers,
                    nodeTypes: counts.supported_chains,
                });
            }
        } catch (e) {
            // keep previous remote state on error
        }
    }

    function serviceIsActiveStatus(statusVal) {
        if (statusVal === undefined || statusVal === null) return true;
        if (typeof statusVal === "boolean") return !!statusVal;
        const s = String(statusVal).trim().toLowerCase();
        if (!s) return true;
        return ["1", "active", "online", "true", "on", "up", "running"].includes(s);
    }

    function countActiveServicesFromProviderServices(payload) {
        if (!payload || typeof payload !== "object") return null;
        const d = payload.data || payload;
        let providers = [];
        if (Array.isArray(d.providers)) providers = d.providers;
        else if (Array.isArray(d.provider)) providers = d.provider;
        let count = 0;
        for (const p of providers) {
            if (!p || typeof p !== "object") continue;
            const svcs = Array.isArray(p.services) ? p.services : Array.isArray(p.service) ? p.service : [];
            for (const s of svcs) {
                if (!s || typeof s !== "object") continue;
                const status = s.status !== undefined ? s.status : p.status;
                if (serviceIsActiveStatus(status)) count += 1;
            }
        }
        return count;
    }

    function updateMetrics(results, overrides) {
        const mProv = document.getElementById("metricProviders");
        const mSvc = document.getElementById("metricServices");
        const mCon = document.getElementById("metricContracts");
        const mSub = document.getElementById("metricSubscribers");
        const mNode = document.getElementById("metricNodeTypes");
        const getCount = (payload, keys) => {
            if (!payload || typeof payload !== "object") return null;
            const d = payload.data || payload;
            for (const k of keys) {
                const v = d[k];
                if (Array.isArray(v)) return v.length;
            }
            return null;
        };
        let activeSvcCount = null;
        if (results) {
            if ("active_services" in results) {
                const d = results["active_services"].data || results["active_services"];
                if (d && Array.isArray(d.active_services)) activeSvcCount = d.active_services.length;
            }
            if (activeSvcCount === null && "provider-services" in results) {
                const c = countActiveServicesFromProviderServices(results["provider-services"]);
                if (c !== null) activeSvcCount = c;
            }
            if (mProv && "provider-services" in results) {
                const c = getCount(results["provider-services"], ["providers", "provider"]);
                if (c !== null) mProv.textContent = c;
            }
            if (mProv && "active_providers" in results) {
                const d = results["active_providers"].data || results["active_providers"];
                if (d && Array.isArray(d.providers)) {
                    mProv.textContent = d.providers.length;
                }
            }
            if (mCon && "provider-contracts" in results) {
                const c = getCount(results["provider-contracts"], ["contracts", "contract"]);
                if (c !== null) mCon.textContent = c;
            }
            if (mSub && "subscribers" in results) {
                const d = results["subscribers"].data || results["subscribers"];
                if (d && Array.isArray(d.subscribers)) mSub.textContent = d.subscribers.length;
            }
            if (mSvc && "service-types" in results) {
                const c = getCount(results["service-types"], ["services", "service", "result", "data"]);
                if (mNode && c !== null) mNode.textContent = c;
            }
            if (mProv && "providers" in results) {
                const d = results["providers"];
                if (d && d.data && Array.isArray(d.data.providers)) {
                    mProv.textContent = d.data.providers.length;
                }
            }
        }
        if (mSvc && activeSvcCount !== null) {
            mSvc.textContent = activeSvcCount;
        }
        if (overrides) {
            if (mProv && overrides.providers !== undefined) mProv.textContent = overrides.providers;
            if (mSvc && overrides.services !== undefined) mSvc.textContent = overrides.services;
            if (mCon && overrides.contracts !== undefined) mCon.textContent = overrides.contracts;
            if (mSub && overrides.subscribers !== undefined) mSub.textContent = overrides.subscribers;
            if (mNode && overrides.nodeTypes !== undefined) mNode.textContent = overrides.nodeTypes;
        }
        if (mNode) mNode.textContent = mNode.textContent || "–";
    }
    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.classList.add("hidden");
        // Refresh listeners/service options when any modal closes to ensure latest data
        loadListeners();
        refreshServiceTypes(true);
    }

    function copyListenerEndpoint(endpoint) {
        const title = "Copy Listener Endpoint";
        const val = endpoint || "";
        if (!val || val === "–") {
            showResultModal(title, "Endpoint unavailable");
            return;
        }
        const msg = val;
        const fallbackMsg = `Failed to copy endpoint (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`;
        navigator.clipboard.writeText(msg).then(() => {
            showResultModal(title, `Endpoint copied:\n${val}`);
        }).catch(() => {
            try {
                const ta = document.createElement("textarea");
                ta.value = msg;
                document.body.appendChild(ta);
                ta.select();
                const ok = document.execCommand("copy");
                document.body.removeChild(ta);
                if (ok) {
                    showResultModal(title, `Endpoint copied:\n${val}`);
                    return;
                }
            } catch (e) {
                /* ignore */
            }
            showResultModal(title, fallbackMsg);
        });
    }

    // ─────────────────────────────
    // Listener registry UI helpers
    // ─────────────────────────────
    let listenersEditingId = null;
    let listenersCache = [];
    let serviceTypesCache = [];
    let providersByServiceCache = {};
    let providersFetchInFlight = {};
    let lastServiceTypesFetch = 0;

    function serviceOptionsHtml(selectedId) {
        const opts = serviceTypesCache.map((s) => {
            const sid = s && (s.service_id ?? s.serviceID ?? s.id);
            if (sid === undefined || sid === null) return "";
            const label = formatServiceLabel(sid);
            const count = s && s.count !== undefined ? ` (${s.count} Active)` : "";
            const sel = String(selectedId || "") === String(sid) ? "selected" : "";
            return `<option value="${escapeHtml(String(sid))}" ${sel}>${escapeHtml(label + count)}</option>`;
        }).filter(Boolean).join("");
        return `<option value="">Select a service</option>${opts}`;
    }

    function updateSelectOptionsFromCache(selectEl) {
        if (!selectEl) return;
        const current = selectEl.value;
        selectEl.innerHTML = serviceOptionsHtml(current);
        if (current) selectEl.value = current;
    }

    async function refreshServiceTypes(rerenderTable = false, selectIdToUpdate = null, force = false) {
        const now = Date.now();
        const freshWindowMs = 5000;
        if (!force && now - lastServiceTypesFetch < freshWindowMs) {
            if (selectIdToUpdate) updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
            if (rerenderTable && !listenersEditingId) renderListenersTable();
            return;
        }
        try {
            const res = await fetch(apiUrl("/api/active-service-types"), { cache: "no-store" });
            if (!res.ok) return;
            const svcData = await res.json().catch(() => ({}));
            const list = svcData && svcData.active_service_types;
            if (Array.isArray(list)) {
                serviceTypesCache = list;
                lastServiceTypesFetch = Date.now();
                populateServiceSelect();
                if (selectIdToUpdate) {
                    updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
                }
                if (rerenderTable && !listenersEditingId) {
                    renderListenersTable();
                }
            }
        } catch (e) {
            // ignore fetch errors; will retry on next trigger
        }
    }

    async function loadListeners() {
        try {
            const res = await fetch(apiUrl("/api/listeners"), { cache: "no-store" });
            const data = await res.json();
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersCache = Array.isArray(data.listeners) ? data.listeners : [];
            const nextPort = data.next_port || "n/a";
            const npEl = document.getElementById("nextPortValue");
            if (npEl) npEl.textContent = nextPort;
            if (Array.isArray(data.port_range) && data.port_range.length === 2) {
                portRangeGlobal = data.port_range;
            }
            if (data.port_floor) {
                portFloorGlobal = data.port_floor;
            } else if (Array.isArray(portRangeGlobal) && portRangeGlobal.length === 2) {
                portFloorGlobal = portRangeGlobal[0];
            }
            const rangeEl = document.getElementById("listenerRange");
            if (rangeEl && Array.isArray(data.port_range) && data.port_range.length === 2) {
                rangeEl.textContent = `Ports ${data.port_range[0]}-${data.port_range[1]}`;
            }
            populatePortStartSelect();
            renderListenersTable();
            renderListenerLogs();
            if (!serviceTypesCache.length) {
                refreshServiceTypes(true);
            }
        } catch (err) {
            renderListenersTable(`Failed to load listeners: ${err}`);
        }
    }

    function populatePortStartSelect() {
        const sel = document.getElementById("portStartSelect");
        if (!sel) return;
        const [min, max] = Array.isArray(portRangeGlobal) && portRangeGlobal.length === 2 ? portRangeGlobal : [62001, 62100];
        const floor = portFloorGlobal || min;
        let opts = "";
        for (let p = min; p <= max; p++) {
            opts += `<option value="${p}" ${p === floor ? "selected" : ""}>${p}</option>`;
        }
        sel.innerHTML = opts;
        sel.value = String(floor);
    }

    async function handlePortStartChange() {
        const sel = document.getElementById("portStartSelect");
        if (!sel) return;
        const val = parseInt(sel.value, 10);
        if (Number.isNaN(val)) return;
        sel.disabled = true;
        try {
            const res = await fetch(apiUrl("/api/listener-port-start"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ start_port: val }),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.statusText || res.status);
            }
            if (data.port_floor) {
                portFloorGlobal = data.port_floor;
            }
            if (Array.isArray(data.port_range) && data.port_range.length === 2) {
                portRangeGlobal = data.port_range;
            }
            await loadListeners();
        } catch (e) {
            alert(`Failed to set start port: ${e}`);
            populatePortStartSelect();
        } finally {
            sel.disabled = false;
        }
    }

    let openListenerId = null;

    function renderListenersTable(errorText) {
        const container = document.getElementById("listenersTable");
        if (!container) return;
        if (errorText) {
            container.innerHTML = `<div class="muted">${escapeHtml(errorText)}</div>`;
            return;
        }
        if (!listenersCache.length) {
            container.innerHTML = `<div class="muted">No listeners yet. Add one to auto-assign the next open port.</div>`;
            return;
        }
        const rows = listenersCache.map((l) => {
            const isEditing = listenersEditingId === String(l.id);
            const isOpen = isEditing || openListenerId === String(l.id);
            const targetSafe = escapeHtml(l.target || "");
            const portSafe = escapeHtml(l.port ?? "");
            const statusSafe = escapeHtml(l.status || "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id);
            const svcSelect = `<div class="muted">
                <div>${escapeHtml(svcLabel || "—")}</div>
                <div class="muted small">Service type cannot be changed after creation.</div>
                <input type="hidden" id="editService-${l.id}" value="${escapeHtml(l.service_id || "")}">
            </div>`;
            const statusSelect = buildStatusSelect(l.status, `editStatus-${l.id}`);
            const topServices = dedupTopServices(Array.isArray(l.top_services) ? l.top_services : []);
            const whitelist = l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)";
            const hostForListener = window.location.hostname || "localhost";
            const protoForListener = (window.location.protocol || "").startsWith("https") ? "https" : "http";
            const endpointUrl = portSafe ? `${protoForListener}://${hostForListener}:${portSafe}` : "–";
            let topServicesDisplay;
            if (isEditing) {
                const rows = topServices.length ? topServices.map((bp, idx) => {
                        const mon = bp && bp.provider_moniker;
                        const fallbackName = mon || l.provider_moniker || (bp && bp.provider_pubkey) || "(unknown)";
                        const inactive = (!mon && !l.provider_moniker) || fallbackName === "(Inactive)";
                        const name = fallbackName;
                        const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                            ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                            : "";
                        const actions = isEditing
                            ? `<div class="top-service-actions" style="display:flex;gap:6px;flex-wrap:nowrap;">
                                    <button class="copy-btn" ${idx === 0 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, -1)">↑</button>
                                    <button class="copy-btn" ${idx === topServices.length - 1 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, 1)">↓</button>
                                    <button class="copy-btn danger-btn" onclick="removeTopService('${l.id}', ${idx})">✕</button>
                               </div>`
                            : "";
                        const statusVal = bp && bp.status ? String(bp.status) : "";
                        const statusDot = statusVal.toLowerCase() === "up"
                            ? '<span class="status-dot dot-ok"></span>'
                            : statusVal.toLowerCase() === "down"
                                ? '<span class="status-dot dot-err"></span>'
                                : "—";
                        let rtDisplay = "—";
                        if (bp && bp.rt_avg_ms !== undefined && bp.rt_avg_ms !== null) {
                            const avgMs = Number(bp.rt_avg_ms);
                            if (!Number.isNaN(avgMs)) {
                                rtDisplay = `${Math.round(avgMs)} ms`;
                            }
                        }
                        return `<tr>
                            <td class="ts-col-num"><span class="muted small" style="color:#fff; font-weight:700;">${idx + 1}</span></td>
                            <td class="ts-col-name"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(name)}${inactive ? " (Inactive)" : ""}</span></td>
                            <td class="ts-col-rate"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rate)}</span></td>
                            <td class="ts-col-status">${statusDot}</td>
                            <td class="ts-col-rt"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rtDisplay)}</span></td>
                            ${isEditing ? `<td class="ts-col-actions">${actions}</td>` : ""}
                        </tr>`;
                    }).join("") : `<tr><td colspan="6" class="muted small">No providers yet.</td></tr>`;
                const head = `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th><th></th></tr>`;
                const svcForTop = l.service_id || l.service;
                const selectId = `addTopSvc-${l.id}`;
                const cached = svcForTop ? providersByServiceCache[String(svcForTop)] : undefined;
                const excludePks = topServices.map((ts) => ts?.provider_pubkey || ts?.pubkey || "");
                if (svcForTop && cached === undefined) {
                    ensureProvidersForService(svcForTop, l.id);
                }
                const hasCache = cached !== undefined;
                const addControls = svcForTop
                    ? (() => {
                        const hasList = cached && Array.isArray(cached) && cached.length;
                        if (!hasCache) {
                            return `<div class="muted small">Loading providers for this service...</div>`;
                        }
                        if (!hasList) {
                            return `<div class="muted small">No active providers found for this service.</div>`;
                        }
                        // even if all filtered out, still show disabled select/button so user sees the state
                        const selectHtml = providerSelectHtml(svcForTop, selectId, excludePks);
                        return `<div class="top-service-add-row" style="display:flex;align-items:center;gap:10px;padding:8px;margin-top:8px;">
                                    ${selectHtml}
                                    <button class="primary" style="white-space:nowrap;" onclick="addTopService('${l.id}', '${selectId}')">Add provider</button>
                                </div>`;
                    })()
                    : `<div class="muted small">Select a service to add providers.</div>`;
                topServicesDisplay = `<div class="top-services-table-wrap">
                            <table class="top-services-table">
                                <thead>${head}</thead>
                                <tbody>${rows}</tbody>
                            </table>
                            ${addControls}
                        </div>`;
            } else {
                topServicesDisplay = topServices.length
                    ? (() => {
                        const rows = topServices.map((bp, idx) => {
                            const mon = bp && bp.provider_moniker;
                            const fallbackName = mon || l.provider_moniker || (bp && bp.provider_pubkey) || "(unknown)";
                            const inactive = (!mon && !l.provider_moniker) || fallbackName === "(Inactive)";
                            const name = fallbackName;
                            const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                                ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                                : "";
                            const actions = "";
                            const statusVal = bp && bp.status ? String(bp.status) : "";
                            const statusDot = statusVal.toLowerCase() === "up"
                                ? '<span class="status-dot dot-ok"></span>'
                                : statusVal.toLowerCase() === "down"
                                    ? '<span class="status-dot dot-err"></span>'
                                    : "—";
                            let rtDisplay = "—";
                            if (bp && bp.rt_avg_ms !== undefined && bp.rt_avg_ms !== null) {
                                const avgMs = Number(bp.rt_avg_ms);
                                if (!Number.isNaN(avgMs)) {
                                    rtDisplay = `${Math.round(avgMs)} ms`;
                                }
                            }
                            return `<tr>
                                <td class="ts-col-num"><span class="muted small" style="color:#fff; font-weight:700;">${idx + 1}</span></td>
                                <td class="ts-col-name"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(name)}${inactive ? " (Inactive)" : ""}</span></td>
                                <td class="ts-col-rate"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rate)}</span></td>
                                <td class="ts-col-status">${statusDot}</td>
                                <td class="ts-col-rt"><span class="muted small" style="color:#fff; font-weight:700;">${escapeHtml(rtDisplay)}</span></td>
                            </tr>`;
                        }).join("");
                        const head = `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th></tr>`;
                        return `<table class="top-services-table">
                            <thead>${head}</thead>
                            <tbody>${rows}</tbody>
                        </table>`;
                    })()
                    : "—";
            }
            if (isEditing) {
                return `
                <tbody class="listener-block" id="listener-${l.id}">
                <tr class="listener-main">
                    <td class="col-status">${statusSelect}</td>
                    <td>
                        ${svcSelect}
                    </td>
                    <td class="mono">${portSafe || "–"}</td>
                    <td class="listener-actions-cell col-actions">
                        <div class="actions align-right" style="display:flex;gap:8px;flex-wrap:nowrap;justify-content:flex-end;">
                            <button onclick="cancelEditListener()">Cancel</button>
                            <button class="primary" onclick="saveListener('${l.id}')">Save</button>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                    <div class="muted small" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:start;">
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Endpoint:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${escapeHtml(endpointUrl)}</strong></span> ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}</div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Whitelist IPs:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)"}</strong></span></div>
                        </div>
                    </div>
                        <div class="muted small" style="margin-top:8px;">Polling Options</div>
                        <div class="muted small" style="display:flex; gap:8px; align-items:flex-start; flex-wrap:wrap;">
                            <label class="inline" style="gap:4px;">
                                <select id="editHealthMethod-${l.id}" class="select" style="width:auto;">
                                    <option value="POST" ${String(l.health_method || "POST").toUpperCase() === "POST" ? "selected" : ""}>POST</option>
                                    <option value="GET" ${String(l.health_method || "POST").toUpperCase() === "GET" ? "selected" : ""}>GET</option>
                                </select>
                            </label>
                            <label class="inline" style="gap:4px;">
                                <select id="editHealthHeader-${l.id}" class="select" style="width:auto;">
                                    <option value="">(no header)</option>
                                    <option value="application/json" ${String(l.health_header || "application/json").toLowerCase() === "application/json" ? "selected" : ""}>Content-Type: application/json</option>
                                    <option value="application/x-www-form-urlencoded" ${String(l.health_header || "").toLowerCase() === "application/x-www-form-urlencoded" ? "selected" : ""}>Content-Type: application/x-www-form-urlencoded</option>
                                    <option value="text/plain" ${String(l.health_header || "").toLowerCase() === "text/plain" ? "selected" : ""}>Content-Type: text/plain</option>
                                    <option value="application/octet-stream" ${String(l.health_header || "").toLowerCase() === "application/octet-stream" ? "selected" : ""}>Content-Type: application/octet-stream</option>
                                </select>
                            </label>
                            <div style="flex:1; min-width:200px;">
                                <textarea id="editHealthPayload-${l.id}" rows="2" class="full-input" placeholder="Payload for POST or URL/path for GET">${escapeHtml(l.health_payload || "")}</textarea>
                            </div>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small">Top services:</div>
                        <div class="muted">${topServicesDisplay}</div>
                    </td>
                </tr>
                <tr class="listener-spacer"><td colspan="4"></td></tr>
                </tbody>`;
            }
            const statusDot = `<span class="status-dot ${String(l.status).toLowerCase() === "active" ? "dot-ok" : "dot-err"}"></span>`;
            const caret = isOpen ? "▾" : "▸";
            return `
            <tbody class="listener-block ${isOpen ? "open" : "closed"}" id="listener-${l.id}">
            <tr class="listener-main" onclick="toggleListenerOpen('${l.id}')">
                <td class="col-status"><span class="muted small" style="font-size:18px; display:inline-block; width:16px; color: var(--blue);">${caret}</span> ${statusDot}</td>
                <td>${escapeHtml(svcLabel || "—")}</td>
                <td class="mono">${portSafe || "–"}</td>
                <td class="listener-actions-cell col-actions">
                    <button class="btn-ghost" onclick="event.stopPropagation(); testListener('${l.id}')">Test</button>
                    <button class="btn-ghost" onclick="event.stopPropagation(); pollListener('${l.id}')">Poll</button>
                    <button class="primary" onclick="event.stopPropagation(); editListener('${l.id}')">Edit</button>
                    <button class="primary danger-btn" onclick="event.stopPropagation(); deleteListener('${l.id}')">Delete</button>
                </td>
            </tr>
            ${isOpen ? `
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small" style="display:grid; grid-template-columns: 1fr 1fr; gap:8px; align-items:start;">
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Endpoint:</div>
                            <div class="muted"><span class="mono" style="color:#fff;"><strong>${escapeHtml(endpointUrl)}</strong></span> ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}</div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:4px;">
                            <div class="muted small">Whitelist IPs:</div>
                            <div class="muted small"><span class="mono" style="color:#fff;"><strong>${whitelist}</strong></span></div>
                        </div>
                    </div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small" style="padding-bottom:4px;">Polling Options:</div>
                    <div class="muted small"><span style="color:#fff;"><strong>
                        Method: ${escapeHtml((l.health_method || "POST").toString().toUpperCase())}
                        | Content-Type: ${escapeHtml(l.health_header || "(none)")}
                        | Payload/URL: ${escapeHtml(l.health_payload || "(default)")}
                    </strong></span></div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Top services:</div>
                    <div class="muted">${topServicesDisplay}</div>
                </td>
            </tr>
            <tr class="listener-spacer"><td colspan="4"></td></tr>` : ""}
            ${!isOpen ? `<tr class="listener-spacer"><td colspan="4"></td></tr>` : ""}
            </tbody>`;
        }).join("");
        container.innerHTML = `<div class="table-wrap">
            <table class="table listeners-table">
                <thead>
                    <tr><th class="col-status">Status</th><th>Service Type</th><th>Port</th><th class="col-actions">Actions</th></tr>
                </thead>
                <tbody>${rows}</tbody>
            </table>
        </div>`;
    }

    function resetListenerForm() {
        const svc = document.getElementById("listenerService");
        if (svc) svc.value = "";
    }

    async function submitListenerForm(evt) {
        evt.preventDefault();
        const svcId = document.getElementById("listenerService")?.value || "";
        if (!svcId) {
            alert("Please select a service type before adding a listener.");
            return;
        }
        const svcName = (serviceNameById(svcId) || "").toLowerCase();
        const body = {
            status: "active",
            whitelist_ips: "",
            health_method: "POST",
            health_payload: "",
            health_header: "application/json",
        };
        if (svcName.includes("cosmos") || svcName.includes("arkeo") || svcName.includes("gaia") || svcName.includes("osmosis")) {
            body.health_method = "POST";
            body.health_header = "application/json";
            body.health_payload = '{"jsonrpc":"2.0","id":1,"method":"status","params":[]}';
        }
        if (svcId) body.service_id = svcId;
        try {
            const res = await fetch(apiUrl("/api/listeners"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            const newId = data && data.listener && data.listener.id ? String(data.listener.id) : null;
            resetListenerForm();
            listenersEditingId = null;
            if (newId) {
                openListenerId = newId; // ensure the new listener drawer opens
            }
            await loadListeners();
            if (newId) {
                const elId = `listener-${newId}`;
                // wait for DOM render
                setTimeout(() => {
                    const el = document.getElementById(elId);
                    if (el && typeof el.scrollIntoView === "function") {
                        el.scrollIntoView({ behavior: "smooth", block: "start" });
                    }
                }, 50);
            }
        } catch (err) {
            showResultModal("Add Listener", `Failed to add listener: ${err}`);
        }
    }

    function editListener(id) {
        listenersEditingId = String(id);
        const l = listenersCache.find((x) => String(x.id) === String(id));
        const svc = l ? (l.service_id || l.service) : null;
        if (svc) ensureProvidersForService(svc, id);
        renderListenersTable();
    }

    function cancelEditListener() {
        listenersEditingId = null;
        renderListenersTable();
    }

    function toggleListenerOpen(id) {
        if (listenersEditingId && listenersEditingId === String(id)) return; // keep edit open
        if (openListenerId === String(id)) {
            openListenerId = null;
        } else {
            openListenerId = String(id);
        }
        renderListenersTable();
    }

    async function saveListener(id) {
        const svcIdInput = document.getElementById(`editService-${id}`);
        const svcId = (svcIdInput && svcIdInput.value) || "";
        const status = document.getElementById(`editStatus-${id}`)?.value || "";
        const whitelist = document.getElementById(`editWhitelist-${id}`)?.value || "";
        const current = listenersCache.find((l) => String(l.id) === String(id));
        const body = {
            status,
            whitelist_ips: whitelist,
            health_method: document.getElementById(`editHealthMethod-${id}`)?.value || "",
            health_payload: document.getElementById(`editHealthPayload-${id}`)?.value || "",
            health_header: document.getElementById(`editHealthHeader-${id}`)?.value || "",
        };
        if (svcId) {
            body.service_id = svcId;
        } else if (current && current.service_id) {
            body.service_id = current.service_id;
        }
        if (current && Array.isArray(current.top_services)) {
            body.top_services = current.top_services;
        }
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Update Listener", `Failed to update listener: ${err}`);
        }
    }

    function moveTopService(listenerId, idx, delta) {
        const l = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!l || !Array.isArray(l.top_services)) return;
        const newIdx = idx + delta;
        if (newIdx < 0 || newIdx >= l.top_services.length) return;
        const arr = [...l.top_services];
        const [item] = arr.splice(idx, 1);
        arr.splice(newIdx, 0, item);
        l.top_services = arr;
        renderListenersTable();
    }

    async function addTopService(listenerId, selectId) {
        const listener = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!listener) return;
        const svcId = listener.service_id || listener.service;
        if (!svcId) {
            alert("Select a service type before adding providers.");
            return;
        }
        const sid = String(svcId);
        if (!providersByServiceCache[sid]) {
            await ensureProvidersForService(sid, listenerId);
        }
        const selectEl = document.getElementById(selectId);
        const selectedPk = (selectEl && selectEl.value) || "";
        if (!selectedPk) {
            alert("Choose a provider to add.");
            return;
        }
        const existing = Array.isArray(listener.top_services) ? listener.top_services : [];
        const already = existing.some(
            (ts) => String(ts?.provider_pubkey || ts?.pubkey || "") === String(selectedPk)
        );
        if (already) {
            alert("That provider is already in this list.");
            return;
        }
        const choices = providersByServiceCache[sid] || [];
        const match = choices.find((p) => String(p?.provider_pubkey || p?.pubkey || "") === String(selectedPk));
        if (!match) {
            alert("Provider not found for this service.");
            return;
        }
        const entry = {
            provider_pubkey: selectedPk,
            service_id: sid,
        };
        const moniker = match.provider_moniker || match?.provider?.moniker;
        if (moniker) entry.provider_moniker = moniker;
        if (match.sentinel_url) entry.sentinel_url = match.sentinel_url;
        if (match.metadata_uri) entry.metadata_uri = match.metadata_uri;
        if (match.pay_as_you_go_rate) entry.pay_as_you_go_rate = match.pay_as_you_go_rate;
        if (match.queries_per_minute !== undefined) entry.queries_per_minute = match.queries_per_minute;
        if (match.min_contract_duration !== undefined) entry.min_contract_duration = match.min_contract_duration;
        if (match.max_contract_duration !== undefined) entry.max_contract_duration = match.max_contract_duration;
        if (match.settlement_duration !== undefined) entry.settlement_duration = match.settlement_duration;
        const top = Array.isArray(listener.top_services) ? [...listener.top_services] : [];
        top.push(entry);
        listener.top_services = dedupTopServices(top);
        renderListenersTable();
    }

    function removeTopService(listenerId, idx) {
        const l = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!l || !Array.isArray(l.top_services)) return;
        const arr = [...l.top_services];
        if (idx < 0 || idx >= arr.length) return;
        arr.splice(idx, 1);
        l.top_services = arr;
        renderListenersTable();
    }

    async function deleteListener(id) {
        if (!confirm("Delete this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "DELETE",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Delete Listener", `Failed to delete listener: ${err}`);
        }
    }

    // ─────────────────────────────
    // Listener logs
    // ─────────────────────────────
    function scrollLogToBottom(pre) {
        if (!pre) return;
        pre.scrollTop = pre.scrollHeight;
    }

    async function fetchListenerLog(id, elId) {
        const pre = document.getElementById(elId);
        if (pre) pre.textContent = "Loading log...";
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/logs?lines=200`), { cache: "no-store" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (pre) pre.textContent = data && data.error ? `Error: ${data.error}` : `Error: ${res.status}`;
                scrollLogToBottom(pre);
                return;
            }
            const log = data && data.log ? data.log : "(no log)";
            if (pre) pre.textContent = log || "(no log)";
            scrollLogToBottom(pre);
        } catch (e) {
            if (pre) pre.textContent = `Error: ${e}`;
            scrollLogToBottom(pre);
        }
    }

    function renderListenerLogs() {
        const container = document.getElementById("listenerLogs");
        if (!container) return;
        if (!listenersCache.length) {
            container.innerHTML = "";
            return;
        }
        const cards = listenersCache.map((l) => {
            const portSafe = escapeHtml(l.port ?? "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id) || "";
            const logId = `log-${l.id}`;
            return `
            <div class="log-card">
                <div class="row-between" style="align-items: center;">
                    <h4>Port ${portSafe || "–"} ${svcLabel ? `| ${escapeHtml(svcLabel)}` : ""}</h4>
                    <div class="log-actions">
                        <button class="primary" onclick="fetchListenerLog('${l.id}', '${logId}')">Refresh</button>
                    </div>
            </div>
            <pre id="${logId}" class="log-pre">(loading...)</pre>
        </div>`;
        }).join("");
        container.innerHTML = cards;
        listenersCache.forEach((l) => fetchListenerLog(l.id, `log-${l.id}`));
    }

    async function runListenerTests(id, runs = 1, titlePrefix, refreshAfter = false) {
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const port = listener && listener.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        const header = `
<div>${escapeHtml(titlePrefix || "Testing")} listener (${runs} runs)...</div>
<div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
        let summaryHtml = `<div class="muted small">Please wait...</div>`;
        let logText = "";
        const logContainer = () => document.getElementById("testLogPre");
        const summaryContainer = () => document.getElementById("testSummary");
        const appendLog = (line) => {
            logText = logText ? `${logText}\n${line}` : line;
            const pre = logContainer();
            if (pre) {
                pre.textContent = logText;
                pre.scrollTop = pre.scrollHeight;
            }
        };
        // open modal shell first
        showResultModal("Test Listener", "", true);
        const renderShell = () => {
            const shell = `${header}<div id="testSummary" class="muted small">${summaryHtml}</div><pre id="testLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(shell);
        };
        renderShell();
        const results = [];
        const successes = [];
        const failures = [];
        for (let i = 1; i <= runs; i++) {
            appendLog(`Run ${i}/${runs}: sending test request...`);
            try {
                const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), {
                    method: "GET",
                    cache: "no-store",
                });
                const data = await res.json().catch(() => ({}));
                const cmd = data && data.command ? data.command : "";
                const ok = isTestOk(res, data);
                const err = ok ? null : (data && (data.detail || data.error)) || res.statusText || res.status;
                let resp = data && data.response;
                let respPretty = resp || "(no data)";
                try {
                    if (typeof resp === "string") {
                        respPretty = JSON.stringify(JSON.parse(resp), null, 2);
                    } else if (resp && typeof resp === "object") {
                        respPretty = JSON.stringify(resp, null, 2);
                    }
                } catch (e) {
                    respPretty = resp || "(no data)";
                }
                results.push({
                    idx: i,
                    cmd,
                    err,
                    respPretty,
                    sentinel: data && data.sentinel_url,
                    provider: data && data.provider_pubkey,
                    providerMon: data && data.provider_moniker,
                    serviceId: data && data.service_id,
                    serviceName: data && data.service_name,
                    sentinelTarget: data && data.sentinel_target,
                    candidateSentinel: data && data.candidate_sentinel,
                    candidateProvider: data && data.candidate_provider,
                    lastCode: data && data.last_code,
                    lastNonce: data && data.last_nonce,
                    lastNonceSource: data && data.last_nonce_source,
                    lastNonceCache: data && data.last_nonce_cache,
                    lastCandProvider: data && data.last_candidate_provider,
                    lastCandSentinel: data && data.last_candidate_sentinel,
                    arkeoNonce: data && data.arkeo_nonce,
                    arkeoContractId: data && data.arkeo_contract_id,
                    arkeoCost: data && data.arkeo_cost,
                    respHeaders: data && data.response_headers,
                    nonceCached: data && data.nonce_cached,
                    nonceCacheKey: data && data.nonce_cache_key,
                    lastUpstreamBody: data && data.last_upstream_body,
                    requestUrl: data && data.request_url,
                    requestMethod: data && data.request_method,
                    requestHeaders: data && data.request_headers,
                    requestBody: data && data.request_body,
                });
                if (err) {
                    failures.push(i);
                } else {
                    successes.push(i);
                }
            } catch (e) {
                results.push({
                    idx: i,
                    cmd: "",
                    err: String(e),
                    respPretty: "(no data)",
                });
                failures.push(i);
            }
            const metaLines = [];
            const last = results[results.length - 1] || {};
            if (last.health_method) metaLines.push(`Method: ${last.health_method}`);
            if (last.health_header) metaLines.push(`Content-Type: ${last.health_header}`);
            if (last.health_payload) metaLines.push(`Payload/URL: ${last.health_payload}`);
            if (last.health_url_example) metaLines.push(`Target: ${last.health_url_example}`);
            if (last.requestUrl) metaLines.push(`Request URL: ${last.requestUrl}`);
            if (last.requestMethod) metaLines.push(`Request Method: ${last.requestMethod}`);
            if (last.requestBody) metaLines.push(`Request Body: ${last.requestBody}`);
            const sentinelDisplay = last.candidateSentinel || last.lastCandSentinel || last.sentinel_target || last.sentinel;
            if (sentinelDisplay) {
                metaLines.push(`Sentinel: ${sentinelDisplay}`);
            }
            const providerDisplay = last.provider || last.candidateProvider || last.lastCandProvider;
            const providerMonDisplay = last.providerMon;
            if (providerDisplay) metaLines.push(`Provider: ${providerDisplay}${providerMonDisplay ? ` (${providerMonDisplay})` : ""}`);
            if (last.health_method) metaLines.push(`Method: ${last.health_method}`);
            if (last.health_header) metaLines.push(`Content-Type: ${last.health_header}`);
            if (last.health_payload) metaLines.push(`Payload/URL: ${last.health_payload}`);
            if (last.health_url_example) metaLines.push(`Target: ${last.health_url_example}`);
            if (last.serviceId || last.serviceName) {
                metaLines.push(`Service: ${last.serviceName || ""}${last.serviceId ? ` [${last.serviceId}]` : ""}`);
            }
            if (last.lastNonce !== undefined && last.lastNonce !== null) {
                metaLines.push(`Last nonce used: ${last.lastNonce}`);
            }
            if (last.lastNonceSource) {
                metaLines.push(`Nonce source: ${last.lastNonceSource}${last.lastNonceCache !== undefined && last.lastNonceCache !== null ? ` (cache now ${last.lastNonceCache})` : ""}`);
            }
            if (last.arkeoNonce) {
                metaLines.push(`Nonce (from response): ${last.arkeoNonce}`);
            }
            if (last.nonceCached !== undefined && last.nonceCached !== null) {
                metaLines.push(`Nonce cache: ${last.nonceCached}${last.nonceCacheKey ? ` [${last.nonceCacheKey}]` : ""}`);
            }
            if (last.lastCode !== undefined && last.lastCode !== null) {
                metaLines.push(`Last upstream code: ${last.lastCode}`);
            }
            if (last.lastUpstreamBody) {
                metaLines.push(`Upstream body: ${last.lastUpstreamBody}`);
            }
            if (last.last_upstream_url) {
                metaLines.push(`Upstream URL: ${last.last_upstream_url}`);
            }
            if (last.last_upstream_headers) {
                metaLines.push(`Upstream Headers: ${JSON.stringify(last.last_upstream_headers)}`);
            }
            if (last.activeContractId) {
                metaLines.push(`Active contract: ${last.activeContractId}${last.activeContractHeight ? ` @height ${last.activeContractHeight}` : ""}`);
                if (last.activeContractProvider) {
                    metaLines.push(`Contract provider: ${last.activeContractProvider}`);
                }
                if (last.activeContractService) {
                    metaLines.push(`Contract service: ${last.activeContractService}`);
                }
            }
            if (last.arkeoContractId) {
                metaLines.push(`Contract (from response): ${last.arkeoContractId}`);
            }
            if (last.arkeoCost) {
                metaLines.push(`Cost (from response): ${last.arkeoCost}`);
            }
            const metaText = metaLines.length ? metaLines.join("\n") + "\n" : "";
            const block = [
                `--- Run ${i} ---`,
                `Command: ${results[results.length - 1].cmd || ""}`,
                metaText ? metaText.trimEnd() : null,
                results[results.length - 1].err ? `Error: ${results[results.length - 1].err}` : `Response:\n${results[results.length - 1].respPretty}`
            ].filter(Boolean).join("\n");
            appendLog(block);
            summaryHtml = `<div class="muted small">Success: ${successes.length ? successes.join(", ") : "0"} | Failed: ${failures.length ? failures.join(", ") : "0"}</div>`;
        }
        // Final summary update
        const summaryEl = summaryContainer();
        if (summaryEl) summaryEl.innerHTML = `<div class="muted small">Test complete.</div>${summaryHtml}`;
        appendLog("All test runs finished.");
        if (refreshAfter) {
            await loadListeners();
        }
    }

    function dedupTopServices(list) {
        const seen = new Set();
        const out = [];
        for (const item of Array.isArray(list) ? list : []) {
            const key = `${item?.provider_pubkey || ""}::${item?.service_id || item?.service || ""}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(item);
        }
        return out;
    }

    function providerOptionLabel(p) {
        const pk = p?.provider_pubkey || p?.pubkey || "";
        const mon = p?.provider_moniker
            || p?.provider?.moniker
            || (p?.metadata && p.metadata.config && p.metadata.config.moniker)
            || (p?.metadata && p.metadata.moniker);
        if (mon) return mon;
        return pk ? formatPubkeyShort(pk) : "(unknown)";
    }

    async function ensureProvidersForService(serviceId, listenerId = null) {
        const sid = String(serviceId || "").trim();
        if (!sid) return [];
        if (providersByServiceCache[sid]) return providersByServiceCache[sid];
        if (providersFetchInFlight[sid]) return providersFetchInFlight[sid];
        providersFetchInFlight[sid] = fetch(apiUrl(`/api/services/${encodeURIComponent(sid)}/providers`), { cache: "no-store" })
            .then(res => res.json().catch(() => ({})))
            .then((data) => {
                const list = Array.isArray(data.providers) ? data.providers : [];
                providersByServiceCache[sid] = list;
                delete providersFetchInFlight[sid];
                if (listenerId && listenersEditingId === String(listenerId)) {
                    renderListenersTable();
                }
                return list;
            })
            .catch(() => {
                providersByServiceCache[sid] = [];
                delete providersFetchInFlight[sid];
                if (listenerId && listenersEditingId === String(listenerId)) {
                    renderListenersTable();
                }
                return [];
            });
        return providersFetchInFlight[sid];
    }

    function providerSelectHtml(serviceId, selectId, excludePks = []) {
        const sid = String(serviceId || "");
        const list = providersByServiceCache[sid];
        if (!sid) {
            return `<select id="${selectId}" class="select" disabled><option value="">Select a service first</option></select>`;
        }
        if (!list) {
            return `<select id="${selectId}" class="select" disabled><option value="">Loading providers...</option></select>`;
        }
        const excludeSet = new Set((excludePks || []).map((x) => String(x || "")));
        const filtered = list.filter((p) => {
            const pk = p?.provider_pubkey || p?.pubkey || "";
            if (!pk) return false;
            return !excludeSet.has(String(pk));
        });
        if (!filtered.length) {
            return `<select id="${selectId}" class="select" disabled><option value="">All providers already added</option></select>`;
        }
        const opts = filtered.map((p) => {
            const pk = p?.provider_pubkey || p?.pubkey || "";
            if (!pk) return "";
            const label = providerOptionLabel(p);
            return `<option value="${escapeHtml(pk)}">${escapeHtml(label)}</option>`;
        }).filter(Boolean).join("");
        return `<select id="${selectId}" class="select"><option value="">Select provider</option>${opts}</select>`;
    }

    async function testListener(id) {
        openListenerId = String(id);
        await runListenerTests(id, 1, "Testing", true);
    }

    async function pollListener(id) {
        openListenerId = String(id);
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const top = listener && Array.isArray(listener.top_services) ? dedupTopServices(listener.top_services) : [];
        // modal shell
        const port = listener?.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        let pollLogText = "";
        const logEl = () => document.getElementById("pollLogPre");
        const summaryEl = () => document.getElementById("pollSummary");
        const renderPollShell = (summaryText = "Starting poll...") => {
            const header = `<div>Polling listener...</div><div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
            const body = `${header}<div id="pollSummary" class="muted small">${escapeHtml(summaryText)}</div><pre id="pollLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(body);
        };
        const appendPollLog = (line, newline = true) => {
            const suffix = newline ? "\n" : "";
            pollLogText = pollLogText ? `${pollLogText}${line}${suffix}` : `${line}${suffix}`;
            const pre = logEl();
            if (pre) {
                pre.textContent = pollLogText.trimEnd();
                pre.scrollTop = pre.scrollHeight;
            }
        };
        showResultModal("Poll Listener", "", true);
        renderPollShell();
        if (!top.length) {
            appendPollLog("No providers to poll; running a single test instead.");
            await testListener(id);
            return;
        }
            const primary = top[0] || {};
            const inferredSvc = listener?.service_id || listener?.service || primary.service_id || primary.service || "";
            const defaults = defaultHealthForService(inferredSvc);
            const basePayload = {
                status: "active",
                service_id: inferredSvc,
                whitelist_ips: listener?.whitelist_ips || "",
                health_method: defaults.method,
                health_payload: defaults.payload,
                health_header: defaults.header,
            };
            let workingTop = dedupTopServices(JSON.parse(JSON.stringify(top)));
            for (const ts of workingTop) {
                const providerLabel = ts?.provider_moniker || "(unknown)";
                appendPollLog(`Provider: ${providerLabel}`);
                // reorder so this provider is first
                const reordered = dedupTopServices([ts, ...workingTop.filter((t) => {
                    const keyT = `${t?.provider_pubkey || ""}::${t?.service_id || t?.service || ""}`;
                    const keyTs = `${ts?.provider_pubkey || ""}::${ts?.service_id || ts?.service || ""}`;
                    return keyT !== keyTs;
                })]);
                try {
                    await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                        method: "PUT",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify({ ...basePayload, top_services: reordered }),
                    });
                    appendPollLog("  Performing tests and polling data...");
                } catch (e) {
                    // ignore reorder errors, proceed
                    appendPollLog(`  reorder failed: ${e}`);
                }
                // run a few tests for this provider, respecting qpm if present
                const qpm = ts && ts.queries_per_minute ? Number(ts.queries_per_minute) : 0;
                const spacingMs = qpm > 0 ? Math.max(200, Math.round(60000 / qpm)) : 400;
                const runs = 3;
                for (let i = 0; i < runs; i++) {
                    try {
                        const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), { method: "GET", cache: "no-store" });
                        const data = await res.json().catch(() => ({}));
                        const ok = isTestOk(res, data);
                        const err = !ok ? (data && (data.detail || data.error)) || res.statusText || res.status : "";
                        appendPollLog(`  Test ${i + 1}/${runs}: ${ok ? "OK" : `Error ${err}`}`);
                    } catch (e) {
                        appendPollLog(`  Test ${i + 1}/${runs}: Error ${e}`);
                    }
                    await new Promise(res => setTimeout(res, spacingMs));
                }
                await loadListeners();
                const refreshed = listenersCache.find((l) => String(l.id) === String(id));
                if (refreshed && Array.isArray(refreshed.top_services)) {
                    workingTop = dedupTopServices(JSON.parse(JSON.stringify(refreshed.top_services)));
                }
                appendPollLog(""); // blank line between providers
            }
        // sort by cheapest then lowest latency using the freshest cache after polling
        const latest = listenersCache.find((l) => String(l.id) === String(id));
        const latestTop = dedupTopServices(latest && Array.isArray(latest.top_services) ? latest.top_services : []);
        const sorted = [...latestTop].sort((a, b) => {
            const statusScore = (x) => {
                const s = String(x?.status || "").toLowerCase();
                if (s === "up") return 0;
                if (s === "down") return 2;
                return 1; // unknown
            };
            const price = (x) => {
                const amt = x?.pay_as_you_go_rate?.amount;
                const n = parseInt(amt, 10);
                return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
            };
            const rt = (x) => {
                const n = Number(x?.rt_avg_ms);
                return Number.isFinite(n) ? n : Number.POSITIVE_INFINITY;
            };

            const sA = statusScore(a);
            const sB = statusScore(b);
            if (sA !== sB) return sA - sB; // Up first, Down last

            const pA = price(a);
            const pB = price(b);
            if (pA !== pB) return pA - pB; // lower price first

            const rtA = rt(a);
            const rtB = rt(b);
            return rtA - rtB; // faster first
        });
        try {
            await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...basePayload, top_services: sorted }),
            });
            appendPollLog("Sorted providers by price then latency and saved.\n\nPolling and sorting complete.");
        } catch (e) {
            /* ignore */
            appendPollLog(`Failed to save sorted providers: ${e}`);
        }
        await loadListeners();
        const summary = summaryEl();
        if (summary) summary.innerHTML = `Poll complete.`;
    }

    async function refreshTopServices(id) {
        if (!confirm("Refresh top services and check for new ones for this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/refresh-top-services`), {
                method: "POST",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            await loadListeners();
        } catch (err) {
            showResultModal("Refresh Top Services", `Failed to refresh: ${err}`);
        }
    }

    function formatServiceLabel(serviceId) {
        if (!serviceId) return "";
        const sid = String(serviceId);
        const match = serviceTypesCache.find((s) => String(s.service_id) === sid);
        if (!match || !match.service_type) return sid;
        const st = match.service_type;
        const desc = st.description || "";
        const name = st.name || "";
        if (desc) return desc;
        return name || sid;
    }

    function serviceOptionLabel(stItem) {
        if (!stItem) return "";
        const st = stItem.service_type || {};
        return st.description || st.name || stItem.service_name || stItem.service_id || "";
    }

    function renderServiceOptions(filterText = "") {
        const optionsEl = document.getElementById("svcComboOptions");
        const hiddenSelect = document.getElementById("listenerService");
        if (!optionsEl || !hiddenSelect) return;
        const filter = filterText.toLowerCase();
        let html = "";
        hiddenSelect.innerHTML = `<option value="">Select a service</option>`;
        (serviceTypesCache || []).forEach((item) => {
            const label = serviceOptionLabel(item);
            const sid = item.service_id;
            if (filter && !label.toLowerCase().includes(filter) && !String(sid).includes(filter)) return;
            html += `<div class="combo-option" data-id="${sid}" onclick="selectServiceOption('${sid}')">${escapeHtml(label)}</div>`;
            const opt = document.createElement("option");
            opt.value = sid;
            opt.textContent = label;
            hiddenSelect.appendChild(opt);
        });
        optionsEl.innerHTML = html || `<div class="combo-option muted">No matches</div>`;
    }

    function selectServiceOption(serviceId) {
        const hiddenSelect = document.getElementById("listenerService");
        const display = document.getElementById("svcComboSelected");
        if (hiddenSelect) {
            hiddenSelect.value = serviceId || "";
        }
        const label = formatServiceLabel(serviceId) || serviceId || "Select a service";
        if (display) display.textContent = label;
        closeServiceMenu();
    }

    function toggleServiceMenu(e) {
        e?.stopPropagation();
        const menu = document.getElementById("svcComboMenu");
        if (!menu) return;
        if (menu.classList.contains("hidden")) {
            openServiceMenu();
        } else {
            closeServiceMenu();
        }
    }

    function openServiceMenu() {
        const menu = document.getElementById("svcComboMenu");
        const search = document.getElementById("svcComboSearch");
        if (menu) menu.classList.remove("hidden");
        serviceMenuOpen = true;
        renderServiceOptions(search ? search.value : "");
        if (search) {
            search.value = "";
            search.focus();
        }
        document.addEventListener("click", handleOutsideServiceMenu, { once: true });
    }

    function closeServiceMenu() {
        const menu = document.getElementById("svcComboMenu");
        if (menu) menu.classList.add("hidden");
        serviceMenuOpen = false;
    }

    function handleOutsideServiceMenu(evt) {
        if (!serviceMenuOpen) return;
        const menu = document.getElementById("svcComboMenu");
        const display = document.getElementById("svcComboDisplay");
        if (!menu || !display) return;
        if (menu.contains(evt.target) || display.contains(evt.target)) {
            document.addEventListener("click", handleOutsideServiceMenu, { once: true });
            return;
        }
        closeServiceMenu();
    }

    function filterServiceOptions() {
        const search = document.getElementById("svcComboSearch");
        renderServiceOptions(search ? search.value : "");
    }

    function populateServiceSelect() {
        renderServiceOptions("");
        const first = serviceTypesCache && serviceTypesCache[0] ? serviceTypesCache[0].service_id : "";
        if (first) {
            selectServiceOption(first);
        }
    }

    function buildStatusSelect(selectedVal, elementId) {
        const opts = [
            { value: "active", label: "Active" },
            { value: "inactive", label: "Inactive" },
        ];
        const inner = opts.map(o => {
            const sel = String(selectedVal || "active").toLowerCase() === o.value ? "selected" : "";
            return `<option value="${o.value}" ${sel}>${o.label}</option>`;
        }).join("");
        return `<select id="${elementId || ""}" class="select">${inner}</select>`;
    }

    function refreshServiceTypesForSelect(selectId) {
        refreshServiceTypes(false, selectId);
    }

    document.addEventListener("focusin", (e) => {
        const sel = e.target.closest(".service-select");
        if (sel && sel.id) {
            refreshServiceTypesForSelect(sel.id);
        }
    });

</script>

</body>
</html>
