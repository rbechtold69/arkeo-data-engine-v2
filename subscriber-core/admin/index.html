<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Arkeo Data Marketplace | Subscriber Manager</title>
    <link rel="stylesheet" href="style.css">
    <link rel="icon" href="images/favicon.ico">
    <link rel="shortcut icon" href="images/favicon.ico">
</head>
<body>
<div class="page">

<div class="card header-card">
    <div class="row-between header-top">
            <div class="header-left">
                <div class="header-brand-row">
                    <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="header-logo">
                    <div class="header-brand">
                        <span class="brand-main">Arkeo Data Marketplace</span>
                        <span class="brand-sep">|</span>
                        <span class="brand-sub">Subscriber Manager</span>
                    </div>
                </div>
                <h1 id="headerMoniker"></h1>
                <div id="headerDescription" class="muted header-desc"></div>
            </div>
            <div class="header-right">
                <div class="header-line" id="headerPubkey">
                    <strong>Subscriber Pubkey:</strong>
                    <span class="inline"><span id="headerPubkeyValue"></span> <button class="copy-btn" onclick="copyPubkeyFromHeader()">Copy</button></span>
            </div>
            <div class="header-line" id="headerAddress">
                <strong>Subscriber Address:</strong>
                <span class="inline">
                    <span id="headerAddressValue"></span>
                    <button class="copy-btn" onclick="copyAddressFromHeader()">Copy</button>
                </span>
            </div>
            <div class="header-line" id="headerBalance"><strong>Subscriber Balance:</strong></div>
            <div class="header-line muted" id="headerBlock"><strong>Current Block:</strong></div>
            <div class="header-line fixed-pill"><span id="syncPill" class="status-badge status-warn hidden">Syncing...</span></div>
        </div>
    </div>
</div>

<div class="card">
    <h2>Arkeo Data Marketplace</h2>
    <div class="metrics-grid header-metrics">
        <div class="metric-card">
            <div class="metric-label">Active Providers</div>
            <div class="metric-value" id="metricProviders">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Active Services</div>
            <div class="metric-value" id="metricServices">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Contracts</div>
            <div class="metric-value" id="metricContracts">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Subscribers</div>
            <div class="metric-value" id="metricSubscribers">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-label">Supported Chains</div>
            <div class="metric-value" id="metricNodeTypes">–</div>
        </div>
        <div class="metric-card">
            <div class="metric-value"><button class="primary block-btn" id="cacheRefreshBtn" onclick="refreshCache()">Refresh</button></div>
        </div>
    </div>
</div>

<div class="card">
    <div class="row-between row-align-end">
        <div>
            <h2>Arkeo Subscriber Listeners</h2>
        </div>
        <div class="text-right">
            <div class="muted" id="listenerRange">Ports 62001-62100</div>
            <div class="muted small">Next available port: <span id="nextPortValue">–</span></div>
        </div>
    </div>
    <form id="listenerForm" class="listener-form" onsubmit="submitListenerForm(event)">
        <div class="listener-grid">
            <label>
                <div class="muted">Status</div>
                <select id="listenerStatus" class="select">
                    <option value="active">Active</option>
                    <option value="inactive">Inactive</option>
                </select>
                <div class="muted small">Active = serve, inactive = paused.</div>
            </label>
            <label>
                <div class="muted">Service Type</div>
                <select id="listenerService" class="select"></select>
                <div class="muted small">Choose an active service to bind.</div>
            </label>
            <label>
                <div class="muted">Whitelist IPs</div>
                <input id="listenerWhitelist" type="text" class="input" placeholder="0.0.0.0" />
                <div class="muted small">Empty = allow all, comma separated.</div>
            </label>
            <div class="listener-actions" style="align-self:flex-end;">
                <button type="submit" class="primary">Add Listener</button>
            </div>
        </div>
    </form>
<div id="listenersTable" class="mt-2"></div>
</div>

<div class="card footer-card">
    <div class="footer-links">
        <div class="footer-brand">
            <img src="images/arkeo-logo-200px_1.png" alt="Arkeo" class="footer-logo">
            <span class="footer-title">
                <span class="brand-main">Arkeo Marketplace</span>
                <span class="brand-sep">|</span>
                <span class="brand-sub">Provider Manager</span>
            </span>
        </div>
        <div class="footer-links-right">
            <div><a href="https://arkeo.network/" target="_blank" rel="noopener">Arkeo Marketplace Website</a></div>
            <div><a href="https://discord.gg/arkeo" target="_blank" rel="noopener">Arkeo Discord</a></div>
        </div>
    </div>
</div>

<div id="listenerLogs" class="section log-container"></div>

</div> <!-- /page -->

<div id="resultModal" class="overlay hidden">
    <div class="overlay-card modal-card">
        <h3 id="modalTitle">Result</h3>
        <div id="modalBody" class="modal-body"></div>
        <button class="primary" onclick="closeModal()">OK</button>
    </div>
</div>

<script>
    let currentPubkey = "";
    let currentAddress = "";

    function formatPubkeyShort(pubkey) {
        if (!pubkey || pubkey.length < 12) return pubkey || "";
        // Show first 10 and last 8 for a bit more context
        return `${pubkey.slice(0, 9)}...${pubkey.slice(-8)}`;
    }

    function formatAddressShort(addr) {
        if (!addr || addr.length < 12) return addr || "";
        return `${addr.slice(0, 6)}...${addr.slice(-8)}`;
    }

    function formatBalance(balanceObj) {
        const coins =
            (balanceObj && balanceObj.balance && balanceObj.balance.result && Array.isArray(balanceObj.balance.result) && balanceObj.balance.result) ||
            (balanceObj && balanceObj.balance && balanceObj.balance.balances && Array.isArray(balanceObj.balance.balances) && balanceObj.balance.balances) ||
            [];
        if (!coins.length) return "0.00000000 uarkeo";
        const fmtCoin = (c) => {
            const amount = c.amount || c.Amount || "";
            const denom = c.denom || c.Denom || "";
            if (denom === "uarkeo") {
                const num = parseInt(amount || "0", 10);
                const val = num / 1e8;
                return `${val.toLocaleString("en-US", { minimumFractionDigits: 8, maximumFractionDigits: 8 })} ${denom}`;
            }
            return `${amount}${denom}`;
        };
        return coins.map(fmtCoin).join(", ");
    }

    function formatBlockHeight(resp) {
        if (!resp || resp.error || !resp.height) return "(unavailable)";
        return resp.height.toString();
    }

    const API_PORT_DEFAULT = 9998;
    const apiPort = new URLSearchParams(window.location.search).get("api_port") || window.API_PORT || API_PORT_DEFAULT;
    const API_BASE = `${window.location.protocol}//${window.location.hostname}${apiPort ? ":" + apiPort : ""}`;
    const apiUrl = (path) => `${API_BASE}${path}`;

    function escapeHtml(str) {
        if (str === undefined || str === null) return "";
        return String(str)
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    async function refreshHeader() {
        const fetchNoStore = (url) => fetch(url, { cache: "no-store" });
        const parseSafe = async (settled) => {
            if (!settled || settled.status !== "fulfilled") return { error: "request failed" };
            try {
                if (!settled.value.ok) return { error: `${settled.value.status}` };
                return await settled.value.json();
            } catch (err) {
                return { error: String(err) };
            }
        };
            const [infoRes, balRes, heightRes] = await Promise.allSettled([
            fetchNoStore(apiUrl("/api/subscriber-info")),
            fetchNoStore(apiUrl("/api/balance")),
            fetchNoStore(apiUrl("/api/block-height")),
        ]);
        const info = await parseSafe(infoRes);
        const bal = await parseSafe(balRes);
        const height = await parseSafe(heightRes);

        const moniker = (info && info.subscriber_name) ||
            (info && info.provider_metadata && (info.provider_metadata.MONIKER || info.provider_metadata.PROVIDER_NAME)) || "";
        const desc = "";
        const bechPub = info && info.pubkey && info.pubkey.bech32;
        currentPubkey = bechPub || "";
        currentAddress = (info && info.address) || "";

        const headerMonikerEl = document.getElementById("headerMoniker");
        const headerDescEl = document.getElementById("headerDescription");
        const headerPubVal = document.getElementById("headerPubkeyValue");
        const headerAddrEl = document.getElementById("headerAddress");
        const headerBalEl = document.getElementById("headerBalance");
        const headerBlockEl = document.getElementById("headerBlock");

        if (headerMonikerEl) headerMonikerEl.textContent = moniker || "";
        if (headerDescEl) headerDescEl.textContent = desc || "";
        if (headerPubVal) headerPubVal.textContent = bechPub ? formatPubkeyShort(bechPub) : "(unavailable)";
        if (headerAddrEl) {
            const addrVal = currentAddress || "(unavailable)";
            const addrSpan = document.getElementById("headerAddressValue");
            if (addrSpan) addrSpan.textContent = formatAddressShort(addrVal);
        }
        if (headerBalEl) headerBalEl.innerHTML = `<strong>Subscriber Balance:</strong> ${formatBalance(bal)}`;
        if (headerBlockEl) headerBlockEl.innerHTML = `<strong>Current Block:</strong> ${formatBlockHeight(height)}`;

    }

    async function copyPubkeyFromHeader() {
        const val = currentPubkey || document.getElementById("headerPubkeyValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Pubkey", "Pubkey unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Pubkey";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Pubkey copied to clipboard:\n${val}`);
        } catch (e) {
            // fallback for non-HTTPS contexts
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Pubkey copied (fallback):\n${val}`);
            } else {
                showResultModal(msgTitle, `Failed to copy pubkey (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`);
            }
        }
    }

    async function copyAddressFromHeader() {
        const val = currentAddress || document.getElementById("headerAddressValue")?.textContent || "";
        if (!val || val === "(unavailable)") {
            showResultModal("Copy Subscriber Address", "Subscriber address unavailable");
            return;
        }
        const msgTitle = "Copy Subscriber Address";
        try {
            await navigator.clipboard.writeText(val);
            showResultModal(msgTitle, `Address copied to clipboard:\n${val}`);
        } catch (e) {
            const ta = document.createElement("textarea");
            ta.value = val;
            document.body.appendChild(ta);
            ta.select();
            let fallbackOk = false;
            try {
                fallbackOk = document.execCommand("copy");
            } catch (err) {
                fallbackOk = false;
            }
            document.body.removeChild(ta);
            if (fallbackOk) {
                showResultModal(msgTitle, `Address copied (fallback):\n${val}`);
            } else {
                showResultModal(msgTitle, `Failed to copy address (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`);
            }
        }
    }

    async function refreshCache() {
        const statusEl = document.getElementById("cacheStatus");
        const btn = document.getElementById("cacheRefreshBtn");
        const startMsg = `Starting cache refresh at ${new Date().toISOString()}...\n` +
            [
                "Providers: syncing...",
                "Contracts: syncing...",
                "Services: syncing...",
                "Active Providers: deriving...",
                "Active Services: deriving...",
                "Subscribers: deriving..."
            ].join("\n") +
            "\n\nPlease wait...";
        if (statusEl) statusEl.textContent = "Refreshing cache...";
        if (btn) btn.disabled = true;
        // keep syncing state across full refresh flow to avoid flicker
        setSyncingLocal(true);
        showResultModal("Cache Refresh", startMsg);
        try {
            const res = await fetch(apiUrl("/api/cache-refresh"), { method: "POST" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                const detail = (data && (data.detail || data.error)) || `${res.status}`;
                throw new Error(detail);
            }
            const results = (data && data.results) || {};
            const summarize = (key, payload) => {
                const tryParse = (val) => {
                    if (typeof val === "string") {
                        try { return JSON.parse(val); } catch (e) { return null; }
                    }
                    return val;
                };
                const pickList = (obj, candidates) => {
                    for (const c of candidates) {
                        const v = c && typeof c === "string" ? obj[c] : obj?.[c];
                        const parsed = tryParse(v);
                        if (Array.isArray(parsed)) return parsed;
                    }
                    return [];
                };
                if (!payload || typeof payload !== "object") return `${key}: (no data)`;
                let d = payload.data ?? payload;
                d = tryParse(d) ?? {};
                let items = [];
                if (Array.isArray(d)) {
                    items = d;
                } else if (typeof d === "object") {
                    if (key === "provider-services" || key === "providers" || key === "active_providers") {
                        items = pickList(d, ["providers", "provider", "result"]);
                    } else if (key === "provider-contracts" || key === "contracts") {
                        items = pickList(d, ["contracts", "contract", "result"]);
                    } else if (key === "active_services") {
                        items = pickList(d, ["active_services"]);
                    } else if (key === "service-types" || key === "services") {
                        // handle nested under data as well
                        items = pickList(d, ["services", "service", "result"]);
                        if (!items.length && d.data) {
                            items = pickList(d.data, ["services", "service", "result"]);
                        }
                    } else if (key === "subscribers") {
                        items = pickList(d, ["subscribers"]);
                    } else {
                        items = [];
                    }
                }
                const count = Array.isArray(items) ? items.length : 0;
                return `${key}: ${count || "(no data)"}`;
            };
            const orderedKeys = ["provider-services","provider-contracts","service-types","active_providers","active_services","subscribers"];
            const summary = orderedKeys.filter(k => k in results).map(k => summarize(k, results[k])).join("\n");
            const finishedMsg = `Finished cache refresh at ${new Date().toISOString()}\n${summary || "(no results)"}\n\nSync is complete, it is ok to close this modal window now.`;
            if (statusEl) statusEl.textContent = `Last refresh: ${new Date().toLocaleString()}`;
            updateModalBody(finishedMsg);
            // refresh header and listeners after cache refresh
            await refreshHeader();
            await loadListeners();
            // update metrics
            updateMetrics(results);
        } catch (err) {
            if (statusEl) statusEl.textContent = `Cache refresh failed: ${err}`;
            updateModalBody(`Failed to refresh cache:\n${err}`);
        } finally {
            if (btn) btn.disabled = false;
            setSyncingLocal(false);
        }
    }

    document.addEventListener("DOMContentLoaded", () => {
        refreshHeader();
        // Refresh every 10 seconds to mirror provider UI behavior
        setInterval(refreshHeader, 10000);
        loadListeners();
        // Keep listener table/logs fresh for dashboard view; skip while editing to avoid clobbering form state
        setInterval(() => { if (!listenersEditingId) loadListeners(); }, 5000);
        refreshServiceTypes(false);
        // try to populate metrics from initial cache-refresh data if present
        updateMetrics();
        // poll cache status to reflect background sync
        pollSyncStatus();
        setInterval(pollSyncStatus, 5000);
        // kick off a cache refresh on load
        refreshCache();
    });

    function showResultModal(title, body, asHtml = false) {
        const modal = document.getElementById("resultModal");
        const modalTitle = document.getElementById("modalTitle");
        const modalBody = document.getElementById("modalBody");
        if (modalTitle) modalTitle.textContent = title || "Result";
        if (modalBody) {
            if (asHtml) {
                modalBody.innerHTML = body || "";
            } else {
                modalBody.textContent = body || "";
            }
        }
        if (modal) modal.classList.remove("hidden");
    }

    function updateModalBody(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.textContent = body || "";
    }

    function updateModalBodyHtml(body) {
        const modalBody = document.getElementById("modalBody");
        if (modalBody) modalBody.innerHTML = body || "";
    }

    let syncingLocal = false;
    let syncingRemote = false;
    function updateSyncUI() {
        const pill = document.getElementById("syncPill");
        const btn = document.getElementById("cacheRefreshBtn");
        const isSyncing = syncingLocal || syncingRemote;
        if (pill) pill.classList[isSyncing ? "remove" : "add"]("hidden");
        if (btn) btn.disabled = isSyncing;
    }
    function setSyncingLocal(active) {
        syncingLocal = !!active;
        updateSyncUI();
    }
    function setSyncingRemote(active) {
        syncingRemote = !!active;
        updateSyncUI();
    }
    async function pollSyncStatus() {
        try {
            const statusRes = await fetch(apiUrl("/api/cache-status"), { cache: "no-store" });
            let wasSyncing = syncingRemote;
            if (statusRes.ok) {
                const data = await statusRes.json();
                const inProg = data && (data.in_progress === true || data.in_progress === "true");
                setSyncingRemote(!!inProg);
                // If a sync just finished, refresh service types to update dropdowns without a full reload
                if (wasSyncing && !inProg) {
                    refreshServiceTypes(true);
                }
            }
            const countsRes = await fetch(apiUrl("/api/cache-counts"), { cache: "no-store" });
            if (countsRes.ok) {
                const counts = await countsRes.json();
                // Update only the active providers, active services, and contracts counts to avoid jumping the UI
                updateMetrics(null, {
                    providers: counts.active_providers,
                    services: counts.active_services,
                    contracts: counts.contracts,
                    subscribers: counts.subscribers,
                    nodeTypes: counts.supported_chains,
                });
            }
        } catch (e) {
            // keep previous remote state on error
        }
    }

    function serviceIsActiveStatus(statusVal) {
        if (statusVal === undefined || statusVal === null) return true;
        if (typeof statusVal === "boolean") return !!statusVal;
        const s = String(statusVal).trim().toLowerCase();
        if (!s) return true;
        return ["1", "active", "online", "true", "on", "up", "running"].includes(s);
    }

    function countActiveServicesFromProviderServices(payload) {
        if (!payload || typeof payload !== "object") return null;
        const d = payload.data || payload;
        let providers = [];
        if (Array.isArray(d.providers)) providers = d.providers;
        else if (Array.isArray(d.provider)) providers = d.provider;
        let count = 0;
        for (const p of providers) {
            if (!p || typeof p !== "object") continue;
            const svcs = Array.isArray(p.services) ? p.services : Array.isArray(p.service) ? p.service : [];
            for (const s of svcs) {
                if (!s || typeof s !== "object") continue;
                const status = s.status !== undefined ? s.status : p.status;
                if (serviceIsActiveStatus(status)) count += 1;
            }
        }
        return count;
    }

    function updateMetrics(results, overrides) {
        const mProv = document.getElementById("metricProviders");
        const mSvc = document.getElementById("metricServices");
        const mCon = document.getElementById("metricContracts");
        const mSub = document.getElementById("metricSubscribers");
        const mNode = document.getElementById("metricNodeTypes");
        const getCount = (payload, keys) => {
            if (!payload || typeof payload !== "object") return null;
            const d = payload.data || payload;
            for (const k of keys) {
                const v = d[k];
                if (Array.isArray(v)) return v.length;
            }
            return null;
        };
        let activeSvcCount = null;
        if (results) {
            if ("active_services" in results) {
                const d = results["active_services"].data || results["active_services"];
                if (d && Array.isArray(d.active_services)) activeSvcCount = d.active_services.length;
            }
            if (activeSvcCount === null && "provider-services" in results) {
                const c = countActiveServicesFromProviderServices(results["provider-services"]);
                if (c !== null) activeSvcCount = c;
            }
            if (mProv && "provider-services" in results) {
                const c = getCount(results["provider-services"], ["providers", "provider"]);
                if (c !== null) mProv.textContent = c;
            }
            if (mProv && "active_providers" in results) {
                const d = results["active_providers"].data || results["active_providers"];
                if (d && Array.isArray(d.providers)) {
                    mProv.textContent = d.providers.length;
                }
            }
            if (mCon && "provider-contracts" in results) {
                const c = getCount(results["provider-contracts"], ["contracts", "contract"]);
                if (c !== null) mCon.textContent = c;
            }
            if (mSub && "subscribers" in results) {
                const d = results["subscribers"].data || results["subscribers"];
                if (d && Array.isArray(d.subscribers)) mSub.textContent = d.subscribers.length;
            }
            if (mSvc && "service-types" in results) {
                const c = getCount(results["service-types"], ["services", "service", "result", "data"]);
                if (mNode && c !== null) mNode.textContent = c;
            }
            if (mProv && "providers" in results) {
                const d = results["providers"];
                if (d && d.data && Array.isArray(d.data.providers)) {
                    mProv.textContent = d.data.providers.length;
                }
            }
        }
        if (mSvc && activeSvcCount !== null) {
            mSvc.textContent = activeSvcCount;
        }
        if (overrides) {
            if (mProv && overrides.providers !== undefined) mProv.textContent = overrides.providers;
            if (mSvc && overrides.services !== undefined) mSvc.textContent = overrides.services;
            if (mCon && overrides.contracts !== undefined) mCon.textContent = overrides.contracts;
            if (mSub && overrides.subscribers !== undefined) mSub.textContent = overrides.subscribers;
            if (mNode && overrides.nodeTypes !== undefined) mNode.textContent = overrides.nodeTypes;
        }
        if (mNode) mNode.textContent = mNode.textContent || "–";
    }
    function closeModal() {
        const modal = document.getElementById("resultModal");
        if (modal) modal.classList.add("hidden");
    }

    function copyListenerEndpoint(endpoint) {
        const title = "Copy Listener Endpoint";
        const val = endpoint || "";
        if (!val || val === "–") {
            showResultModal(title, "Endpoint unavailable");
            return;
        }
        const msg = val;
        const fallbackMsg = `Failed to copy endpoint (clipboard is blocked in insecure contexts).\n\nYou can copy it manually:\n${val}`;
        navigator.clipboard.writeText(msg).then(() => {
            showResultModal(title, `Endpoint copied:\n${val}`);
        }).catch(() => {
            try {
                const ta = document.createElement("textarea");
                ta.value = msg;
                document.body.appendChild(ta);
                ta.select();
                const ok = document.execCommand("copy");
                document.body.removeChild(ta);
                if (ok) {
                    showResultModal(title, `Endpoint copied:\n${val}`);
                    return;
                }
            } catch (e) {
                /* ignore */
            }
            showResultModal(title, fallbackMsg);
        });
    }

    // ─────────────────────────────
    // Listener registry UI helpers
    // ─────────────────────────────
    let listenersEditingId = null;
    let listenersCache = [];
    let serviceTypesCache = [];
    let lastServiceTypesFetch = 0;

    function serviceOptionsHtml(selectedId) {
        const opts = serviceTypesCache.map((s) => {
            const sid = s && (s.service_id ?? s.serviceID ?? s.id);
            if (sid === undefined || sid === null) return "";
            const label = formatServiceLabel(sid);
            const count = s && s.count !== undefined ? ` (${s.count} Active)` : "";
            const sel = String(selectedId || "") === String(sid) ? "selected" : "";
            return `<option value="${escapeHtml(String(sid))}" ${sel}>${escapeHtml(label + count)}</option>`;
        }).filter(Boolean).join("");
        return `<option value="">Select a service</option>${opts}`;
    }

    function updateSelectOptionsFromCache(selectEl) {
        if (!selectEl) return;
        const current = selectEl.value;
        selectEl.innerHTML = serviceOptionsHtml(current);
        if (current) selectEl.value = current;
    }

    async function refreshServiceTypes(rerenderTable = false, selectIdToUpdate = null, force = false) {
        const now = Date.now();
        const freshWindowMs = 5000;
        if (!force && now - lastServiceTypesFetch < freshWindowMs) {
            if (selectIdToUpdate) updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
            if (rerenderTable && !listenersEditingId) renderListenersTable();
            return;
        }
        try {
            const res = await fetch(apiUrl("/api/active-service-types"), { cache: "no-store" });
            if (!res.ok) return;
            const svcData = await res.json().catch(() => ({}));
            const list = svcData && svcData.active_service_types;
            if (Array.isArray(list)) {
                serviceTypesCache = list;
                lastServiceTypesFetch = Date.now();
                populateServiceSelect();
                if (selectIdToUpdate) {
                    updateSelectOptionsFromCache(document.getElementById(selectIdToUpdate));
                }
                if (rerenderTable && !listenersEditingId) {
                    renderListenersTable();
                }
            }
        } catch (e) {
            // ignore fetch errors; will retry on next trigger
        }
    }

    async function loadListeners() {
        try {
            const res = await fetch(apiUrl("/api/listeners"), { cache: "no-store" });
            const data = await res.json();
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersCache = Array.isArray(data.listeners) ? data.listeners : [];
            const nextPort = data.next_port || "n/a";
            const npEl = document.getElementById("nextPortValue");
            if (npEl) npEl.textContent = nextPort;
            const rangeEl = document.getElementById("listenerRange");
            if (rangeEl && Array.isArray(data.port_range) && data.port_range.length === 2) {
                rangeEl.textContent = `Ports ${data.port_range[0]}-${data.port_range[1]}`;
            }
            renderListenersTable();
            renderListenerLogs();
            if (!serviceTypesCache.length) {
                refreshServiceTypes(true);
            }
        } catch (err) {
            renderListenersTable(`Failed to load listeners: ${err}`);
        }
    }

    function renderListenersTable(errorText) {
        const container = document.getElementById("listenersTable");
        if (!container) return;
        if (errorText) {
            container.innerHTML = `<div class="muted">${escapeHtml(errorText)}</div>`;
            return;
        }
        if (!listenersCache.length) {
            container.innerHTML = `<div class="muted">No listeners yet. Add one to auto-assign the next open port.</div>`;
            return;
        }
        const rows = listenersCache.map((l) => {
            const isEditing = listenersEditingId === String(l.id);
            const targetSafe = escapeHtml(l.target || "");
            const portSafe = escapeHtml(l.port ?? "");
            const statusSafe = escapeHtml(l.status || "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id);
            const svcSelect = `<div class="muted">
                <div>${escapeHtml(svcLabel || "—")}</div>
                <div class="muted small">Service type cannot be changed after creation.</div>
                <input type="hidden" id="editService-${l.id}" value="${escapeHtml(l.service_id || "")}">
            </div>`;
            const statusSelect = buildStatusSelect(l.status, `editStatus-${l.id}`);
            const topServices = dedupTopServices(Array.isArray(l.top_services) ? l.top_services : []);
            const whitelist = l.whitelist_ips ? escapeHtml(l.whitelist_ips) : "0.0.0.0 (all)";
            const hostForListener = window.location.hostname || "localhost";
            const protoForListener = (window.location.protocol || "").startsWith("https") ? "https" : "http";
            const endpointUrl = portSafe ? `${protoForListener}://${hostForListener}:${portSafe}` : "–";
            const topServicesDisplay = topServices.length
                ? (() => {
                    const rows = topServices.map((bp, idx) => {
                        const mon = bp && bp.provider_moniker;
                        const fallbackName = mon || l.provider_moniker || (bp && bp.provider_pubkey) || "(unknown)";
                        const inactive = (!mon && !l.provider_moniker) || fallbackName === "(Inactive)";
                        const name = fallbackName;
                        const rate = bp && bp.pay_as_you_go_rate && bp.pay_as_you_go_rate.amount !== undefined
                            ? `${bp.pay_as_you_go_rate.amount}${bp.pay_as_you_go_rate.denom || ""} / tx`
                            : "";
                        const arrows = isEditing
                            ? `<div class="top-service-actions">
                                    <button class="copy-btn" ${idx === 0 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, -1)">↑</button>
                                    <button class="copy-btn" ${idx === topServices.length - 1 ? "disabled" : ""} onclick="moveTopService('${l.id}', ${idx}, 1)">↓</button>
                               </div>`
                            : "";
                        const statusVal = bp && bp.status ? String(bp.status) : "";
                        const statusDot = statusVal.toLowerCase() === "up"
                            ? '<span class="status-dot dot-ok"></span>'
                            : statusVal.toLowerCase() === "down"
                                ? '<span class="status-dot dot-err"></span>'
                                : "—";
                        let rtDisplay = "—";
                        if (bp && bp.rt_avg_ms !== undefined && bp.rt_avg_ms !== null) {
                            const avgMs = Number(bp.rt_avg_ms);
                            if (!Number.isNaN(avgMs)) {
                                rtDisplay = `${Math.round(avgMs)} ms`;
                            }
                        }
                        return `<tr>
                            <td class="ts-col-num">${idx + 1}</td>
                            <td class="ts-col-name">${escapeHtml(name)}${inactive ? " (Inactive)" : ""}</td>
                            <td class="ts-col-rate">${escapeHtml(rate)}</td>
                            <td class="ts-col-status">${statusDot}</td>
                            <td class="ts-col-rt">${escapeHtml(rtDisplay)}</td>
                            ${isEditing ? `<td class="ts-col-actions">${arrows}</td>` : ""}
                        </tr>`;
                    }).join("");
                    const head = isEditing
                        ? `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th><th></th></tr>`
                        : `<tr><th>#</th><th>Provider</th><th>Price</th><th>Status</th><th>Response Time</th></tr>`;
                    return `<table class="top-services-table">
                        <thead>${head}</thead>
                        <tbody>${rows}</tbody>
                    </table>`;
                })()
                : "—";
            if (isEditing) {
                return `
                <tbody class="listener-block">
                <tr class="listener-main">
                    <td class="col-status">${statusSelect}</td>
                    <td>
                        ${svcSelect}
                    </td>
                    <td class="mono">${portSafe || "–"}</td>
                    <td class="listener-actions-cell col-actions">
                        <div class="actions align-right">
                            <button class="primary" onclick="saveListener('${l.id}')">Save</button>
                            <button onclick="cancelEditListener()">Cancel</button>
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small" style="padding-bottom:4px;">Whitelist IPs:</div>
                        <input id="editWhitelist-${l.id}" class="input" value="${l.whitelist_ips ? escapeHtml(l.whitelist_ips) : ""}" placeholder="0.0.0.0" />
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small">Endpoint:</div>
                        <div class="muted endpoint-row">
                            <span class="mono">${escapeHtml(endpointUrl)}</span>
                            ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}
                        </div>
                    </td>
                </tr>
                <tr class="listener-sub">
                    <td colspan="4">
                        <div class="muted small">Top services (sorted by lowest PAYG):</div>
                        <div class="muted">${topServicesDisplay}</div>
                    </td>
                </tr>
                <tr class="listener-spacer"><td colspan="4"></td></tr>
                </tbody>`;
            }
            const statusDot = `<span class="status-dot ${String(l.status).toLowerCase() === "active" ? "dot-ok" : "dot-err"}"></span>`;
            return `
            <tbody class="listener-block">
            <tr class="listener-main">
                <td class="col-status">${statusDot}</td>
                <td>${escapeHtml(svcLabel || "—")}</td>
                <td class="mono">${portSafe || "–"}</td>
                <td class="listener-actions-cell col-actions">
                    <button class="btn-ghost" onclick="testListener('${l.id}')">Test</button>
                    <button class="btn-ghost" onclick="pollListener('${l.id}')">Poll</button>
                    <button class="primary" onclick="editListener('${l.id}')">Edit</button>
                    <button class="primary danger-btn" onclick="deleteListener('${l.id}')">Delete</button>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Whitelist IPs:</div>
                    <div class="muted">${whitelist}</div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Endpoint:</div>
                    <div class="muted endpoint-row">
                        <span class="mono">${escapeHtml(endpointUrl)}</span>
                        ${portSafe ? `<button class="copy-btn" onclick="copyListenerEndpoint('${escapeHtml(endpointUrl)}')">Copy</button>` : ""}
                    </div>
                </td>
            </tr>
            <tr class="listener-sub">
                <td colspan="4">
                    <div class="muted small">Top services:</div>
                    <div class="muted">${topServicesDisplay}</div>
                </td>
            </tr>
            <tr class="listener-spacer"><td colspan="4"></td></tr>
            </tbody>`;
        }).join("");
        container.innerHTML = `<div class="table-wrap">
            <table class="table listeners-table">
                <thead>
                    <tr><th class="col-status">Status</th><th>Service Type</th><th>Port</th><th class="col-actions">Actions</th></tr>
                </thead>
                <tbody>${rows}</tbody>
            </table>
        </div>`;
    }

    function resetListenerForm() {
        const svc = document.getElementById("listenerService");
        const status = document.getElementById("listenerStatus");
        const wl = document.getElementById("listenerWhitelist");
        if (svc) svc.value = "";
        if (status) status.value = "active";
        if (wl) wl.value = "";
    }

    async function submitListenerForm(evt) {
        evt.preventDefault();
        const svcId = document.getElementById("listenerService")?.value || "";
        if (!svcId) {
            alert("Please select a service type before adding a listener.");
            return;
        }
        const status = document.getElementById("listenerStatus")?.value || "active";
        const whitelist = document.getElementById("listenerWhitelist")?.value || "";
        const body = { status, whitelist_ips: whitelist };
        if (svcId) body.service_id = svcId;
        try {
            const res = await fetch(apiUrl("/api/listeners"), {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            resetListenerForm();
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Add Listener", `Failed to add listener: ${err}`);
        }
    }

    function editListener(id) {
        listenersEditingId = String(id);
        renderListenersTable();
    }

    function cancelEditListener() {
        listenersEditingId = null;
        renderListenersTable();
    }

    async function saveListener(id) {
        const svcIdInput = document.getElementById(`editService-${id}`);
        const svcId = (svcIdInput && svcIdInput.value) || "";
        const status = document.getElementById(`editStatus-${id}`)?.value || "";
        const whitelist = document.getElementById(`editWhitelist-${id}`)?.value || "";
        const current = listenersCache.find((l) => String(l.id) === String(id));
        const body = { status, whitelist_ips: whitelist };
        if (svcId) {
            body.service_id = svcId;
        } else if (current && current.service_id) {
            body.service_id = current.service_id;
        }
        if (current && Array.isArray(current.top_services)) {
            body.top_services = current.top_services;
        }
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(body),
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (data && data.error === "service_already_used") {
                    alert("That service type is already assigned to a listener.");
                    return;
                }
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Update Listener", `Failed to update listener: ${err}`);
        }
    }

    function moveTopService(listenerId, idx, delta) {
        const l = listenersCache.find((x) => String(x.id) === String(listenerId));
        if (!l || !Array.isArray(l.top_services)) return;
        const newIdx = idx + delta;
        if (newIdx < 0 || newIdx >= l.top_services.length) return;
        const arr = [...l.top_services];
        const [item] = arr.splice(idx, 1);
        arr.splice(newIdx, 0, item);
        l.top_services = arr;
        renderListenersTable();
    }

    async function deleteListener(id) {
        if (!confirm("Delete this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "DELETE",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            listenersEditingId = null;
            await loadListeners();
        } catch (err) {
            showResultModal("Delete Listener", `Failed to delete listener: ${err}`);
        }
    }

    // ─────────────────────────────
    // Listener logs
    // ─────────────────────────────
    function scrollLogToBottom(pre) {
        if (!pre) return;
        pre.scrollTop = pre.scrollHeight;
    }

    async function fetchListenerLog(id, elId) {
        const pre = document.getElementById(elId);
        if (pre) pre.textContent = "Loading log...";
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/logs?lines=200`), { cache: "no-store" });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                if (pre) pre.textContent = data && data.error ? `Error: ${data.error}` : `Error: ${res.status}`;
                scrollLogToBottom(pre);
                return;
            }
            const log = data && data.log ? data.log : "(no log)";
            if (pre) pre.textContent = log || "(no log)";
            scrollLogToBottom(pre);
        } catch (e) {
            if (pre) pre.textContent = `Error: ${e}`;
            scrollLogToBottom(pre);
        }
    }

    function renderListenerLogs() {
        const container = document.getElementById("listenerLogs");
        if (!container) return;
        if (!listenersCache.length) {
            container.innerHTML = "";
            return;
        }
        const cards = listenersCache.map((l) => {
            const portSafe = escapeHtml(l.port ?? "");
            const svcLabel = l.service_description || formatServiceLabel(l.service_id) || "";
            const logId = `log-${l.id}`;
            return `
            <div class="log-card">
                <div class="row-between" style="align-items: center;">
                    <h4>Port ${portSafe || "–"} ${svcLabel ? `| ${escapeHtml(svcLabel)}` : ""}</h4>
                    <div class="log-actions">
                        <button class="primary" onclick="fetchListenerLog('${l.id}', '${logId}')">Refresh</button>
                    </div>
            </div>
            <pre id="${logId}" class="log-pre">(loading...)</pre>
        </div>`;
        }).join("");
        container.innerHTML = cards;
        listenersCache.forEach((l) => fetchListenerLog(l.id, `log-${l.id}`));
    }

    async function runListenerTests(id, runs, titlePrefix, refreshAfter = false) {
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const port = listener && listener.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        const header = `
<div>${escapeHtml(titlePrefix || "Testing")} listener (${runs} runs)...</div>
<div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
        let summaryHtml = `<div class="muted small">Please wait...</div>`;
        let logText = "";
        const logContainer = () => document.getElementById("testLogPre");
        const summaryContainer = () => document.getElementById("testSummary");
        const appendLog = (line) => {
            logText = logText ? `${logText}\n${line}` : line;
            const pre = logContainer();
            if (pre) {
                pre.textContent = logText;
                pre.scrollTop = pre.scrollHeight;
            }
        };
        // open modal shell first
        showResultModal("Test Listener", "", true);
        const renderShell = () => {
            const shell = `${header}<div id="testSummary" class="muted small">${summaryHtml}</div><pre id="testLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(shell);
        };
        renderShell();
        const results = [];
        const successes = [];
        const failures = [];
        for (let i = 1; i <= runs; i++) {
            appendLog(`Run ${i}/${runs}: sending test request...`);
            try {
                const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), {
                    method: "GET",
                    cache: "no-store",
                });
                const data = await res.json().catch(() => ({}));
                const cmd = data && data.command ? data.command : "";
                const ok = res.ok && !(data && data.error && data.ok === false);
                const err = ok ? null : (data && (data.detail || data.error)) || res.statusText || res.status;
                let resp = data && data.response;
                let respPretty = resp || "(no data)";
                try {
                    if (typeof resp === "string") {
                        respPretty = JSON.stringify(JSON.parse(resp), null, 2);
                    } else if (resp && typeof resp === "object") {
                        respPretty = JSON.stringify(resp, null, 2);
                    }
                } catch (e) {
                    respPretty = resp || "(no data)";
                }
                results.push({
                    idx: i,
                    cmd,
                    err,
                    respPretty,
                    sentinel: data && data.sentinel_url,
                    provider: data && data.provider_pubkey,
                    providerMon: data && data.provider_moniker,
                    serviceId: data && data.service_id,
                    serviceName: data && data.service_name,
                    sentinelTarget: data && data.sentinel_target,
                    candidateSentinel: data && data.candidate_sentinel,
                    candidateProvider: data && data.candidate_provider,
                    lastCode: data && data.last_code,
                    lastNonce: data && data.last_nonce,
                    lastNonceSource: data && data.last_nonce_source,
                    lastNonceCache: data && data.last_nonce_cache,
                    lastCandProvider: data && data.last_candidate_provider,
                    lastCandSentinel: data && data.last_candidate_sentinel,
                    arkeoNonce: data && data.arkeo_nonce,
                    arkeoContractId: data && data.arkeo_contract_id,
                    arkeoCost: data && data.arkeo_cost,
                    respHeaders: data && data.response_headers,
                    nonceCached: data && data.nonce_cached,
                    nonceCacheKey: data && data.nonce_cache_key,
                });
                if (err) {
                    failures.push(i);
                } else {
                    successes.push(i);
                }
            } catch (e) {
                results.push({
                    idx: i,
                    cmd: "",
                    err: String(e),
                    respPretty: "(no data)",
                });
                failures.push(i);
            }
            summaryHtml = `<div class="muted small">Success: ${successes.length ? successes.join(", ") : "0"} | Failed: ${failures.length ? failures.join(", ") : "0"}</div>`;
            const summaryEl = summaryContainer();
            if (summaryEl) summaryEl.innerHTML = summaryHtml;
            const metaLines = [];
            const last = results[results.length - 1] || {};
            const sentinelDisplay = last.candidateSentinel || last.lastCandSentinel || last.sentinel_target || last.sentinel;
            if (sentinelDisplay) {
                metaLines.push(`Sentinel: ${sentinelDisplay}`);
            }
            const providerDisplay = last.provider || last.candidateProvider || last.lastCandProvider;
            const providerMonDisplay = last.providerMon;
            if (providerDisplay) metaLines.push(`Provider: ${providerDisplay}${providerMonDisplay ? ` (${providerMonDisplay})` : ""}`);
            if (last.serviceId || last.serviceName) {
                metaLines.push(`Service: ${last.serviceName || ""}${last.serviceId ? ` [${last.serviceId}]` : ""}`);
            }
            if (last.lastNonce !== undefined && last.lastNonce !== null) {
                metaLines.push(`Last nonce used: ${last.lastNonce}`);
            }
            if (last.lastNonceSource) {
                metaLines.push(`Nonce source: ${last.lastNonceSource}${last.lastNonceCache !== undefined && last.lastNonceCache !== null ? ` (cache now ${last.lastNonceCache})` : ""}`);
            }
            if (last.arkeoNonce) {
                metaLines.push(`Nonce (from response): ${last.arkeoNonce}`);
            }
            if (last.nonceCached !== undefined && last.nonceCached !== null) {
                metaLines.push(`Nonce cache: ${last.nonceCached}${last.nonceCacheKey ? ` [${last.nonceCacheKey}]` : ""}`);
            }
            if (last.lastCode !== undefined && last.lastCode !== null) {
                metaLines.push(`Last upstream code: ${last.lastCode}`);
            }
            if (last.activeContractId) {
                metaLines.push(`Active contract: ${last.activeContractId}${last.activeContractHeight ? ` @height ${last.activeContractHeight}` : ""}`);
                if (last.activeContractProvider) {
                    metaLines.push(`Contract provider: ${last.activeContractProvider}`);
                }
                if (last.activeContractService) {
                    metaLines.push(`Contract service: ${last.activeContractService}`);
                }
            }
            if (last.arkeoContractId) {
                metaLines.push(`Contract (from response): ${last.arkeoContractId}`);
            }
            if (last.arkeoCost) {
                metaLines.push(`Cost (from response): ${last.arkeoCost}`);
            }
            const metaText = metaLines.length ? metaLines.join("\n") + "\n" : "";
            const block = [
                `--- Run ${i} ---`,
                `Command: ${results[results.length - 1].cmd || ""}`,
                metaText ? metaText.trimEnd() : null,
                results[results.length - 1].err ? `Error: ${results[results.length - 1].err}` : `Response:\n${results[results.length - 1].respPretty}`
            ].filter(Boolean).join("\n");
            appendLog(block);
        }
        // Final summary update
        const summaryEl = summaryContainer();
        if (summaryEl) summaryEl.innerHTML = `<div class="muted small">Test complete.</div>${summaryHtml}`;
        appendLog("All test runs finished.");
        if (refreshAfter) {
            await loadListeners();
        }
    }

    function dedupTopServices(list) {
        const seen = new Set();
        const out = [];
        for (const item of Array.isArray(list) ? list : []) {
            const key = `${item?.provider_pubkey || ""}::${item?.service_id || item?.service || ""}`;
            if (seen.has(key)) continue;
            seen.add(key);
            out.push(item);
        }
        return out;
    }

    async function testListener(id) {
        await runListenerTests(id, 3, "Testing", true);
    }

    async function pollListener(id) {
        const listener = listenersCache.find((l) => String(l.id) === String(id));
        const top = listener && Array.isArray(listener.top_services) ? dedupTopServices(listener.top_services) : [];
        // modal shell
        const port = listener?.port ? listener.port : "–";
        const svcLabel = listener
            ? (listener.service_description || formatServiceLabel(listener.service_id) || listener.service_name || listener.service_id || "")
            : "";
        let pollLogText = "";
        const logEl = () => document.getElementById("pollLogPre");
        const summaryEl = () => document.getElementById("pollSummary");
        const renderPollShell = (summaryText = "Starting poll...") => {
            const header = `<div>Polling listener...</div><div class="muted small">Port: ${escapeHtml(String(port))}${svcLabel ? ` • Service: ${escapeHtml(String(svcLabel))}` : ""}</div>`;
            const body = `${header}<div id="pollSummary" class="muted small">${escapeHtml(summaryText)}</div><pre id="pollLogPre" class="mono" style="max-height:50vh;overflow:auto;"></pre>`;
            updateModalBodyHtml(body);
        };
        const appendPollLog = (line) => {
            pollLogText = pollLogText ? `${pollLogText}\n${line}` : line;
            const pre = logEl();
            if (pre) {
                pre.textContent = pollLogText;
                pre.scrollTop = pre.scrollHeight;
            }
        };
        showResultModal("Poll Listener", "", true);
        renderPollShell();
        if (!top.length) {
            appendPollLog("No providers to poll; running a single test instead.");
            await testListener(id);
            return;
        }
        const primary = top[0] || {};
        const inferredSvc = listener?.service_id || listener?.service || primary.service_id || primary.service || "";
        const basePayload = {
            status: "active",
            service_id: inferredSvc,
            whitelist_ips: listener?.whitelist_ips || "",
        };
        let workingTop = dedupTopServices(JSON.parse(JSON.stringify(top)));
        for (const ts of workingTop) {
            const providerLabel = ts?.provider_moniker || ts?.provider_pubkey || "(unknown)";
            appendPollLog(`Provider: ${providerLabel} (${ts?.provider_pubkey || "n/a"})`);
            // reorder so this provider is first
            const reordered = dedupTopServices([ts, ...workingTop.filter((t) => {
                const keyT = `${t?.provider_pubkey || ""}::${t?.service_id || t?.service || ""}`;
                const keyTs = `${ts?.provider_pubkey || ""}::${ts?.service_id || ts?.service || ""}`;
                return keyT !== keyTs;
            })]);
            try {
                await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                    method: "PUT",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({ ...basePayload, top_services: reordered }),
                });
                appendPollLog("  reordered list to prioritize this provider");
            } catch (e) {
                // ignore reorder errors, proceed
                appendPollLog(`  reorder failed: ${e}`);
            }
            // run a few tests for this provider, respecting qpm if present
            const qpm = ts && ts.queries_per_minute ? Number(ts.queries_per_minute) : 0;
            const spacingMs = qpm > 0 ? Math.max(200, Math.round(60000 / qpm)) : 400;
            const runs = 3;
            for (let i = 0; i < runs; i++) {
                try {
                    const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/test`), { method: "GET", cache: "no-store" });
                    const ok = res.ok;
                    const data = await res.json().catch(() => ({}));
                    const err = !ok ? (data && (data.detail || data.error)) || res.statusText || res.status : "";
                    appendPollLog(`  test ${i + 1}/${runs}: ${ok ? "ok" : `error ${err}`}`);
                } catch (e) {
                    appendPollLog(`  test ${i + 1}/${runs}: error ${e}`);
                }
                await new Promise(res => setTimeout(res, spacingMs));
            }
            await loadListeners();
            const refreshed = listenersCache.find((l) => String(l.id) === String(id));
            if (refreshed && Array.isArray(refreshed.top_services)) {
                workingTop = dedupTopServices(JSON.parse(JSON.stringify(refreshed.top_services)));
            }
        }
        // sort by cheapest then lowest latency using the freshest cache after polling
        const latest = listenersCache.find((l) => String(l.id) === String(id));
        const latestTop = dedupTopServices(latest && Array.isArray(latest.top_services) ? latest.top_services : []);
        const sorted = [...latestTop].sort((a, b) => {
            const rateA = (a?.pay_as_you_go_rate && a.pay_as_you_go_rate.amount !== undefined) ? Number(a.pay_as_you_go_rate.amount) : Number.POSITIVE_INFINITY;
            const rateB = (b?.pay_as_you_go_rate && b.pay_as_you_go_rate.amount !== undefined) ? Number(b.pay_as_you_go_rate.amount) : Number.POSITIVE_INFINITY;
            if (rateA !== rateB) return rateA - rateB;
            const rtA = a?.rt_avg_ms !== undefined ? Number(a.rt_avg_ms) : Number.POSITIVE_INFINITY;
            const rtB = b?.rt_avg_ms !== undefined ? Number(b.rt_avg_ms) : Number.POSITIVE_INFINITY;
            return rtA - rtB;
        });
        try {
            await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}`), {
                method: "PUT",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...basePayload, top_services: sorted }),
            });
            appendPollLog("Sorted providers by price then latency and saved.\n\nPolling and sorting complete.");
        } catch (e) {
            /* ignore */
            appendPollLog(`Failed to save sorted providers: ${e}`);
        }
        await loadListeners();
        const summary = summaryEl();
        if (summary) summary.innerHTML = `Poll complete.`;
    }

    async function refreshTopServices(id) {
        if (!confirm("Refresh top services and check for new ones for this listener?")) return;
        try {
            const res = await fetch(apiUrl(`/api/listeners/${encodeURIComponent(id)}/refresh-top-services`), {
                method: "POST",
            });
            const data = await res.json().catch(() => ({}));
            if (!res.ok || (data && data.error)) {
                throw new Error((data && (data.detail || data.error)) || res.status);
            }
            await loadListeners();
        } catch (err) {
            showResultModal("Refresh Top Services", `Failed to refresh: ${err}`);
        }
    }

    function formatServiceLabel(serviceId) {
        if (!serviceId) return "";
        const sid = String(serviceId);
        const match = serviceTypesCache.find((s) => String(s.service_id) === sid);
        if (!match || !match.service_type) return sid;
        const st = match.service_type;
        const desc = st.description || "";
        const name = st.name || "";
        if (desc) return desc;
        return name || sid;
    }

    function buildServiceSelect(selectedId, elementId) {
        const opts = serviceOptionsHtml(selectedId);
        const selId = elementId || "";
        return `<select id="${selId}" class="select service-select" data-select-id="${selId}">${opts}</select>`;
    }

    function populateServiceSelect() {
        const select = document.getElementById("listenerService");
        if (!select) return;
        updateSelectOptionsFromCache(select);
        if (select.options.length) select.selectedIndex = 0;
    }

    function buildStatusSelect(selectedVal, elementId) {
        const opts = [
            { value: "active", label: "Active" },
            { value: "inactive", label: "Inactive" },
        ];
        const inner = opts.map(o => {
            const sel = String(selectedVal || "active").toLowerCase() === o.value ? "selected" : "";
            return `<option value="${o.value}" ${sel}>${o.label}</option>`;
        }).join("");
        return `<select id="${elementId || ""}" class="select">${inner}</select>`;
    }

    function refreshServiceTypesForSelect(selectId) {
        refreshServiceTypes(false, selectId);
    }

    document.addEventListener("focusin", (e) => {
        const sel = e.target.closest(".service-select");
        if (sel && sel.id) {
            refreshServiceTypesForSelect(sel.id);
        }
    });
</script>

</body>
</html>
